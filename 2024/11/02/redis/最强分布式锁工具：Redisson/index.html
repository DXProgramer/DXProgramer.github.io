<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/next_favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/next_favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"dxprogramer.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":280},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。">
<meta property="og:type" content="article">
<meta property="og:title" content="最强分布式锁工具：Redisson">
<meta property="og:url" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/index.html">
<meta property="og:site_name" content="Xiangger">
<meta property="og:description" content="Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/1.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/2.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/3.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/4.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/5.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/6.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/7.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/8.jpg">
<meta property="og:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/9.jpg">
<meta property="article:published_time" content="2024-11-02T13:41:11.000Z">
<meta property="article:modified_time" content="2024-11-03T03:52:35.626Z">
<meta property="article:author" content="Xiangger">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="高并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/1.jpg">


<link rel="canonical" href="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/","path":"2024/11/02/redis/最强分布式锁工具：Redisson/","title":"最强分布式锁工具：Redisson"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>最强分布式锁工具：Redisson | Xiangger</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Xiangger</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">业精于勤，荒于嬉；行成于思，毁于随</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedisson%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是Redisson？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lua%E8%84%9A%E6%9C%AC"><span class="nav-number">2.1.</span> <span class="nav-text">lua脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-number">2.2.</span> <span class="nav-text">可重入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">Redisson分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RLock"><span class="nav-number">3.1.</span> <span class="nav-text">RLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RLock%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%EF%BC%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">RLock如何加锁？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FairSync"><span class="nav-number">5.</span> <span class="nav-text">FairSync</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JUC%E4%BB%A5%E9%BB%98%E8%AE%A4%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%91%A2%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么JUC以默认非公平锁呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedissonFairLock"><span class="nav-number">5.2.</span> <span class="nav-text">RedissonFairLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%A8%A1%E6%8B%9F"><span class="nav-number">5.3.</span> <span class="nav-text">2.模拟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xiangger"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xiangger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/DXProgramer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DXProgramer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:13554742813@163.com" title="E-Mail → mailto:13554742813@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/your_weibo" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;your_weibo" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxprogramer.github.io/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xiangger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiangger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="最强分布式锁工具：Redisson | Xiangger">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          最强分布式锁工具：Redisson
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-02 21:41:11" itemprop="dateCreated datePublished" datetime="2024-11-02T21:41:11+08:00">2024-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-03 11:52:35" itemprop="dateModified" datetime="2024-11-03T11:52:35+08:00">2024-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p>
<span id="more"></span>

<h3 id="什么是Redisson？"><a href="#什么是Redisson？" class="headerlink" title="什么是Redisson？"></a>什么是Redisson？</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p>
<p>其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。</p>
<p>Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。</p>
<p>Redisson和Jedis、Lettuce有什么区别？</p>
<ul>
<li>Jedis是Redis官方推出的用于通过Java连接Redis客户端的一个工具包，提供了Redis的各种命令支持</li>
<li>Lettuce是一种可扩展的线程安全的 Redis 客户端，通讯框架基于Netty，支持高级的 Redis 特性，比如哨兵，集群，管道，自动重新连接和Redis数据模型。Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</li>
<li>Redisson是架设在Redis基础上，通讯基于Netty的综合的、新型的中间件，企业级开发中使用Redis的最佳范本。</li>
</ul>
<p>Jedis把Redis命令封装好，Lettuce则进一步有了更丰富的Api，也支持集群等模式。但是两者也都点到为止，只给了你操作Redis数据库的脚手架，而Redisson则是基于Redis、Lua和Netty建立起了成熟的分布式解决方案，甚至redis官方都推荐的一种工具集。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>以Spring Data Redis为例，用RedisTemplate来操作Redis（setIfAbsent已经是setNx + expire的合并命令），如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key, String value, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁，防止删错别人的锁，以uuid为value校验是否自己的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockName, String uuid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(lockName)) &#123;        </span><br><span class="line">           redisTemplate.opsForValue().del(lockName);    </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构</span></span><br><span class="line"><span class="keyword">if</span>(tryLock)&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是锁没错，但get和del操作非原子性，并发一旦大了，无法保证进程安全（获取已被其他线程删除的锁）。</p>
<h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><p>解决方案使用Lua脚本，Lua脚本是redis已经内置的一种轻量小巧语言，其执行是通过redis的<strong>eval</strong>&#x2F;<strong>evalsha</strong>命令来运行，把操作封装成一个Lua脚本，封装为一次执行的原子操作。</p>
<p>通过Lua脚本删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    then </span><br><span class="line"> -- 执行删除操作</span><br><span class="line">        <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"> -- 不成功，返回<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>delete操作时执行Lua命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁脚本</span></span><br><span class="line">DefaultRedisScript&lt;Object&gt; unlockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">unlockScript</span><br><span class="line">    .setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lockDel.lua&quot;</span>)));</span><br><span class="line"><span class="comment">// 执行lua脚本解锁</span></span><br><span class="line">redisTemplate.execute(unlockScript, Collections.singletonList(keyName), value);</span><br></pre></td></tr></table></figure>

<p>优化后似乎更像一把锁，但好像又缺少了什么，synchronized和ReentrantLock都很丝滑，因为他们都是可重入锁，一个线程多次拿锁也不会死锁，我们需要可重入。</p>
<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>重入就是，同一个线程多次获取同一把锁是允许的，不会造成死锁，这一点synchronized偏向锁提供了很好的思路，synchronized的实现重入是在JVM层面，JAVA对象头MARK WORD中便藏有线程ID和计数器来对当前线程做重入判断，避免每次CAS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向</span><br><span class="line">锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁标志是否设置成<span class="number">1</span>：没有则CAS竞争；设置了，则CAS将对象头偏向锁指向当前线程。再维护一个计数器，同个线程进入则自增<span class="number">1</span>，离开</span><br><span class="line">再减<span class="number">1</span>，直到为<span class="number">0</span>才能释放。</span><br></pre></td></tr></table></figure>

<p>仿造该方案，改造Lua脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要存储锁名称lockName、获得该锁的线程id和对应线程的进入次数count</span><br><span class="line"><span class="number">2.</span>加锁</span><br><span class="line">    每次线程获取锁时，判断是否已存在该锁</span><br><span class="line">    	<span class="number">1</span>）不存在</span><br><span class="line">    		设置hash的key为线程id，value初始化为<span class="number">1</span></span><br><span class="line">    		设置过期时间</span><br><span class="line">    		返回获取锁成功<span class="literal">true</span></span><br><span class="line">    	<span class="number">2</span>）存在</span><br><span class="line">    		继续判断是否存在当前线程id的hash key</span><br><span class="line">    		存在，线程key的value + <span class="number">1</span>，重入次数增加<span class="number">1</span>，设置过期时间</span><br><span class="line">    		不存在，返回加锁失败<span class="literal">false</span></span><br><span class="line"><span class="number">3.</span>解锁</span><br><span class="line">    每次线程来解锁时，判断是否已存在该锁</span><br><span class="line">    	<span class="number">1</span>）存在</span><br><span class="line">    		是否有该线程的id的hash key，有则减<span class="number">1</span>，无则返回解锁失败</span><br><span class="line">    		减<span class="number">1</span>后，判断剩余count是否为<span class="number">0</span>，为<span class="number">0</span>则说明不再需要这把锁，执行del命令删除</span><br></pre></td></tr></table></figure>

<p>为了方便维护这个对象，我们用Hash结构来存储这些字段。Redis的Hash类似Java的HashMap，适合存储对象。</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/1.jpg"></p>
<p>设置一个名字为<strong>lockname1</strong>的hash结构，该hash结构key为<strong>threadId</strong>，值value为<strong>1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset lockname1 threadId <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>获取lockname1的threadId的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget lockname1 threadId</span><br></pre></td></tr></table></figure>

<p>存储结构为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lockname 锁名称</span><br><span class="line">    key1：    threadId   唯一键，线程id</span><br><span class="line">    value1：  count      计数器，记录该线程获取锁的次数</span><br></pre></td></tr></table></figure>

<p>redis中的结构</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/2.jpg"></p>
<p><strong>计数器的加减</strong></p>
<p>当同一个线程获取同一把锁时，我们需要对对应线程的计数器count做加减，判断一个redis key是否存在，可以用<code>exists</code>，而判断一个hash的key是否存在，可以用<code>hexists</code></p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/3.jpg"></p>
<p>而redis也有hash自增的命令<code>hincrby</code>，每次自增1时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby lockname1 threadId <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>自减1时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby lockname1 threadId -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/4.jpg"></p>
<p><strong>解锁的判断</strong></p>
<p>当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除。综合上述的存储结构和判断流程，加锁和解锁Lua如下。</p>
<p>加锁 lock.lua：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">threadId</span> <span class="operator">=</span> ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">releaseTime</span> <span class="operator">=</span> ARGV[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">-- lockname不存在</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) then</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 当前线程已id存在</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) then</span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>解锁 unlock.lua：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">threadId</span> <span class="operator">=</span> ARGV[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">-- lockname、threadId不存在</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">0</span>) then</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 计数器-<span class="number">1</span></span><br><span class="line"><span class="type">local</span> <span class="variable">count</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">-- 删除lock</span><br><span class="line"><span class="title function_">if</span> <span class="params">(count == <span class="number">0</span>)</span> then</span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 原生redis实现分布式锁</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Long&gt; lockScript;</span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Object&gt; unlockScript;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="comment">// 加载加锁的脚本</span></span><br><span class="line">        lockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.lockScript</span><br><span class="line">            .setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        <span class="built_in">this</span>.lockScript.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        unlockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.unlockScript</span><br><span class="line">            <span class="title function_">setScriptSource</span><span class="params">(new ResourceScriptSource(new ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>)</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tryLock</span><span class="params">(String lockName, <span class="type">long</span> releaseTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 存入的线程信息的前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) redisTemplate.execute(</span><br><span class="line">                lockScript,</span><br><span class="line">                Collections.singletonList(lockName),</span><br><span class="line">                key + Thread.currentThread().getId(),</span><br><span class="line">                releaseTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockName, String key)</span> &#123;</span><br><span class="line">        redisTemplate.execute(unlockScript,</span><br><span class="line">                Collections.singletonList(lockName),</span><br><span class="line">                key + Thread.currentThread().getId()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此已经完成了一把分布式锁，符合互斥、可重入、防死锁的基本特点。</p>
<p>虽然当个普通互斥锁，已经稳稳够用，可是业务里总是又很多特殊情况的，<strong>比如A进程在获取到锁的时候，因业务操作时间太长，锁释放了但是业务还在执行，而此刻B进程又可以正常拿到锁做业务操作，两个进程操作就会存在依旧有共享资源的问题</strong>。而且如果负责储存这个分布式锁的<strong>Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态</strong>。</p>
<p>在这种情况时，希望可以延长锁的releaseTime延迟释放锁来直到完成业务期望结果，这种不断延长锁过期时间来保证业务执行完成的操作就是锁续约。</p>
<p>读写分离也是常见，一个读多写少的业务为了性能，常常是有读锁和写锁的。</p>
<h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><p>依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原生，本章使用--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 另一种Spring集成starter，本章未使用 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">getRedisson</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().</span><br><span class="line">                setAddress(<span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:&quot;</span> + port).</span><br><span class="line">                setPassword(password);</span><br><span class="line">        config.setCodec(<span class="keyword">new</span> <span class="title class_">JsonJacksonCodec</span>());</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启用分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(lockName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> rLock.tryLock(expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简洁明了，只需要一个RLock。</p>
<h4 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h4><p>RLock是Redisson分布式锁的最核心接口，继承了concurrent包的Lock接口和自己的RLockAsync接口，RLockAsync的返回值都是RFuture，是Redisson执行异步实现的核心逻辑，也是Netty发挥的主要阵地。</p>
<h5 id="RLock如何加锁？"><a href="#RLock如何加锁？" class="headerlink" title="RLock如何加锁？"></a>RLock如何加锁？</h5><p>从RLock进入，找到RedissonLock类，找到<strong>tryLock</strong>方法再递进到干事的<strong>tryAcquireOnceAsync</strong>方法，这是加锁的主要代码（版本不一此处实现有差别，和最新3.15.x有一定出入，但是核心逻辑依然未变。此处以3.13.6为例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RFuture&lt;Boolean&gt; <span class="title function_">tryAcquireOnceAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, </span><br><span class="line">                                          RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; ttlRemainingFuture = </span><br><span class="line">            <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg()</span><br><span class="line">                                       .getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, </span><br><span class="line">                                       RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此处出现leaseTime时间判断的2个分支，实际上就是加锁时是否设置过期时间，未设置过期时间（-1）时则会有<strong>watchDog</strong>的<strong>锁续约</strong>（下文），一个注册了加锁事件的续约任务。我们先来看有过期时间<strong>tryLockInnerAsync</strong>部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, </span></span><br><span class="line"><span class="params">                                 RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, </span><br><span class="line">                                                   command, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]</span><br><span class="line">                                                   &#123;<span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里揭开真面目，eval命令执行Lua脚本的地方，此处的Lua脚本展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 不存在该key时</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) then </span><br><span class="line">  -- 新增该锁并且hash中该线程id对应的count置<span class="number">1</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  -- 设置过期时间</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> nil; </span><br><span class="line">end; </span><br><span class="line"></span><br><span class="line">-- 存在该key 并且 hash中线程id的key也存在</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) then </span><br><span class="line">  -- 线程重入次数++</span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> nil; </span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>和前面我们写自定义的分布式锁的脚本几乎一致，看来redisson也是一样的实现，具体参数分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keyName</span></span><br><span class="line">KEYS[<span class="number">1</span>] = Collections.singletonList(<span class="built_in">this</span>.getName())</span><br><span class="line"><span class="comment">// leaseTime</span></span><br><span class="line">ARGV[<span class="number">1</span>] = <span class="built_in">this</span>.internalLockLeaseTime</span><br><span class="line"><span class="comment">// uuid+threadId组合的唯一值</span></span><br><span class="line">ARGV[<span class="number">2</span>] = <span class="built_in">this</span>.getLockName(threadId)</span><br></pre></td></tr></table></figure>

<p>总共3个参数完成了一段逻辑：</p>
<p>判断该锁是否已经有对应hash表存在，</p>
<p>• 没有对应的hash表：则set该hash表中一个entry的key为锁名称，value为1，之后设置该hash表失效时间为leaseTime</p>
<p>• 存在对应的hash表：则将该lockName的value执行+1操作，也就是计算进入次数，再设置失效时间leaseTime</p>
<p>• 最后返回这把锁的ttl剩余时间</p>
<p>那解锁的步骤也肯定有对应的-1操作，再看unlock方法，同样查找方法名，一路到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;</span>, Arrays.asList(<span class="built_in">this</span>.getName(), <span class="built_in">this</span>.getChannelName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;LockPubSub.unlockMessage, <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>掏出Lua部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 不存在key</span><br><span class="line"><span class="title function_">if</span> <span class="params">(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>])</span> == <span class="number">0</span>) then </span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line">-- 计数器 -<span class="number">1</span></span><br><span class="line"><span class="type">local</span> <span class="variable">counter</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], -<span class="number">1</span>); </span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) then </span><br><span class="line">  -- 过期时间重设</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  -- 删除并发布解锁消息</span><br><span class="line">  redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">  redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> nil;</span><br></pre></td></tr></table></figure>

<p>该Lua KEYS有2个<code>Arrays.asList(getName(), getChannelName())</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name 锁名称</span><br><span class="line">channelName，用于pubSub发布消息的channel名称</span><br></pre></td></tr></table></figure>

<p>ARGV变量有三个<code>LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LockPubSub.UNLOCK_MESSAGE，channel发送消息的类别，此处解锁为<span class="number">0</span></span><br><span class="line">internalLockLeaseTime，watchDog配置的超时时间，默认为30s</span><br><span class="line">lockName 这里的lockName指的是uuid和threadId组合的唯一值</span><br></pre></td></tr></table></figure>

<p>步骤如下：</p>
<p>1.如果该锁不存在则返回nil；</p>
<p>2.如果该锁存在则将其线程的hash key计数器-1，</p>
<p>3.计数器counter&gt;0，重置下失效时间，返回0；否则，删除该锁，发布解锁消息unlockMessage，返回1；</p>
<p>其中unLock的时候使用到了Redis发布订阅PubSub完成消息通知。</p>
<p>而订阅的步骤就在RedissonLock的加锁入口的lock方法里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(-<span class="number">1L</span>, leaseTime, unit, threadId);</span><br><span class="line">        <span class="keyword">if</span> (ttl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 订阅</span></span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; future = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                <span class="built_in">this</span>.commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.commandExecutor.syncSubscription(future);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure>

<p>当锁被其他线程占用时，通过监听锁的释放通知（在其他线程通过RedissonLock释放锁时，会通过发布订阅pub&#x2F;sub功能发起通知），等待锁被其他线程释放，也是为了避免自旋的一种常用效率手段。</p>
<p><strong>解锁消息</strong></p>
<p>为了一探究竟通知了什么，通知后又做了什么，进入LockPubSub。</p>
<p>这里只有一个明显的监听方法onMessage，其订阅和信号量的释放都在父类PublishSubscribe，我们只关注监听事件的实际操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> &#123;</span><br><span class="line">        Runnable runnableToExecute;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(unlockMessage)) &#123;</span><br><span class="line">            <span class="comment">// 从监听器队列取监听线程执行监听回调</span></span><br><span class="line">            runnableToExecute = (Runnable)value.getListeners().poll();</span><br><span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="literal">null</span>) &#123;</span><br><span class="line">                runnableToExecute.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// getLatch()返回的是Semaphore，信号量，此处是释放信号量</span></span><br><span class="line">            <span class="comment">// 释放信号量后会唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span><br><span class="line">            value.getLatch().release();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(readUnlockMessage)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                runnableToExecute = (Runnable)value.getListeners().poll();</span><br><span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="literal">null</span>) &#123;</span><br><span class="line">                    value.getLatch().release(value.getLatch().getQueueLength());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                runnableToExecute.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现一个是<strong>默认解锁消息</strong>，一个是<strong>读锁解锁消息</strong>，因为redisson是有提供读写锁的，而读写锁读读情况和读写、写写情况互斥情况不同，我们只看上面的默认解锁消息unlockMessage分支，LockPubSub监听最终执行了2件事</p>
<p><code>1、runnableToExecute.run()</code> 执行监听回调</p>
<p><code>2、value.getLatch().release();</code> 释放信号量</p>
<p>Redisson通过<strong>LockPubSub</strong>监听解锁消息，执行监听回调和释放信号量通知等待线程可以重新抢锁。</p>
<p>这时再回来看tryAcquireOnceAsync另一分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RFuture&lt;Boolean&gt; <span class="title function_">tryAcquireOnceAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无超时时间时，在执行加锁操作后，还执行了一段费解的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)                   &#125;                 &#125;             &#125;)</span><br></pre></td></tr></table></figure>

<p>此处涉及到Netty的Future&#x2F;Promise-Listener模型，Redisson中几乎全部以这种方式通信（所以说Redisson是基于Netty通信机制实现的），理解这段逻辑可以试着先理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 call()或 run()执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。</span><br></pre></td></tr></table></figure>

<p>这块代码的表面意义就是，在执行异步加锁的操作后，加锁成功则根据加锁完成返回的ttl是否过期来确认是否执行一段定时任务。这段定时任务的就是watchDog的核心。</p>
<p>锁续约</p>
<p>查看<code>RedissonLock.this.scheduleExpirationRenewal(threadId)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>.ExpirationEntry();</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">        <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEntry.addThreadId(threadId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.addThreadId(threadId);</span><br><span class="line">            <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                            RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                        RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            ee.setTimeout(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拆分来看，这段连续嵌套且冗长的代码实际上做了几步</p>
<p>• 添加一个netty的Timeout回调任务，每（<code>internalLockLeaseTime / 3</code>）毫秒执行一次，执行的方法是<code>renewExpirationAsync</code></p>
<p>• <code>renewExpirationAsync</code>重置了锁超时时间，又注册一个监听器，监听回调又执行了<code>renewExpiration</code></p>
<p><code>renewExpirationAsync</code> 的Lua如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) then </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>重新设置了超时时间。</p>
<p>Redisson加这段逻辑的目的是什么？</p>
<p>目的是为了某种场景下保证业务不影响，如任务执行超时但未结束，锁已经释放的问题。</p>
<p><strong>当一个线程持有了一把锁，由于并未设置超时时间leaseTime，Redisson默认配置了30S，开启watchDog，每10S对该锁进行一次续约，维持30S的超时时间，直到任务完成再删除锁。</strong></p>
<p>这就是Redisson的<strong>锁续约</strong>，也就是<strong>WatchDog</strong>实现的基本思路。</p>
<p><strong>流程概括</strong></p>
<p>通过整体的介绍，流程简单概括：</p>
<p>1、A、B线程争抢一把锁，A获取到后，B阻塞</p>
<p>2、B线程阻塞时并非主动CAS，而是PubSub方式订阅该锁的广播消息</p>
<p>3、A操作完成释放了锁，B线程收到订阅消息通知</p>
<p>4、B被唤醒开始继续抢锁，拿到锁</p>
<p>详细加锁解锁流程总结如下图：</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/5.jpg"></p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>以上介绍的可重入锁是非公平锁，Redisson还基于Redis的队列（List）和ZSet实现了公平锁</p>
<p><strong>公平的定义是什么？</strong></p>
<p>公平就是按照客户端的请求先来后到排队来获取锁，先到先得，也就是FIFO，所以队列和容器顺序编排必不可少</p>
<h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a><strong>FairSync</strong></h3><p>回顾JUC的ReentrantLock公平锁的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS已经提供了整个实现，是否公平取决于实现类取出节点逻辑是否顺序取</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/6.jpg"></p>
<p>AbstractQueuedSynchronizer是用来构建锁或者其他同步组件的基础框架，通过内置FIFO队列来完成资源获取线程的排队工作，他自身没有实现同步接口，仅仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用（上图），支持独占和共享获取，这是基于模版方法模式的一种设计，给公平&#x2F;非公平提供了土壤。</p>
<p>我们用2张图来简单解释AQS的等待流程（出自《JAVA并发编程的艺术》）</p>
<p>一张是同步队列（FIFO双向队列）<strong>管理 获取同步状态失败（抢锁失败）的线程引用、等待状态和前驱后继节点的流程图</strong></p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/7.jpg"></p>
<p>一张是<strong>独占式获取同步状态的总流程</strong>，核心acquire(int arg)方法调用流程</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/8.jpg"></p>
<p>可以看出锁的获取流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AQS维护一个同步队列，获取状态失败的线程都会加入到队列中进行自旋，移出队列或停止自旋的条件是前驱节点为头节点切成功获取了同步状态。</span><br></pre></td></tr></table></figure>

<p>而比较另一段非公平锁类<code>NonfairSync</code>可以发现，控制公平和非公平的关键代码，在于<code>hasQueuedPredecessors</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NonfairSync</code>减少了了<code>hasQueuedPredecessors</code>判断条件，该方法的作用就是</p>
<p><strong>查看同步队列中当前节点是否有前驱节点，如果有比当前线程更早请求获取锁则返回true。</strong></p>
<p><strong>保证每次都取队列的第一个节点（线程）来获取锁，这就是公平规则</strong></p>
<h4 id="为什么JUC以默认非公平锁呢？"><a href="#为什么JUC以默认非公平锁呢？" class="headerlink" title="为什么JUC以默认非公平锁呢？"></a>为什么JUC以默认非公平锁呢？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为当一个线程请求锁时，只要获取来同步状态即成功获取。在此前提下，刚释放的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。但这样带来的好处是，非公平锁大大减少了系统线程上下文的切换开销。</span><br></pre></td></tr></table></figure>

<p>可见公平的代价是性能与吞吐量。</p>
<p>Redis里没有AQS，但是有List和zSet，看看Redisson是怎么实现公平的。</p>
<h4 id="RedissonFairLock"><a href="#RedissonFairLock" class="headerlink" title="RedissonFairLock"></a>RedissonFairLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redissonClient.getFairLock(lockName);</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure>

<p><code>RedissonFairLock</code>继承自<code>RedissonLock</code>，同样一路向下找到加锁实现方法<strong>tryLockInnerAsync</strong>。</p>
<p>这里有2段冗长的Lua，但是Debug发现，公平锁的入口在 <code>command == RedisCommands.EVAL_LONG</code> 之后，此段Lua较长，参数也多，我们着重分析Lua的实现规则</p>
<p><strong>参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- lua中的几个参数</span><br><span class="line">KEYS = Arrays.&lt;Object&gt;asList(getName(), threadsQueueName, timeoutSetName)</span><br><span class="line">KEYS[<span class="number">1</span>]: lock_name, 锁名称                   </span><br><span class="line">KEYS[<span class="number">2</span>]: <span class="string">&quot;redisson_lock_queue:&#123;xxx&#125;&quot;</span>  线程队列</span><br><span class="line">KEYS[<span class="number">3</span>]: <span class="string">&quot;redisson_lock_timeout:&#123;xxx&#125;&quot;</span>  线程id对应的超时集合</span><br><span class="line"></span><br><span class="line">ARGV =  internalLockLeaseTime, getLockName(threadId), currentTime + threadWaitTime, currentTime</span><br><span class="line">ARGV[<span class="number">1</span>]: <span class="string">&quot;&#123;leaseTime&#125;&quot;</span> 过期时间</span><br><span class="line">ARGV[<span class="number">2</span>]: <span class="string">&quot;&#123;Redisson.UUID&#125;:&#123;threadId&#125;&quot;</span>   </span><br><span class="line">ARGV[<span class="number">3</span>] = 当前时间 + 线程等待时间:（<span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span>） + <span class="number">5000</span>毫秒 = <span class="number">10</span>:<span class="number">00</span>:<span class="number">05</span></span><br><span class="line">ARGV[<span class="number">4</span>] = 当前时间（<span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span>）  部署服务器时间，非redis-server服务器时间</span><br></pre></td></tr></table></figure>

<p>公平锁实现的Lua脚本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="number">1.</span>死循环清除过期key</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  -- 获取头节点</span><br><span class="line">    <span class="type">local</span> <span class="variable">firstThreadId2</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>);</span><br><span class="line">    -- 首次获取必空跳出循环</span><br><span class="line">  <span class="keyword">if</span> firstThreadId2 == <span class="literal">false</span> then </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  end;</span><br><span class="line">  -- 清除过期key</span><br><span class="line">  <span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2));</span><br><span class="line">  <span class="keyword">if</span> timeout &lt;= tonumber(ARGV[<span class="number">4</span>]) then</span><br><span class="line">    redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2);</span><br><span class="line">    redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  end;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">2.</span>不存在该锁 &amp;&amp; （不存在线程等待队列 || 存在线程等待队列而且第一个节点就是此线程ID)，加锁部分主要逻辑</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) and </span><br><span class="line">  ((redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">2</span>]) == <span class="number">0</span>)  or (redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>) == ARGV[<span class="number">2</span>])) then</span><br><span class="line">  -- 弹出队列中线程id元素，删除Zset中该线程id对应的元素</span><br><span class="line">  redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]);</span><br><span class="line">  redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">local</span> <span class="variable">keys</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;zrange&#x27;</span>, KEYS[<span class="number">3</span>], <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">  -- 遍历zSet所有key，将key的超时时间(score) - 当前时间ms</span><br><span class="line">  <span class="type">for</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, #keys, <span class="number">1</span> <span class="keyword">do</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;zincrby&#x27;</span>, KEYS[<span class="number">3</span>], -tonumber(ARGV[<span class="number">3</span>]), keys[i]);</span><br><span class="line">  end;</span><br><span class="line">    -- 加锁设置锁过期时间</span><br><span class="line">  redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">3.</span>线程存在，重入判断</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">4.</span>返回当前线程剩余存活时间</span><br><span class="line"><span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> timeout ~= <span class="literal">false</span> then</span><br><span class="line">  -- 过期时间timeout的值在下方设置，此处的减法算出的依旧是当前线程的ttl</span><br><span class="line">  <span class="keyword">return</span> timeout - tonumber(ARGV[<span class="number">3</span>]) - tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">5.</span>尾节点剩余存活时间</span><br><span class="line"><span class="type">local</span> <span class="variable">lastThreadId</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], -<span class="number">1</span>);</span><br><span class="line">local ttl;</span><br><span class="line">-- 尾节点不空 &amp;&amp; 尾节点非当前线程</span><br><span class="line"><span class="keyword">if</span> lastThreadId ~= <span class="literal">false</span> and lastThreadId ~= ARGV[<span class="number">2</span>] then</span><br><span class="line">  -- 计算队尾节点剩余存活时间</span><br><span class="line">  ttl = tonumber(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], lastThreadId)) - tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  -- 获取lock_name剩余存活时间</span><br><span class="line">  ttl = redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">6.</span>末尾排队</span><br><span class="line">-- zSet 超时时间（score），尾节点ttl + 当前时间 + 5000ms + 当前时间，无则新增，有则更新</span><br><span class="line">-- 线程id放入队列尾部排队，无则插入，有则不再插入</span><br><span class="line"><span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> ttl + tonumber(ARGV[<span class="number">3</span>]) + tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">3</span>], timeout, ARGV[<span class="number">2</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;rpush&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">end;</span><br><span class="line"><span class="keyword">return</span> ttl;</span><br></pre></td></tr></table></figure>

<p>公平锁加锁步骤</p>
<p>通过以上Lua，可以发现，lua操作的关键结构是列表（list）和有序集合（zSet）。</p>
<p>其中list维护了一个等待的线程队列<code>redisson_lock_queue:&#123;xxx&#125;</code>，zSet维护了一个线程超时情况的有序集合<code>redisson_lock_timeout:&#123;xxx&#125;</code>，尽管lua较长，但是可以拆分为6个步骤</p>
<p><strong>1.队列清理</strong></p>
<ul>
<li>保证队列中只有未过期的等待线程</li>
</ul>
<p><strong>2.首次加锁</strong></p>
<ul>
<li>hset加锁，pexpire过期时间</li>
</ul>
<p><strong>3.重入判断</strong></p>
<ul>
<li>此处同可重入锁lua</li>
</ul>
<p><strong>4.返回ttl</strong></p>
<p><strong>5.计算尾节点ttl</strong></p>
<ul>
<li>初始值为锁的剩余过期时间</li>
</ul>
<p><strong>6.末尾排队</strong></p>
<ul>
<li><code>ttl + 2 * currentTime + waitTime</code>是score的默认值计算公式</li>
</ul>
<h4 id="2-模拟"><a href="#2-模拟" class="headerlink" title="2.模拟"></a>2.模拟</h4><p>如果模拟以下顺序，就会明了redisson公平锁整个加锁流程</p>
<p>假设 <code>t1 10:00:00 &lt; t2 10:00:10 &lt; t3 10:00:20</code></p>
<p>t1：当线程1初次获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列无头节点，跳出死循环-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁 &amp;&amp; 不存在线程等待队列 成立</span><br><span class="line">    <span class="number">2.1</span> lpop和zerm、zincrby都是无效操作，只有加锁生效，说明是首次加锁，加锁后返回nil加锁成功，线程<span class="number">1</span></span><br><span class="line">    获取到锁，结束</span><br></pre></td></tr></table></figure>

<p>t2：线程2尝试获取锁（线程1未释放锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.等待队列无头节点，跳出死循环-&gt;2</span><br><span class="line">2.不存在该锁 不成立-&gt;3</span><br><span class="line">3.非重入线程 -&gt;4</span><br><span class="line">4.score无值 -&gt;5</span><br><span class="line">5.尾节点为空，设置ttl初始值为lock_name的ttl -&gt; 6</span><br><span class="line">6.按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列，线程</span><br><span class="line">2为头节点score = 20S + 5000ms + 10:00:10 + 10:00:10 = 10:00:35 + 10:00:10</span><br></pre></td></tr></table></figure>

<p>t3：线程3尝试获取锁（线程1未释放锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列有头节点</span><br><span class="line">    <span class="number">1.1</span>未过期-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁不成立-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3.</span>非重入线程-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4.</span>score无值 -&gt;<span class="number">5</span></span><br><span class="line"><span class="number">5.</span>尾节点不为空 &amp;&amp; 尾节点线程为<span class="number">2</span>，非当前线程</span><br><span class="line">    <span class="number">5.1</span>取出之前设置的score，减去当前时间：ttl = score - currentTime -&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6.</span>按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列</span><br><span class="line">    score = 10S + 5000ms + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>如此一来，三个需要抢夺一把锁的线程，完成了一次排队，在list中排列他们等待线程id，在zSet中存放过期时间（便于排列优先级）。其中返回ttl的线程2客户端、线程3客户端将会一直按一定间隔自旋重复执行该段Lua，尝试加锁，如此一来便和AQS有了异曲同工之处。</p>
<p>而当线程1释放锁之后（这里依旧有通过Pub&#x2F;Sub发布解锁消息，通知其他线程获取）</p>
<p>10:00:30 线程2尝试获取锁（线程1已释放锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列有头节点，未过期-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁 &amp; 等待队列头节点是当前线程 成立</span><br><span class="line">    <span class="number">2.1</span>删除当前线程的队列信息和zSet信息，超时时间为：</span><br><span class="line">    	线程<span class="number">2</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">10</span> - <span class="number">10</span>:<span class="number">00</span>:<span class="number">30</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">15</span></span><br><span class="line">        线程<span class="number">3</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> - <span class="number">10</span>:<span class="number">00</span>:<span class="number">30</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">25</span></span><br><span class="line">    <span class="number">2.2</span>线程<span class="number">2</span>获取到锁，重新设置过期时间加锁成功，线程<span class="number">2</span>获取到锁，结束</span><br></pre></td></tr></table></figure>

<p>排队结构如图</p>
<p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/9.jpg"></p>
<p>公平锁的释放脚本和重入锁类似，多了一步加锁开头的清理过期key的while true逻辑，在此不再展开篇幅描述。</p>
<p>由上可以看出，Redisson公平锁的玩法类似于延迟队列的玩法，核心都在Redis的List和zSet结构的搭配，但又借鉴了AQS实现，在定时判断头节点上如出一辙（watchDog），保证了锁的竞争公平和互斥。并发场景下，lua脚本里，zSet的score很好地解决了顺序插入的问题，排列好优先级。</p>
<p>并且为了防止因异常而退出的线程无法清理，每次请求都会判断头节点的过期情况给予清理，最后释放时通过CHANNEL通知订阅线程可以来获取锁，重复一开始的步骤，顺利交接到下一个顺序线程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redisson整体实现分布式加解锁流程的实现稍显复杂，作者Rui Gu对Netty和JUC、Redis研究深入，利用了很多高级特性和语义，值得深入学习，本次介绍也只是单机Redis下锁实现。</p>
<p>Redisson也提供了多机情况下的联锁MultiLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/redisson/redisson/wiki/8.-分布式锁和同步器#81-可重入锁reentrant-lock</span></span><br></pre></td></tr></table></figure>

<p>和官方推荐的红锁RedLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/redisson/redisson/wiki/8.-分布式锁和同步器#84-红锁redlock</span></span><br></pre></td></tr></table></figure>

<p>所以，当你真的需要分布式锁时，不妨先来Redisson里找找。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KeXXL6bag1uRcLJj4s3trg">https://mp.weixin.qq.com/s/KeXXL6bag1uRcLJj4s3trg</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%94%81/" rel="tag"><i class="fa fa-tag"></i> 锁</a>
              <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 高并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/02/redis/Redis%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E6%93%8D%E4%BD%9C%E5%92%8C%E9%98%B2%E6%AD%A2%E8%A2%AB%E8%B6%85%E5%8D%96%EF%BC%9F/" rel="prev" title="如何实现库存扣减操作和防止被超卖？">
                  <i class="fa fa-angle-left"></i> 如何实现库存扣减操作和防止被超卖？
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81/" rel="next" title="自旋锁">
                  自旋锁 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="DXProgramer/hexo-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Xiangger</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">371k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:37</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- 樱花特效 -->
  
      <script async src="/js/fairyDustCursor.js"></script>
  
</body>
</html>
