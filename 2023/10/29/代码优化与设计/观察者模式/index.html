<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/next_favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/next_favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"dxprogramer.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":280},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="观察者模式定义观察者模式，也可以称之为发布订阅模式，它在GoF 的《设计模式》中，是这么定义的： 12Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically。  观察者">
<meta property="og:type" content="article">
<meta property="og:title" content="观察者模式">
<meta property="og:url" content="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Xiangger">
<meta property="og:description" content="观察者模式定义观察者模式，也可以称之为发布订阅模式，它在GoF 的《设计模式》中，是这么定义的： 12Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically。  观察者">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.png">
<meta property="og:image" content="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2.png">
<meta property="article:published_time" content="2023-10-29T14:47:18.000Z">
<meta property="article:modified_time" content="2024-10-26T06:17:30.775Z">
<meta property="article:author" content="Xiangger">
<meta property="article:tag" content="观察者模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.png">


<link rel="canonical" href="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","path":"2023/10/29/代码优化与设计/观察者模式/","title":"观察者模式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>观察者模式 | Xiangger</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Xiangger</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">业精于勤，荒于嬉；行成于思，毁于随</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">观察者模式定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">观察者模式的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">如何实现一个简单的观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84"><span class="nav-number">4.</span> <span class="nav-text">工作中，如何使用观察者模式的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F%E7%9A%84%E8%A7%82%E5%AF%9F%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">同步阻塞方式的观察模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">异步非阻塞方式的观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">spring观察者模式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.1.</span> <span class="nav-text">Spring观察者模式原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Espring%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8A%BD%E5%8F%96%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.4.</span> <span class="nav-text">基于spring观察者模式，抽取一个模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Event%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.1.</span> <span class="nav-text">定义Event事件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Listener%E7%9B%91%E5%90%AC%E8%80%85%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%89"><span class="nav-number">4.4.2.</span> <span class="nav-text">定义Listener监听者（观察者）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Publisher%E5%8F%91%E9%80%81%E8%80%85%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.4.3.</span> <span class="nav-text">定义Publisher发送者模板</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xiangger"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xiangger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/DXProgramer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DXProgramer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:13554742813@163.com" title="E-Mail → mailto:13554742813@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/your_weibo" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;your_weibo" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxprogramer.github.io/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xiangger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiangger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="观察者模式 | Xiangger">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          观察者模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-29 22:47:18" itemprop="dateCreated datePublished" datetime="2023-10-29T22:47:18+08:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-26 14:17:30" itemprop="dateModified" datetime="2024-10-26T14:17:30+08:00">2024-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="观察者模式定义"><a href="#观察者模式定义" class="headerlink" title="观察者模式定义"></a><strong>观察者模式定义</strong></h2><p>观察者模式，也可以称之为<strong>发布订阅模式</strong>，它在GoF 的《设计模式》中，是这么定义的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Define a one-to-many dependency between objects so that when one object changes state,</span><br><span class="line">all its dependents are notified and updated automatically。</span><br></pre></td></tr></table></figure>

<p><strong>观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新</strong>。</p>
<span id="more"></span>

<p>观察者模式属于<strong>行为模式</strong>，一个对象（<strong>被观察者</strong>）的状态发生改变，所有的依赖对象（<strong>观察者对象</strong>）都将得到通知，进行广播通知。它的主要成员就是<strong>观察者和被观察者</strong>。</p>
<ul>
<li>被观察者（Observerable）：目标对象，状态发生变化时，将通知所有的观察者。</li>
<li>观察者（observer）：接受被观察者的状态变化通知，执行预先定义的业务。</li>
</ul>
<h2 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a><strong>观察者模式的应用场景</strong></h2><p>日常开发中，观察者模式的使用场景主要表现在：完成一件事情后，通知处理某个逻辑。如，<strong>登陆成功发个IM消息</strong>，<strong>支付成功发个邮件消息或者发个抽奖消息</strong>，<strong>用户评论成功给他发个积分</strong>等等。</p>
<p>详细点的例子:<strong>登陆注册</strong>应该是最常见的业务场景了，我们就拿注册来说事，大家经常会遇到类似的场景，就是用户注册成功后，我们给用户发一条<code>IM</code>消息，又或者发个邮件等等，因此经常有如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">  insertRegisterUser（user）;</span><br><span class="line">  sendIMMessage();</span><br><span class="line">  sendEmail()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码会有什么问题呢？如果产品又加需求：现在注册成功的用户，再给用户发一条短信通知。于是你又得改<code>register</code>方法的代码了。。。这是不是违反了<strong>开闭原则</strong>啦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">  insertRegisterUser（user）;</span><br><span class="line">  sendIMMessage();</span><br><span class="line">  sendMobileMessage（）;</span><br><span class="line">  sendEmail()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，如果调发短信的接口失败了，是不是又影响到用户注册了？！这时候，是不是得加个<strong>异步方法</strong>，异步发通知消息才好？？其实这种场景，我们可以使用<strong>异步非阻塞的观察者模式</strong>优化的。</p>
<h2 id="如何实现一个简单的观察者模式"><a href="#如何实现一个简单的观察者模式" class="headerlink" title="如何实现一个简单的观察者模式"></a><strong>如何实现一个简单的观察者模式</strong></h2><p>我们先来看下，简单的观察者模式如何实现。可以这么定义</p>
<ul>
<li>一个主题接口<code>Subject</code>（声明添加、删除、通知观察者方法）</li>
<li>一个<code>Observer</code>观察者接口</li>
<li>一个创建主题的类<code>ObserverableImpl</code>（即被观察者），实现了<code>Subject</code>接口</li>
<li>各个观察者的差异化实现</li>
</ul>
<p>为了通俗易懂，可以这样理解观察者模式：就是被观察者（<code>ObserverableImpl</code>）做了一件事情，或者说发布了一个主题（<code>Subject</code>），然后这件事情通知到各个相关的不同的人（不同的观察者，<code>Observer</code>的差异化实现者）。</p>
<p><img src="/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.png" alt="图片"></p>
<p><strong>主题接口:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>观察者接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个创建主题的类<code>ObserverableImpl</code>（即被观察者），同时有观察者列表的属性（其实就是说观察者要事先注册到被观察者）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverableImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储被观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>观察者的差异化</strong>实现，以及使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverOneImpl</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ObserverOne is notified,&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverTwoImpl</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ObserverTwo is notified,&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverDemoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverableImpl</span>();</span><br><span class="line">        <span class="comment">//添加观察者</span></span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">ObserverOneImpl</span>());</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">ObserverTwoImpl</span>());</span><br><span class="line">        <span class="comment">//通知</span></span><br><span class="line">        subject.notifyAllObservers(<span class="string">&quot;关注公众号:捡田螺的小男孩&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">ObserverOne is notified,关注公众号:捡田螺的小男孩</span><br><span class="line">ObserverTwo is notified,关注公众号:捡田螺的小男孩</span><br></pre></td></tr></table></figure>

<h2 id="工作中，如何使用观察者模式的"><a href="#工作中，如何使用观察者模式的" class="headerlink" title="工作中，如何使用观察者模式的"></a><strong>工作中，如何使用观察者模式的</strong></h2><p>观察者模式的实现有两种方式，同步阻塞方式和异步非阻塞方式。第3小节就是一个<strong>同步阻塞方式</strong>的观察者模式。我们来看下，日常工作的例子：<strong>用户注册成功发消息的例子，如何实现</strong>。本小节分同步阻塞、异步阻塞、spring观察者模式三个方向探讨。</p>
<ul>
<li>同步阻塞方式的观察模式</li>
<li>异步非阻塞方式的观察者模式</li>
<li>spring观察者模式应用</li>
</ul>
<h3 id="同步阻塞方式的观察模式"><a href="#同步阻塞方式的观察模式" class="headerlink" title="同步阻塞方式的观察模式"></a>同步阻塞方式的观察模式</h3><p>我们可以把<strong>用户注册</strong>，当做<strong>被观察者</strong>实现的逻辑，然后<strong>发消息</strong>就是<strong>观察者的实现逻辑</strong>。</p>
<p>假设有两个观察者，分别是发QQ消息和手机消息，于是有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverMobileImpl</span> <span class="keyword">implements</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送手机短信消息&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverQQImpl</span> <span class="keyword">implements</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送QQ消息&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接可以通过<code>spring</code>的<code>ApplicationContextAware</code>，初始化观察者列表，然后用户注册成功，通知观察者即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//观察者列表</span></span><br><span class="line">     <span class="keyword">private</span> Collection&lt;RegisterObserver&gt; regObservers;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(&quot;register&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">          <span class="comment">//注册成功过（类似于被观察者，做了某件事）</span></span><br><span class="line">          userService.addUser(userParam);</span><br><span class="line">          <span class="comment">//然后就开始通知各个观察者。</span></span><br><span class="line">          <span class="keyword">for</span>(RegisterObserver temp:regObservers)&#123;</span><br><span class="line">               temp.sendMsg(<span class="string">&quot;注冊成功&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//利用spring的ApplicationContextAware，初始化所有观察者</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">          regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，观察者模式，就是将不同的行为代码解耦，也就是说<strong>将观察者和被观察者代码解耦</strong>。但是这里大家会发现，这是<strong>同步阻塞式的观察者模式</strong>，是有缺点的，比如发QQ消息异常，就会影响用户注册，或者发消息因为某些原因耗时，就影响了用户注册，所以可以考虑<strong>异步非阻塞</strong>的观察者模式。</p>
<h3 id="异步非阻塞方式的观察者模式"><a href="#异步非阻塞方式的观察者模式" class="headerlink" title="异步非阻塞方式的观察者模式"></a>异步非阻塞方式的观察者模式</h3><p>如何实现异步非阻塞，最简单就是另开个线程嘛，即<strong>新开个线程或者线程池异步跑观察者通知</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Collection&lt;RegisterObserver&gt; regObservers;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(&quot;register&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">          userService.addUser(userParam);</span><br><span class="line">          <span class="comment">//异步通知每个观察者</span></span><br><span class="line">          <span class="keyword">for</span> (RegisterObserver temp : regObservers) &#123;</span><br><span class="line">               executor.execute(() -&gt; &#123;</span><br><span class="line">                    temp.sendMsg(<span class="string">&quot;注冊成功&quot;</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">          regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池实现的异步非阻塞方式，还是可以的，但是异步执行逻辑都耦合在了<code>register()函数</code>中，不是很优雅，也增加了这部分业务代码的维护成本。一般日常工作中，我们会用<code>spring</code>那一套观察者模式等。</p>
<h3 id="spring观察者模式应用"><a href="#spring观察者模式应用" class="headerlink" title="spring观察者模式应用"></a>spring观察者模式应用</h3><p>spring的观察者模式使用也是比较简单的，就是先定义个事件，继承于<code>ApplicationEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个事件监听器<code>MessageListener</code>，类似于<strong>观察者</strong>，它实现<code>ApplicationListener</code>接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MessageEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MessageEvent messageEvent)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;用户注册成功，执行监听事件&quot;</span>+messageEvent.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户注册成功后，<code>applicationEventPublisher</code>（<strong>类似于被观察者</strong>）发布事件即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;springListenRegister&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">springListenRegister</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始注册&quot;</span>);</span><br><span class="line">        userService.addUser(userParam);</span><br><span class="line">        <span class="comment">//用户注册成功，发布事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">MessageEvent</span>(<span class="string">&quot;666&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始注册</span><br><span class="line">用户注册成功，执行监听事件666</span><br></pre></td></tr></table></figure>

<p>这个也是<strong>同步阻塞</strong>的方式实现的。</p>
<h4 id="Spring观察者模式原理"><a href="#Spring观察者模式原理" class="headerlink" title="Spring观察者模式原理"></a><strong>Spring观察者模式原理</strong></h4><p>Spring 中实现的观察者模式包含三部分：分别是<code>Event</code>事件（相当于消息）、<code>Listener</code>监听者（相当于观察者）、<code>Publisher</code>发送者（相当于被观察者）。用个图表示就是这样：</p>
<p><img src="/2023/10/29/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2.png" alt="图片"></p>
<p><code>ApplicationEventPublisher</code>源代码（<strong>被观察者&#x2F;发布者</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  publishEvent((Object) event);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationEventPublisher</code>它只是一个函数式接口，我们再看下它接口方法的实现。它的具体实现类是<code>AbstractApplicationContext</code>，这个类代码有点多，我把关键部分代码贴出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> extends ... &#123;</span><br><span class="line">  <span class="comment">//监听者（观察者列表）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造器，初始化观察者列表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发布事件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发布事件接口实现</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Object applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      <span class="comment">//如果event是ApplicationEvent对象,或者是它的子类</span></span><br><span class="line">      applicationEvent = (ApplicationEvent)event;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是ApplicationEvent对象或者它的子类，则将其包装成PayloadApplicationEvent事件，并获取对应的事件类型</span></span><br><span class="line">      applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>(<span class="built_in">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//真正的消息发送，是通过它。获取ApplicationEventMulticaster，调用multicastEvent方法广播事件</span></span><br><span class="line">      <span class="built_in">this</span>.getApplicationEventMulticaster().multicastEvent(</span><br><span class="line">            (ApplicationEvent)applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前命名空间还有父亲节点，也需要给父亲推送该消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">        ((AbstractApplicationContext)<span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加观察者（监听者）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    Assert.notNull(listener, <span class="string">&quot;ApplicationListener must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.applicationEventMulticaster != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationEventMulticaster.addApplicationListener(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.add(listener);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//观察者列表</span></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.applicationListeners;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册监听器</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//把提前存储好的监听器添加到监听器容器中到ApplicationEventMulticaster</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">   getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">     <span class="comment">//获取类型是ApplicationListener的beanName集合，此处不会去实例化bean</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">   getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//如果存在earlyEventsToProcess，提前处理这些事件</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码，我们可以发现，真正的消息发送，实际上是通过事件广播器<code>ApplicationEventMulticaster </code>这个接口来完成的。<code>multicastEvent</code>是主要方法，这个方法的实现在类<code>SimpleApplicationEventMulticaster</code>中，我们一起来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleApplicationEventMulticaster</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationEventMulticaster</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//线程池</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">protected</span> Executor <span class="title function_">getTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.taskExecutor;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(<span class="meta">@Nullable</span> Executor taskExecutor)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.taskExecutor = taskExecutor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 根据event类型获取适合的监听器</span></span><br><span class="line">  <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">   <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果executor不为空，异步调用执行监听器中的方法</span></span><br><span class="line">    executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用监听器的方法</span></span><br><span class="line">    invokeListener(listener, event);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">  <span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">    <span class="comment">//如果存在ErrorHandler，调用监听器方法(会用try...catch包一下)</span></span><br><span class="line">  <span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    doInvokeListener(listener, event);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">//如果抛出异常则调用ErrorHandler来处理异常。</span></span><br><span class="line">    errorHandler.handleError(err);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      否则直接调用监听器方法</span><br><span class="line">   doInvokeListener(listener, event);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，<strong>默认情况下，spring实现的观察者模式，同步阻塞的</strong>。如果想异步执行事件，可以自定义<code>SimpleApplicationEventMulticaster</code>，然后构造一下<code>executor</code>线程池就好啦。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把线程池赋值进去</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">simpleApplicationEventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">        simpleApplicationEventMulticaster.setTaskExecutor(simpleAsyncTaskExecutor());</span><br><span class="line">        <span class="keyword">return</span> simpleApplicationEventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleAsyncTaskExecutor <span class="title function_">simpleAsyncTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册开始</span><br><span class="line">当前线程名称http-nio-8080-exec-1</span><br><span class="line">注册结束</span><br><span class="line">用户注册成功2，执行监听事件666Sat Jun 18 11:44:07 GMT+08:00 2022</span><br><span class="line">当前线程名称:SimpleAsyncTaskExecutor-20</span><br><span class="line">当前线程名称:SimpleAsyncTaskExecutor-19</span><br><span class="line">用户注册成功，执行监听事件666Sat Jun 18 11:44:12 GMT+08:00 2022</span><br></pre></td></tr></table></figure>

<p>如果手动新建<code>SimpleApplicationEventMulticaster</code>，并设置<code>taskExecutor</code>的话，所有的监听响应事件，都是<strong>异步执行</strong>的哦。而有些有些场景我们希望同步执行的，这时候这种实现方式就不好了。</p>
<p>其实<code>spring</code>提供了<code>@Async</code>注解，可以用来实现<strong>异步</strong>。具体怎么实现呢？其实很简单，只需要在<strong>配置类</strong>加上<code>@EnableAsync</code>，接着在需要异步执行的监听实现方法。加上<code>@Async</code>即可。代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//配置类加上```@EnableAsync```</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerConfig2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">simpleApplicationEventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">        <span class="keyword">return</span> simpleApplicationEventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageAsyncListener3</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MessageEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//方法异步注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MessageEvent messageEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户注册成功3，执行监听事件&quot;</span> + messageEvent.getSource() + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程名称:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，异步执行也可以自己手动通过线程池来开启啦。回到我们本文的<strong>后端思维</strong>主题，如果每个开发，都自己定义观察者模式的实现，这种代码会很混乱，<strong>所以最好是实现一个可扩展，通用的观察者模板</strong>。</p>
<h3 id="基于spring观察者模式，抽取一个模板"><a href="#基于spring观察者模式，抽取一个模板" class="headerlink" title="基于spring观察者模式，抽取一个模板"></a><strong>基于spring观察者模式，抽取一个模板</strong></h3><p>基于spring实现观察者模式的话，就包括这三步：</p>
<ol>
<li>定义<code>Event</code>事件（相当于消息），一般定义一个<code>Event</code>对象，继承<code>ApplicationEvent</code></li>
<li>定义<code>Listener</code>监听者（相当于观察者），实现接口<code>ApplicationListener</code></li>
<li><code>Publisher</code>发送者（相当于被观察者），通过<code>ApplicationEventPublisher</code>发布。</li>
</ol>
<h4 id="定义Event事件对象"><a href="#定义Event事件对象" class="headerlink" title="定义Event事件对象"></a>定义<code>Event</code>事件对象</h4><p>定义一个<strong>项目相关的，通用</strong>的<code>BaseEvent</code>类，然后一些相关通用的信息属性可以放进去，比如<code>eventId</code>或者流水号<code>bizSeq</code>什么的，根据实际项目需要。以下代码，我定义一个空空如也的<code>BaseEvent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的观察者模式，是注册成功之后，发个消息的，你就可以声明一个消息类事件对象<code>RegisterMessageEvent</code>，继承通用的<code>BaseEvent</code>即可。然后属性可以自定义就好，比如<code>messageId</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterMessageEvent</span>  <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msgId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterMessageEvent</span><span class="params">(String msgId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.msgId = msgId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsgId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msgId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsgId</span><span class="params">(String msgId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msgId = msgId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果你想定义一个用户送礼物成功，然后发个广播，可以定义一个<code>GiftSendEvent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiftSendEvent</span> <span class="keyword">extends</span> <span class="title class_">BaseEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String giftId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GiftSendEvent</span><span class="params">(String giftId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.giftId = giftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGiftId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> giftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGiftId</span><span class="params">(String giftId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.giftId = giftId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他业务场景类似，只要想接入你的观察者模板，只需要自己定义事件对象，继承于你的<code>BaseEvent</code>即可。</p>
<h4 id="定义Listener监听者（观察者）"><a href="#定义Listener监听者（观察者）" class="headerlink" title="定义Listener监听者（观察者）"></a>定义<code>Listener</code>监听者（观察者）</h4><p>定义完<code>Event</code>事件，我们就可以开始定义监听者了。我们定义的监听者，只需要实现接口<code>ApplicationListener</code>接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span> <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听者的实现，关键在于实现<code>ApplicationListener</code>的<code>onApplicationEvent</code>的接口方法即可。又因为未来别的业务场景接入观察者模式，都是按你的模板来，所以各个<code>Event</code>事件对象，都是继承于你的<code>BaseEvent</code>的，所以我们可以把**&lt; T extends BaseEvent &gt;**的泛型加进去，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些时候，可能会有这种场景，就是执行<strong>监听逻辑</strong>，<strong>只对部分数据（或者说部分特殊用户才执行）</strong>。既然我们是抽取监听模板，考虑到可扩展性，我们可以优化下<code>IEventListener</code>的代码。我们可以声明一个support的方法，默认是执行的,子类可以覆盖重写（让子类去控制是否执行这个监听逻辑），如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口里面，加了default，就可以写方法实现</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后呢，只有<code>support</code>方法返回<code>true</code>，才执行<strong>监听的逻辑</strong>，我们还可以定义一个<code>handler</code>方法，给子类去实现自己的业务逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (support(event)) &#123;</span><br><span class="line">            handler(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正实现业务逻辑的接口，给子类去实现。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给<code>onApplicationEvent</code>的实现<code>try...catch...</code>一下，如果<code>catch</code>住异常的话，可以定义一个<code>handlerException</code>异常处理方法，给子类自定义去实现，当然，异常可以默认不处理嘛，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 观察者的业务逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (support(event)) &#123;</span><br><span class="line">                handler(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            handleException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认执行观察者的逻辑的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  观察者的逻辑，交给不同子类自定义实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常默认不处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Throwable exception)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>最后呢，不同业务不同的监听者（观察者），直接实现你的<code>IEventListener</code>就好啦，比如注册成功那个，我们声明一个<code>RegisterMessageListenerImpl</code>类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterMessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">IEventListener</span>&lt;RegisterMessageEvent&gt; &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(RegisterMessageEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户注册成功register，执行监听事件&quot;</span> + event.getSource() + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义Publisher发送者模板"><a href="#定义Publisher发送者模板" class="headerlink" title="定义Publisher发送者模板"></a>定义<code>Publisher</code>发送者模板</h4><p>最后一步就是<strong>定义发送者模板</strong>。最简单的发送，就是利用<code>ApplicationContext</code>直接发送就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublish</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applicationContext继承了ApplicationEventPublisher接口，所以可以用applicationContext发布事件。</p>
<p>这个只是同步阻塞方式的观察者模式，一般来说，一个<strong>通用的观察者模板</strong>。也需要提供异步非阻塞方式的观察者模板。为了方便管理，和API语义更明确，我们可以手动设置线程池，给我们的模板发布类，提供异步发送的接口。我们先自定义一个线程池，一般<strong>不建议</strong>直接使用JDK的线程池。</p>
<p><strong>自定义线程池</strong></p>
<p>我们在<code>application.properties</code>配置文件，定义线程池一些属性（核心线程数、最大线程数等等）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">executor.corePoolSize</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">executor.maxPoolSize</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">executor.queueCapacity</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">executor.keepAliveSeconds</span>=<span class="string">120</span></span><br><span class="line"><span class="attr">executor.threadNamePrefix</span>=<span class="string">threadPoolExecutor</span></span><br></pre></td></tr></table></figure>

<p>声明一个线程配置类<code>TianLuoExecutorsConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;executor&quot;)</span><span class="comment">//读取配置文件的线程池属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TianLuoExecutorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get和set的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过线程配置类<code>TianLuoExecutorsConfig</code>，初始化线程池<code>TianLuoExecutorPool</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TianLuoExecutorPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TianLuoExecutorsConfig tianLuoExecutorsConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">eventExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(tianLuoExecutorsConfig.getCorePoolSize());</span><br><span class="line">        executor.setMaxPoolSize(tianLuoExecutorsConfig.getMaxPoolSize());</span><br><span class="line">        executor.setKeepAliveSeconds(tianLuoExecutorsConfig.getKeepAliveSeconds());</span><br><span class="line">        executor.setQueueCapacity(tianLuoExecutorsConfig.getQueueCapacity());</span><br><span class="line">        executor.setThreadNamePrefix(tianLuoExecutorsConfig.getThreadNamePrefix());</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后回到<code>EventPublish</code>，把异步发布的接口加上，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TianLuoExecutorPool tianLuoExecutorPool;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//同步阻塞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步发布（异步非阻塞）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncPublish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        tianLuoExecutorPool.eventExecutor().execute(()-&gt;&#123;</span><br><span class="line">            publish(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 观察者模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/29/CountDownLatch%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/" rel="prev" title="CountDownLatch的原理是什么?">
                  <i class="fa fa-angle-left"></i> CountDownLatch的原理是什么?
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/" rel="next" title="了解ThreadLocal">
                  了解ThreadLocal <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="DXProgramer/hexo-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Xiangger</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">326k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:56</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- 樱花特效 -->
  
      <script async src="/js/fairyDustCursor.js"></script>
  
</body>
</html>
