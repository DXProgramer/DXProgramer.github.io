<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>物流系统</title>
      <link href="/2024/12/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%89%A9%E6%B5%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%89%A9%E6%B5%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>美团外卖的即时物流分布式高并发系统是如何建设的？</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/gXSMv8OtZ-4g6gxsO5G30Q">美团即时物流的分布式系统架构设计</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物流系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis的执行流程</title>
      <link href="/2024/12/05/mybatis/MyBatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/12/05/mybatis/MyBatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/9ye_7EXqQpZRC9M2CleEyg">https://mp.weixin.qq.com/s/9ye_7EXqQpZRC9M2CleEyg</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>责任链模式是一种行为型设计模式，旨在构建一个处理请求的对象链。每个对象都有机会处理请求，但如果它无法处理，请求将继续传递到链上的下一个对象，直到找到一个能够处理请求的对象。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/M3SV7mXliwKW3EkH67V_zQ">https://mp.weixin.qq.com/s/M3SV7mXliwKW3EkH67V_zQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 责任模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2024/12/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/"/>
      <url>/2024/12/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/</url>
      
        <content type="html"><![CDATA[<p>redis基础原理与应用</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/2_wgTf_ikDqnZrACj_nD8w">基于Redis实现点赞及排行榜功能</a></p><p><a href="https://mp.weixin.qq.com/s/PULSBdokYYa7b26ffO1H9Q">数据埋点之redis版本</a></p><p><a href="https://mp.weixin.qq.com/s/UMzNWhWfvesWcBfPqwLeDg">SpringBoot+Redis 搞定搜索栏热搜、不雅文字过滤功能</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收性能优化</title>
      <link href="/2024/12/05/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2024/12/05/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/tfBoI6unwu2RJIjB2IKwzQ">https://mp.weixin.qq.com/s/tfBoI6unwu2RJIjB2IKwzQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java进程占用cpu过高排查</title>
      <link href="/2024/12/05/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/java/java%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2024/12/05/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/java/java%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>本文记录了一次Java进程CPU占用率过高的问题和排查思路。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/HusklYs69fP8VXDUxht3zQ">https://mp.weixin.qq.com/s/HusklYs69fP8VXDUxht3zQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>组合模式（Composite Pattern），又称部分-整体模式，是一种将对象组合成树形结构以表示“部分-整体”层次结构的模式。组合模式使得用户对单个对象和组合对象的使用具有一致性。例如：处理文件和文件夹时，对于文件和文件夹调用同样的方法，执行不同的处理逻辑。常常用来处理树形结构。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/L-AVI3jKdimvA7qGVKoVGw">https://mp.weixin.qq.com/s/L-AVI3jKdimvA7qGVKoVGw</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>工厂设计模式是一种创建对象的设计模式，它的主要目的是通过定义一个接口来创建对象，使得子类决定实例化哪个类。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/JPu0_bGsUERfVYMb8qX3dQ">https://mp.weixin.qq.com/s/JPu0_bGsUERfVYMb8qX3dQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanPostProcessor</title>
      <link href="/2024/12/05/Spring/%E6%89%A9%E5%B1%95%E7%82%B9%E5%BA%94%E7%94%A8/BeanPostProcessor/"/>
      <url>/2024/12/05/Spring/%E6%89%A9%E5%B1%95%E7%82%B9%E5%BA%94%E7%94%A8/BeanPostProcessor/</url>
      
        <content type="html"><![CDATA[<p>在 Spring 中，BeanPostProcessor 是一个强大的扩展点，允许开发者在 Spring 容器实例化和初始化 Bean 时插入自定义逻辑。通过实现 BeanPostProcessor 接口，可以在 Bean 的生命周期中进行额外的处理，例如动态代理、属性设置或校验等操作。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/DlSFOPUT89PxydSrUwjGOQ">基于 BeanPostProcessor 扩展点应用</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ</title>
      <link href="/2024/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/"/>
      <url>/2024/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/</url>
      
        <content type="html"><![CDATA[<p>MQ常见面试题</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/i_csMg5BCNqXGw08Isw2gQ">RocketMQ发送的三种策略</a></p><p><a href="https://mp.weixin.qq.com/s/6YU8AcoGf7Kz2sQPOkLDxgs">RocketMQ延时消息</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/2024/12/01/WEB%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/12/01/WEB%E7%BC%96%E7%A8%8B/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>JAVA WEB常见面试题</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/7I57JHSyM7VRDqlKTUxlxA">京东一面：post为什么会发送两次请求？</a></p><p><a href="https://mp.weixin.qq.com/s/xfrKJrqJT7PysqQfwRpq0g">Spring Boot Starter 设计：实现统一返回与异常处理</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feed 流系统</title>
      <link href="/2024/11/24/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Feed%20%E6%B5%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/24/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Feed%20%E6%B5%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Feed 流是一个持续更新并展示给用户的信息流。它将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获取最新的订阅源内容。所以它通常具有千人千面的个性化特点。举例来说，我们在各类手机 App 中能看到的猜你喜欢，你的关注和好友动态等功能，都是 Feed 流的一种表现形式。某种意义上来说，你可以一直向下滑动，而后获取到信息的应用，都是属于 Feed 流。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/CyXO13C3zQLoa-p7N2qPMg">Feed 流系统的架构设计方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feed流系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大日志</title>
      <link href="/2024/11/24/MySQL/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
      <url>/2024/11/24/MySQL/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>介绍mysql日志管理机制</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwNjc0MzU1Mg==&mid=2247485223&idx=1&sn=e9e183167e047190e50f2a462b4a075e&chksm=c0e29d48f795145e6fe4a6d56d5dd17d667b98d16f063a93e11742254fda57648a1ed652a961&cur_album_id=3718198882254422020&scene=189#wechat_redirect">Mysql篇-三大日志</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buffer Pool中的三大链表</title>
      <link href="/2024/11/24/MySQL/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/Buffer%20Pool%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/11/24/MySQL/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/Buffer%20Pool%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>介绍mysql缓存实现原理</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/Iaz_6hb3tp-lWDOVsDDGsw">Mysql篇-Buffer Pool中的三大链表</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优惠券系统</title>
      <link href="/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>优惠券是电商常见的营销手段，是营销平台中的一个重要组成部分，既可以作为促销活动的载体，也是重要的引流入口。在刚刚过去的电商大促周期内，各大电商平台都有配置不同类目、价位的优惠券，吸引用户下单购买。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/qs3Okf7Jxh9nYFHfG7MGsQ">万级TPS优惠券系统设计与实践</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优惠券系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作引擎</title>
      <link href="/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E4%BD%9C%E5%BC%95%E6%93%8E/"/>
      <url>/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E4%BD%9C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>流程从业务中剥离出来，就形成了工作流技术。工作流技术将业务过程中的任务、事件、条件等抽象为一个独立的模型，使得业务逻辑可以按照工作流模型的定义进行自动化地执行和管理。这种解耦方式提高了业务过程的可视化、可配置化和可监控性，同时也降低了业务逻辑的复杂性。而工作流技术中最核心的正是流程引擎。</p><span id="more"></span><p><a href="https://workflow-engine-book.shuwoom.com/">流程引擎原理与实践</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作引擎系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数系统</title>
      <link href="/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E6%95%B0%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E6%95%B0%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>在信息爆炸的时代，计数系统几乎无处不在，从社交平台上的点赞量、评论数，到电商平台的浏览量、订单数量，再到内容网站的访问量统计，计数系统为各种业务提供了实时、准确的数据支持。这些数据不仅是简单的数字，它们可以反映出用户对内容的兴趣、商品的受欢迎程度、市场的需求变化，甚至可以用于预测未来趋势。对于企业和平台而言，计数系统能够提供一个有效的量化依据，帮助优化产品、制定营销策略、提升用户体验，因此它成为了数据统计和用户分析的核心工具。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/ZHOk7zIAZxv4fNi7INGIDA">原文：空间换时间-将查询数据性能提升100倍的计数系统实践</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2024/11/14/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/11/14/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>在 Java中，反射机制（Reflection）非常重要。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/8iL47GrIq8I9HOqVl2oh_A">原文：一步步带你深入了解神秘的Java反射机制</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自旋锁</title>
      <link href="/2024/11/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2024/11/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>​</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><span id="more"></span><p>简单代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!cas.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas释放放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">         cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock()方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>上面代码它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>解决方案：引入计数器，用来记录获取锁被获取的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            count++;  <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas释放放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">         <span class="keyword">if</span> (current == cas.get()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 count --; <span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="有点"><a href="#有点" class="headerlink" title="有点"></a>有点</h4><ol><li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li><li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li><li>上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最强分布式锁工具：Redisson</title>
      <link href="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/"/>
      <url>/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/</url>
      
        <content type="html"><![CDATA[<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p><span id="more"></span><h3 id="什么是Redisson？"><a href="#什么是Redisson？" class="headerlink" title="什么是Redisson？"></a>什么是Redisson？</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p><p>其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。</p><p>Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p>一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。</p><p>Redisson和Jedis、Lettuce有什么区别？</p><ul><li>Jedis是Redis官方推出的用于通过Java连接Redis客户端的一个工具包，提供了Redis的各种命令支持</li><li>Lettuce是一种可扩展的线程安全的 Redis 客户端，通讯框架基于Netty，支持高级的 Redis 特性，比如哨兵，集群，管道，自动重新连接和Redis数据模型。Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</li><li>Redisson是架设在Redis基础上，通讯基于Netty的综合的、新型的中间件，企业级开发中使用Redis的最佳范本。</li></ul><p>Jedis把Redis命令封装好，Lettuce则进一步有了更丰富的Api，也支持集群等模式。但是两者也都点到为止，只给了你操作Redis数据库的脚手架，而Redisson则是基于Redis、Lua和Netty建立起了成熟的分布式解决方案，甚至redis官方都推荐的一种工具集。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>以Spring Data Redis为例，用RedisTemplate来操作Redis（setIfAbsent已经是setNx + expire的合并命令），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key, String value, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁，防止删错别人的锁，以uuid为value校验是否自己的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockName, String uuid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(lockName)) &#123;        </span><br><span class="line">           redisTemplate.opsForValue().del(lockName);    </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构</span></span><br><span class="line"><span class="keyword">if</span>(tryLock)&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是锁没错，但get和del操作非原子性，并发一旦大了，无法保证进程安全（获取已被其他线程删除的锁）。</p><h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><p>解决方案使用Lua脚本，Lua脚本是redis已经内置的一种轻量小巧语言，其执行是通过redis的<strong>eval</strong>&#x2F;<strong>evalsha</strong>命令来运行，把操作封装成一个Lua脚本，封装为一次执行的原子操作。</p><p>通过Lua脚本删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    then </span><br><span class="line"> -- 执行删除操作</span><br><span class="line">        <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"> -- 不成功，返回<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>delete操作时执行Lua命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁脚本</span></span><br><span class="line">DefaultRedisScript&lt;Object&gt; unlockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">unlockScript</span><br><span class="line">    .setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lockDel.lua&quot;</span>)));</span><br><span class="line"><span class="comment">// 执行lua脚本解锁</span></span><br><span class="line">redisTemplate.execute(unlockScript, Collections.singletonList(keyName), value);</span><br></pre></td></tr></table></figure><p>优化后似乎更像一把锁，但好像又缺少了什么，synchronized和ReentrantLock都很丝滑，因为他们都是可重入锁，一个线程多次拿锁也不会死锁，我们需要可重入。</p><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>重入就是，同一个线程多次获取同一把锁是允许的，不会造成死锁，这一点synchronized偏向锁提供了很好的思路，synchronized的实现重入是在JVM层面，JAVA对象头MARK WORD中便藏有线程ID和计数器来对当前线程做重入判断，避免每次CAS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向</span><br><span class="line">锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁标志是否设置成<span class="number">1</span>：没有则CAS竞争；设置了，则CAS将对象头偏向锁指向当前线程。再维护一个计数器，同个线程进入则自增<span class="number">1</span>，离开</span><br><span class="line">再减<span class="number">1</span>，直到为<span class="number">0</span>才能释放。</span><br></pre></td></tr></table></figure><p>仿造该方案，改造Lua脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要存储锁名称lockName、获得该锁的线程id和对应线程的进入次数count</span><br><span class="line"><span class="number">2.</span>加锁</span><br><span class="line">    每次线程获取锁时，判断是否已存在该锁</span><br><span class="line">    <span class="number">1</span>）不存在</span><br><span class="line">    设置hash的key为线程id，value初始化为<span class="number">1</span></span><br><span class="line">    设置过期时间</span><br><span class="line">    返回获取锁成功<span class="literal">true</span></span><br><span class="line">    <span class="number">2</span>）存在</span><br><span class="line">    继续判断是否存在当前线程id的hash key</span><br><span class="line">    存在，线程key的value + <span class="number">1</span>，重入次数增加<span class="number">1</span>，设置过期时间</span><br><span class="line">    不存在，返回加锁失败<span class="literal">false</span></span><br><span class="line"><span class="number">3.</span>解锁</span><br><span class="line">    每次线程来解锁时，判断是否已存在该锁</span><br><span class="line">    <span class="number">1</span>）存在</span><br><span class="line">    是否有该线程的id的hash key，有则减<span class="number">1</span>，无则返回解锁失败</span><br><span class="line">    减<span class="number">1</span>后，判断剩余count是否为<span class="number">0</span>，为<span class="number">0</span>则说明不再需要这把锁，执行del命令删除</span><br></pre></td></tr></table></figure><p>为了方便维护这个对象，我们用Hash结构来存储这些字段。Redis的Hash类似Java的HashMap，适合存储对象。</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/1.jpg"></p><p>设置一个名字为<strong>lockname1</strong>的hash结构，该hash结构key为<strong>threadId</strong>，值value为<strong>1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset lockname1 threadId <span class="number">1</span></span><br></pre></td></tr></table></figure><p>获取lockname1的threadId的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget lockname1 threadId</span><br></pre></td></tr></table></figure><p>存储结构为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lockname 锁名称</span><br><span class="line">    key1：    threadId   唯一键，线程id</span><br><span class="line">    value1：  count      计数器，记录该线程获取锁的次数</span><br></pre></td></tr></table></figure><p>redis中的结构</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/2.jpg"></p><p><strong>计数器的加减</strong></p><p>当同一个线程获取同一把锁时，我们需要对对应线程的计数器count做加减，判断一个redis key是否存在，可以用<code>exists</code>，而判断一个hash的key是否存在，可以用<code>hexists</code></p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/3.jpg"></p><p>而redis也有hash自增的命令<code>hincrby</code>，每次自增1时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby lockname1 threadId <span class="number">1</span></span><br></pre></td></tr></table></figure><p>自减1时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby lockname1 threadId -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/4.jpg"></p><p><strong>解锁的判断</strong></p><p>当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除。综合上述的存储结构和判断流程，加锁和解锁Lua如下。</p><p>加锁 lock.lua：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">threadId</span> <span class="operator">=</span> ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">releaseTime</span> <span class="operator">=</span> ARGV[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">-- lockname不存在</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) then</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 当前线程已id存在</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) then</span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>解锁 unlock.lua：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="type">local</span> <span class="variable">threadId</span> <span class="operator">=</span> ARGV[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">-- lockname、threadId不存在</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">0</span>) then</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 计数器-<span class="number">1</span></span><br><span class="line"><span class="type">local</span> <span class="variable">count</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">-- 删除lock</span><br><span class="line"><span class="title function_">if</span> <span class="params">(count == <span class="number">0</span>)</span> then</span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 原生redis实现分布式锁</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Long&gt; lockScript;</span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Object&gt; unlockScript;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="comment">// 加载加锁的脚本</span></span><br><span class="line">        lockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.lockScript</span><br><span class="line">            .setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        <span class="built_in">this</span>.lockScript.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        unlockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.unlockScript</span><br><span class="line">            <span class="title function_">setScriptSource</span><span class="params">(new ResourceScriptSource(new ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>)</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tryLock</span><span class="params">(String lockName, <span class="type">long</span> releaseTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 存入的线程信息的前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) redisTemplate.execute(</span><br><span class="line">                lockScript,</span><br><span class="line">                Collections.singletonList(lockName),</span><br><span class="line">                key + Thread.currentThread().getId(),</span><br><span class="line">                releaseTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockName, String key)</span> &#123;</span><br><span class="line">        redisTemplate.execute(unlockScript,</span><br><span class="line">                Collections.singletonList(lockName),</span><br><span class="line">                key + Thread.currentThread().getId()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此已经完成了一把分布式锁，符合互斥、可重入、防死锁的基本特点。</p><p>虽然当个普通互斥锁，已经稳稳够用，可是业务里总是又很多特殊情况的，<strong>比如A进程在获取到锁的时候，因业务操作时间太长，锁释放了但是业务还在执行，而此刻B进程又可以正常拿到锁做业务操作，两个进程操作就会存在依旧有共享资源的问题</strong>。而且如果负责储存这个分布式锁的<strong>Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态</strong>。</p><p>在这种情况时，希望可以延长锁的releaseTime延迟释放锁来直到完成业务期望结果，这种不断延长锁过期时间来保证业务执行完成的操作就是锁续约。</p><p>读写分离也是常见，一个读多写少的业务为了性能，常常是有读锁和写锁的。</p><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><p>依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原生，本章使用--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 另一种Spring集成starter，本章未使用 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">getRedisson</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().</span><br><span class="line">                setAddress(<span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:&quot;</span> + port).</span><br><span class="line">                setPassword(password);</span><br><span class="line">        config.setCodec(<span class="keyword">new</span> <span class="title class_">JsonJacksonCodec</span>());</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(lockName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> rLock.tryLock(expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁明了，只需要一个RLock。</p><h4 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h4><p>RLock是Redisson分布式锁的最核心接口，继承了concurrent包的Lock接口和自己的RLockAsync接口，RLockAsync的返回值都是RFuture，是Redisson执行异步实现的核心逻辑，也是Netty发挥的主要阵地。</p><h5 id="RLock如何加锁？"><a href="#RLock如何加锁？" class="headerlink" title="RLock如何加锁？"></a>RLock如何加锁？</h5><p>从RLock进入，找到RedissonLock类，找到<strong>tryLock</strong>方法再递进到干事的<strong>tryAcquireOnceAsync</strong>方法，这是加锁的主要代码（版本不一此处实现有差别，和最新3.15.x有一定出入，但是核心逻辑依然未变。此处以3.13.6为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RFuture&lt;Boolean&gt; <span class="title function_">tryAcquireOnceAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, </span><br><span class="line">                                          RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; ttlRemainingFuture = </span><br><span class="line">            <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg()</span><br><span class="line">                                       .getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, </span><br><span class="line">                                       RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处出现leaseTime时间判断的2个分支，实际上就是加锁时是否设置过期时间，未设置过期时间（-1）时则会有<strong>watchDog</strong>的<strong>锁续约</strong>（下文），一个注册了加锁事件的续约任务。我们先来看有过期时间<strong>tryLockInnerAsync</strong>部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, </span></span><br><span class="line"><span class="params">                                 RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, </span><br><span class="line">                                                   command, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]</span><br><span class="line">                                                   &#123;<span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里揭开真面目，eval命令执行Lua脚本的地方，此处的Lua脚本展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 不存在该key时</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) then </span><br><span class="line">  -- 新增该锁并且hash中该线程id对应的count置<span class="number">1</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  -- 设置过期时间</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> nil; </span><br><span class="line">end; </span><br><span class="line"></span><br><span class="line">-- 存在该key 并且 hash中线程id的key也存在</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) then </span><br><span class="line">  -- 线程重入次数++</span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> nil; </span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>和前面我们写自定义的分布式锁的脚本几乎一致，看来redisson也是一样的实现，具体参数分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keyName</span></span><br><span class="line">KEYS[<span class="number">1</span>] = Collections.singletonList(<span class="built_in">this</span>.getName())</span><br><span class="line"><span class="comment">// leaseTime</span></span><br><span class="line">ARGV[<span class="number">1</span>] = <span class="built_in">this</span>.internalLockLeaseTime</span><br><span class="line"><span class="comment">// uuid+threadId组合的唯一值</span></span><br><span class="line">ARGV[<span class="number">2</span>] = <span class="built_in">this</span>.getLockName(threadId)</span><br></pre></td></tr></table></figure><p>总共3个参数完成了一段逻辑：</p><p>判断该锁是否已经有对应hash表存在，</p><p>• 没有对应的hash表：则set该hash表中一个entry的key为锁名称，value为1，之后设置该hash表失效时间为leaseTime</p><p>• 存在对应的hash表：则将该lockName的value执行+1操作，也就是计算进入次数，再设置失效时间leaseTime</p><p>• 最后返回这把锁的ttl剩余时间</p><p>那解锁的步骤也肯定有对应的-1操作，再看unlock方法，同样查找方法名，一路到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;</span>, Arrays.asList(<span class="built_in">this</span>.getName(), <span class="built_in">this</span>.getChannelName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;LockPubSub.unlockMessage, <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>掏出Lua部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 不存在key</span><br><span class="line"><span class="title function_">if</span> <span class="params">(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>])</span> == <span class="number">0</span>) then </span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line">-- 计数器 -<span class="number">1</span></span><br><span class="line"><span class="type">local</span> <span class="variable">counter</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], -<span class="number">1</span>); </span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) then </span><br><span class="line">  -- 过期时间重设</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  -- 删除并发布解锁消息</span><br><span class="line">  redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">  redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> nil;</span><br></pre></td></tr></table></figure><p>该Lua KEYS有2个<code>Arrays.asList(getName(), getChannelName())</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name 锁名称</span><br><span class="line">channelName，用于pubSub发布消息的channel名称</span><br></pre></td></tr></table></figure><p>ARGV变量有三个<code>LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LockPubSub.UNLOCK_MESSAGE，channel发送消息的类别，此处解锁为<span class="number">0</span></span><br><span class="line">internalLockLeaseTime，watchDog配置的超时时间，默认为30s</span><br><span class="line">lockName 这里的lockName指的是uuid和threadId组合的唯一值</span><br></pre></td></tr></table></figure><p>步骤如下：</p><p>1.如果该锁不存在则返回nil；</p><p>2.如果该锁存在则将其线程的hash key计数器-1，</p><p>3.计数器counter&gt;0，重置下失效时间，返回0；否则，删除该锁，发布解锁消息unlockMessage，返回1；</p><p>其中unLock的时候使用到了Redis发布订阅PubSub完成消息通知。</p><p>而订阅的步骤就在RedissonLock的加锁入口的lock方法里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(-<span class="number">1L</span>, leaseTime, unit, threadId);</span><br><span class="line">        <span class="keyword">if</span> (ttl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 订阅</span></span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; future = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                <span class="built_in">this</span>.commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.commandExecutor.syncSubscription(future);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure><p>当锁被其他线程占用时，通过监听锁的释放通知（在其他线程通过RedissonLock释放锁时，会通过发布订阅pub&#x2F;sub功能发起通知），等待锁被其他线程释放，也是为了避免自旋的一种常用效率手段。</p><p><strong>解锁消息</strong></p><p>为了一探究竟通知了什么，通知后又做了什么，进入LockPubSub。</p><p>这里只有一个明显的监听方法onMessage，其订阅和信号量的释放都在父类PublishSubscribe，我们只关注监听事件的实际操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> &#123;</span><br><span class="line">        Runnable runnableToExecute;</span><br><span class="line">        <span class="keyword">if</span> (message.equals(unlockMessage)) &#123;</span><br><span class="line">            <span class="comment">// 从监听器队列取监听线程执行监听回调</span></span><br><span class="line">            runnableToExecute = (Runnable)value.getListeners().poll();</span><br><span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="literal">null</span>) &#123;</span><br><span class="line">                runnableToExecute.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// getLatch()返回的是Semaphore，信号量，此处是释放信号量</span></span><br><span class="line">            <span class="comment">// 释放信号量后会唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span><br><span class="line">            value.getLatch().release();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(readUnlockMessage)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                runnableToExecute = (Runnable)value.getListeners().poll();</span><br><span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="literal">null</span>) &#123;</span><br><span class="line">                    value.getLatch().release(value.getLatch().getQueueLength());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                runnableToExecute.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现一个是<strong>默认解锁消息</strong>，一个是<strong>读锁解锁消息</strong>，因为redisson是有提供读写锁的，而读写锁读读情况和读写、写写情况互斥情况不同，我们只看上面的默认解锁消息unlockMessage分支，LockPubSub监听最终执行了2件事</p><p><code>1、runnableToExecute.run()</code> 执行监听回调</p><p><code>2、value.getLatch().release();</code> 释放信号量</p><p>Redisson通过<strong>LockPubSub</strong>监听解锁消息，执行监听回调和释放信号量通知等待线程可以重新抢锁。</p><p>这时再回来看tryAcquireOnceAsync另一分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RFuture&lt;Boolean&gt; <span class="title function_">tryAcquireOnceAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，无超时时间时，在执行加锁操作后，还执行了一段费解的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)                   &#125;                 &#125;             &#125;)</span><br></pre></td></tr></table></figure><p>此处涉及到Netty的Future&#x2F;Promise-Listener模型，Redisson中几乎全部以这种方式通信（所以说Redisson是基于Netty通信机制实现的），理解这段逻辑可以试着先理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 call()或 run()执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。</span><br></pre></td></tr></table></figure><p>这块代码的表面意义就是，在执行异步加锁的操作后，加锁成功则根据加锁完成返回的ttl是否过期来确认是否执行一段定时任务。这段定时任务的就是watchDog的核心。</p><p>锁续约</p><p>查看<code>RedissonLock.this.scheduleExpirationRenewal(threadId)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>.ExpirationEntry();</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">        <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEntry.addThreadId(threadId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.addThreadId(threadId);</span><br><span class="line">            <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">        RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                            RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                        RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            ee.setTimeout(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拆分来看，这段连续嵌套且冗长的代码实际上做了几步</p><p>• 添加一个netty的Timeout回调任务，每（<code>internalLockLeaseTime / 3</code>）毫秒执行一次，执行的方法是<code>renewExpirationAsync</code></p><p>• <code>renewExpirationAsync</code>重置了锁超时时间，又注册一个监听器，监听回调又执行了<code>renewExpiration</code></p><p><code>renewExpirationAsync</code> 的Lua如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.commandExecutor.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) then </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">end; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新设置了超时时间。</p><p>Redisson加这段逻辑的目的是什么？</p><p>目的是为了某种场景下保证业务不影响，如任务执行超时但未结束，锁已经释放的问题。</p><p><strong>当一个线程持有了一把锁，由于并未设置超时时间leaseTime，Redisson默认配置了30S，开启watchDog，每10S对该锁进行一次续约，维持30S的超时时间，直到任务完成再删除锁。</strong></p><p>这就是Redisson的<strong>锁续约</strong>，也就是<strong>WatchDog</strong>实现的基本思路。</p><p><strong>流程概括</strong></p><p>通过整体的介绍，流程简单概括：</p><p>1、A、B线程争抢一把锁，A获取到后，B阻塞</p><p>2、B线程阻塞时并非主动CAS，而是PubSub方式订阅该锁的广播消息</p><p>3、A操作完成释放了锁，B线程收到订阅消息通知</p><p>4、B被唤醒开始继续抢锁，拿到锁</p><p>详细加锁解锁流程总结如下图：</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/5.jpg"></p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>以上介绍的可重入锁是非公平锁，Redisson还基于Redis的队列（List）和ZSet实现了公平锁</p><p><strong>公平的定义是什么？</strong></p><p>公平就是按照客户端的请求先来后到排队来获取锁，先到先得，也就是FIFO，所以队列和容器顺序编排必不可少</p><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a><strong>FairSync</strong></h3><p>回顾JUC的ReentrantLock公平锁的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS已经提供了整个实现，是否公平取决于实现类取出节点逻辑是否顺序取</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/6.jpg"></p><p>AbstractQueuedSynchronizer是用来构建锁或者其他同步组件的基础框架，通过内置FIFO队列来完成资源获取线程的排队工作，他自身没有实现同步接口，仅仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用（上图），支持独占和共享获取，这是基于模版方法模式的一种设计，给公平&#x2F;非公平提供了土壤。</p><p>我们用2张图来简单解释AQS的等待流程（出自《JAVA并发编程的艺术》）</p><p>一张是同步队列（FIFO双向队列）<strong>管理 获取同步状态失败（抢锁失败）的线程引用、等待状态和前驱后继节点的流程图</strong></p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/7.jpg"></p><p>一张是<strong>独占式获取同步状态的总流程</strong>，核心acquire(int arg)方法调用流程</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/8.jpg"></p><p>可以看出锁的获取流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AQS维护一个同步队列，获取状态失败的线程都会加入到队列中进行自旋，移出队列或停止自旋的条件是前驱节点为头节点切成功获取了同步状态。</span><br></pre></td></tr></table></figure><p>而比较另一段非公平锁类<code>NonfairSync</code>可以发现，控制公平和非公平的关键代码，在于<code>hasQueuedPredecessors</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NonfairSync</code>减少了了<code>hasQueuedPredecessors</code>判断条件，该方法的作用就是</p><p><strong>查看同步队列中当前节点是否有前驱节点，如果有比当前线程更早请求获取锁则返回true。</strong></p><p><strong>保证每次都取队列的第一个节点（线程）来获取锁，这就是公平规则</strong></p><h4 id="为什么JUC以默认非公平锁呢？"><a href="#为什么JUC以默认非公平锁呢？" class="headerlink" title="为什么JUC以默认非公平锁呢？"></a>为什么JUC以默认非公平锁呢？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为当一个线程请求锁时，只要获取来同步状态即成功获取。在此前提下，刚释放的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。但这样带来的好处是，非公平锁大大减少了系统线程上下文的切换开销。</span><br></pre></td></tr></table></figure><p>可见公平的代价是性能与吞吐量。</p><p>Redis里没有AQS，但是有List和zSet，看看Redisson是怎么实现公平的。</p><h4 id="RedissonFairLock"><a href="#RedissonFairLock" class="headerlink" title="RedissonFairLock"></a>RedissonFairLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redissonClient.getFairLock(lockName);</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure><p><code>RedissonFairLock</code>继承自<code>RedissonLock</code>，同样一路向下找到加锁实现方法<strong>tryLockInnerAsync</strong>。</p><p>这里有2段冗长的Lua，但是Debug发现，公平锁的入口在 <code>command == RedisCommands.EVAL_LONG</code> 之后，此段Lua较长，参数也多，我们着重分析Lua的实现规则</p><p><strong>参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- lua中的几个参数</span><br><span class="line">KEYS = Arrays.&lt;Object&gt;asList(getName(), threadsQueueName, timeoutSetName)</span><br><span class="line">KEYS[<span class="number">1</span>]: lock_name, 锁名称                   </span><br><span class="line">KEYS[<span class="number">2</span>]: <span class="string">&quot;redisson_lock_queue:&#123;xxx&#125;&quot;</span>  线程队列</span><br><span class="line">KEYS[<span class="number">3</span>]: <span class="string">&quot;redisson_lock_timeout:&#123;xxx&#125;&quot;</span>  线程id对应的超时集合</span><br><span class="line"></span><br><span class="line">ARGV =  internalLockLeaseTime, getLockName(threadId), currentTime + threadWaitTime, currentTime</span><br><span class="line">ARGV[<span class="number">1</span>]: <span class="string">&quot;&#123;leaseTime&#125;&quot;</span> 过期时间</span><br><span class="line">ARGV[<span class="number">2</span>]: <span class="string">&quot;&#123;Redisson.UUID&#125;:&#123;threadId&#125;&quot;</span>   </span><br><span class="line">ARGV[<span class="number">3</span>] = 当前时间 + 线程等待时间:（<span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span>） + <span class="number">5000</span>毫秒 = <span class="number">10</span>:<span class="number">00</span>:<span class="number">05</span></span><br><span class="line">ARGV[<span class="number">4</span>] = 当前时间（<span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span>）  部署服务器时间，非redis-server服务器时间</span><br></pre></td></tr></table></figure><p>公平锁实现的Lua脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="number">1.</span>死循环清除过期key</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  -- 获取头节点</span><br><span class="line">    <span class="type">local</span> <span class="variable">firstThreadId2</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>);</span><br><span class="line">    -- 首次获取必空跳出循环</span><br><span class="line">  <span class="keyword">if</span> firstThreadId2 == <span class="literal">false</span> then </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  end;</span><br><span class="line">  -- 清除过期key</span><br><span class="line">  <span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2));</span><br><span class="line">  <span class="keyword">if</span> timeout &lt;= tonumber(ARGV[<span class="number">4</span>]) then</span><br><span class="line">    redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2);</span><br><span class="line">    redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  end;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">2.</span>不存在该锁 &amp;&amp; （不存在线程等待队列 || 存在线程等待队列而且第一个节点就是此线程ID)，加锁部分主要逻辑</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) and </span><br><span class="line">  ((redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">2</span>]) == <span class="number">0</span>)  or (redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>) == ARGV[<span class="number">2</span>])) then</span><br><span class="line">  -- 弹出队列中线程id元素，删除Zset中该线程id对应的元素</span><br><span class="line">  redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]);</span><br><span class="line">  redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">local</span> <span class="variable">keys</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;zrange&#x27;</span>, KEYS[<span class="number">3</span>], <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">  -- 遍历zSet所有key，将key的超时时间(score) - 当前时间ms</span><br><span class="line">  <span class="type">for</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, #keys, <span class="number">1</span> <span class="keyword">do</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;zincrby&#x27;</span>, KEYS[<span class="number">3</span>], -tonumber(ARGV[<span class="number">3</span>]), keys[i]);</span><br><span class="line">  end;</span><br><span class="line">    -- 加锁设置锁过期时间</span><br><span class="line">  redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">3.</span>线程存在，重入判断</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>],<span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">4.</span>返回当前线程剩余存活时间</span><br><span class="line"><span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> timeout ~= <span class="literal">false</span> then</span><br><span class="line">  -- 过期时间timeout的值在下方设置，此处的减法算出的依旧是当前线程的ttl</span><br><span class="line">  <span class="keyword">return</span> timeout - tonumber(ARGV[<span class="number">3</span>]) - tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">5.</span>尾节点剩余存活时间</span><br><span class="line"><span class="type">local</span> <span class="variable">lastThreadId</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], -<span class="number">1</span>);</span><br><span class="line">local ttl;</span><br><span class="line">-- 尾节点不空 &amp;&amp; 尾节点非当前线程</span><br><span class="line"><span class="keyword">if</span> lastThreadId ~= <span class="literal">false</span> and lastThreadId ~= ARGV[<span class="number">2</span>] then</span><br><span class="line">  -- 计算队尾节点剩余存活时间</span><br><span class="line">  ttl = tonumber(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], lastThreadId)) - tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  -- 获取lock_name剩余存活时间</span><br><span class="line">  ttl = redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- <span class="number">6.</span>末尾排队</span><br><span class="line">-- zSet 超时时间（score），尾节点ttl + 当前时间 + 5000ms + 当前时间，无则新增，有则更新</span><br><span class="line">-- 线程id放入队列尾部排队，无则插入，有则不再插入</span><br><span class="line"><span class="type">local</span> <span class="variable">timeout</span> <span class="operator">=</span> ttl + tonumber(ARGV[<span class="number">3</span>]) + tonumber(ARGV[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">3</span>], timeout, ARGV[<span class="number">2</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;rpush&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">end;</span><br><span class="line"><span class="keyword">return</span> ttl;</span><br></pre></td></tr></table></figure><p>公平锁加锁步骤</p><p>通过以上Lua，可以发现，lua操作的关键结构是列表（list）和有序集合（zSet）。</p><p>其中list维护了一个等待的线程队列<code>redisson_lock_queue:&#123;xxx&#125;</code>，zSet维护了一个线程超时情况的有序集合<code>redisson_lock_timeout:&#123;xxx&#125;</code>，尽管lua较长，但是可以拆分为6个步骤</p><p><strong>1.队列清理</strong></p><ul><li>保证队列中只有未过期的等待线程</li></ul><p><strong>2.首次加锁</strong></p><ul><li>hset加锁，pexpire过期时间</li></ul><p><strong>3.重入判断</strong></p><ul><li>此处同可重入锁lua</li></ul><p><strong>4.返回ttl</strong></p><p><strong>5.计算尾节点ttl</strong></p><ul><li>初始值为锁的剩余过期时间</li></ul><p><strong>6.末尾排队</strong></p><ul><li><code>ttl + 2 * currentTime + waitTime</code>是score的默认值计算公式</li></ul><h4 id="2-模拟"><a href="#2-模拟" class="headerlink" title="2.模拟"></a>2.模拟</h4><p>如果模拟以下顺序，就会明了redisson公平锁整个加锁流程</p><p>假设 <code>t1 10:00:00 &lt; t2 10:00:10 &lt; t3 10:00:20</code></p><p>t1：当线程1初次获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列无头节点，跳出死循环-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁 &amp;&amp; 不存在线程等待队列 成立</span><br><span class="line">    <span class="number">2.1</span> lpop和zerm、zincrby都是无效操作，只有加锁生效，说明是首次加锁，加锁后返回nil加锁成功，线程<span class="number">1</span></span><br><span class="line">    获取到锁，结束</span><br></pre></td></tr></table></figure><p>t2：线程2尝试获取锁（线程1未释放锁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.等待队列无头节点，跳出死循环-&gt;2</span><br><span class="line">2.不存在该锁 不成立-&gt;3</span><br><span class="line">3.非重入线程 -&gt;4</span><br><span class="line">4.score无值 -&gt;5</span><br><span class="line">5.尾节点为空，设置ttl初始值为lock_name的ttl -&gt; 6</span><br><span class="line">6.按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列，线程</span><br><span class="line">2为头节点score = 20S + 5000ms + 10:00:10 + 10:00:10 = 10:00:35 + 10:00:10</span><br></pre></td></tr></table></figure><p>t3：线程3尝试获取锁（线程1未释放锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列有头节点</span><br><span class="line">    <span class="number">1.1</span>未过期-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁不成立-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3.</span>非重入线程-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4.</span>score无值 -&gt;<span class="number">5</span></span><br><span class="line"><span class="number">5.</span>尾节点不为空 &amp;&amp; 尾节点线程为<span class="number">2</span>，非当前线程</span><br><span class="line">    <span class="number">5.1</span>取出之前设置的score，减去当前时间：ttl = score - currentTime -&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6.</span>按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列</span><br><span class="line">    score = 10S + 5000ms + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure><p>如此一来，三个需要抢夺一把锁的线程，完成了一次排队，在list中排列他们等待线程id，在zSet中存放过期时间（便于排列优先级）。其中返回ttl的线程2客户端、线程3客户端将会一直按一定间隔自旋重复执行该段Lua，尝试加锁，如此一来便和AQS有了异曲同工之处。</p><p>而当线程1释放锁之后（这里依旧有通过Pub&#x2F;Sub发布解锁消息，通知其他线程获取）</p><p>10:00:30 线程2尝试获取锁（线程1已释放锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>等待队列有头节点，未过期-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2.</span>不存在该锁 &amp; 等待队列头节点是当前线程 成立</span><br><span class="line">    <span class="number">2.1</span>删除当前线程的队列信息和zSet信息，超时时间为：</span><br><span class="line">    线程<span class="number">2</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">10</span> - <span class="number">10</span>:<span class="number">00</span>:<span class="number">30</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">15</span></span><br><span class="line">        线程<span class="number">3</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">35</span> + <span class="number">10</span>:<span class="number">00</span>:<span class="number">20</span> - <span class="number">10</span>:<span class="number">00</span>:<span class="number">30</span> = <span class="number">10</span>:<span class="number">00</span>:<span class="number">25</span></span><br><span class="line">    <span class="number">2.2</span>线程<span class="number">2</span>获取到锁，重新设置过期时间加锁成功，线程<span class="number">2</span>获取到锁，结束</span><br></pre></td></tr></table></figure><p>排队结构如图</p><p><img src="/2024/11/02/redis/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B7%A5%E5%85%B7%EF%BC%9ARedisson/9.jpg"></p><p>公平锁的释放脚本和重入锁类似，多了一步加锁开头的清理过期key的while true逻辑，在此不再展开篇幅描述。</p><p>由上可以看出，Redisson公平锁的玩法类似于延迟队列的玩法，核心都在Redis的List和zSet结构的搭配，但又借鉴了AQS实现，在定时判断头节点上如出一辙（watchDog），保证了锁的竞争公平和互斥。并发场景下，lua脚本里，zSet的score很好地解决了顺序插入的问题，排列好优先级。</p><p>并且为了防止因异常而退出的线程无法清理，每次请求都会判断头节点的过期情况给予清理，最后释放时通过CHANNEL通知订阅线程可以来获取锁，重复一开始的步骤，顺利交接到下一个顺序线程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redisson整体实现分布式加解锁流程的实现稍显复杂，作者Rui Gu对Netty和JUC、Redis研究深入，利用了很多高级特性和语义，值得深入学习，本次介绍也只是单机Redis下锁实现。</p><p>Redisson也提供了多机情况下的联锁MultiLock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/redisson/redisson/wiki/8.-分布式锁和同步器#81-可重入锁reentrant-lock</span></span><br></pre></td></tr></table></figure><p>和官方推荐的红锁RedLock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/redisson/redisson/wiki/8.-分布式锁和同步器#84-红锁redlock</span></span><br></pre></td></tr></table></figure><p>所以，当你真的需要分布式锁时，不妨先来Redisson里找找。</p><p>原文：<a href="https://mp.weixin.qq.com/s/KeXXL6bag1uRcLJj4s3trg">https://mp.weixin.qq.com/s/KeXXL6bag1uRcLJj4s3trg</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现库存扣减操作和防止被超卖？</title>
      <link href="/2024/11/02/redis/Redis%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E6%93%8D%E4%BD%9C%E5%92%8C%E9%98%B2%E6%AD%A2%E8%A2%AB%E8%B6%85%E5%8D%96%EF%BC%9F/"/>
      <url>/2024/11/02/redis/Redis%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E6%93%8D%E4%BD%9C%E5%92%8C%E9%98%B2%E6%AD%A2%E8%A2%AB%E8%B6%85%E5%8D%96%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中有很多地方都有类似扣减库存的操作，比如电商系统中的商品库存，抽奖系统中的奖品库存等。</p><span id="more"></span><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、使用mysql数据库，使用一个字段来存储库存，每次扣减库存去更新这个字段。</p><p>2、还是使用数据库，但是将库存分成多份存到多条记录里面，扣减库存的时候路由一下，这样子增大了并发量，但是还是避免不了大量的去访问数据库来更新库存。</p><p>3、将库存放到redis使用redis的incrby特性来扣减库存。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="基于数据库单库存"><a href="#基于数据库单库存" class="headerlink" title="基于数据库单库存"></a>基于数据库单库存</h4><p>​        第一种方式在所有请求都会在这里等待锁，获取锁就去扣减库存。在并发量不高的情况下可以使用，但是一旦并发量大了就会有大量请求阻塞在这里，导致请求超时，进而整个系统雪崩；而且会频繁的去访问数据库，大量占用数据库资源，所以在并发高的情况下这种方式不适用。</p><h4 id="基于数据库多库存"><a href="#基于数据库多库存" class="headerlink" title="基于数据库多库存"></a>基于数据库多库存</h4><p>​        第二种方式其实是第一种方式的优化版本，在一定程度上提高了并发量，但是在还是会大量的对数据库做更新操作大量占用数据库资源。</p><p> 基于数据库来实现扣减库存还存在的一些问题：</p><p>（1）用数据库扣减库存的方式，扣减库存的操作必须在一条语句中执行，不能先selec再update，这样在并发下会出现超扣的情况。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update number set x=x-<span class="number">1</span> where x &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>（2）MySQL自身对于高并发的处理性能就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。</p><p>（3）当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。</p><h4 id="基于redis"><a href="#基于redis" class="headerlink" title="基于redis"></a>基于redis</h4><p>​        针对上述问题的问题我们就有了第三种方案，将库存放到缓存，利用redis的incrby特性来扣减库存，解决了超扣和性能问题。但是一旦缓存丢失需要考虑恢复方案。比如抽奖系统扣奖品库存的时候，初始库存&#x3D;总的库存数-已经发放的奖励数，但是如果是异步发奖，需要等到MQ消息消费完了才能重启redis初始化库存，否则也存在库存不一致的问题。</p><p>基于redis实现扣减库存的具体实现：</p><p>（1）使用redis的lua脚本来实现扣减库存</p><p>（2）由于是分布式环境下所以还需要一个分布式锁来控制只能有一个服务去初始化库存</p><p>（3）需要提供一个回调函数，在初始化库存的时候去调用这个函数获取初始化库存。</p><p>初始化库存回调函数(IStockCallback )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 获取库存回调 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStockCallback</span> &#123;</span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 获取库存  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扣减库存服务（StockService）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 库存管理 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Servicepublic</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;    </span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(StockService.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 不限库存     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">UNINITIALIZED_STOCK</span> <span class="operator">=</span> -<span class="number">3L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * Redis 客户端     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 执行扣库存的脚本     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_LUA;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;        </span><br><span class="line">        <span class="comment">/**         </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@desc</span> 扣减库存Lua脚本         </span></span><br><span class="line"><span class="comment">        * 库存（stock）-1：表示不限库存         </span></span><br><span class="line"><span class="comment">        * 库存（stock）0：表示没有库存         </span></span><br><span class="line"><span class="comment">        * 库存（stock）大于0：表示剩余库存             </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@params</span> 库存key         </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span>         </span></span><br><span class="line"><span class="comment">        *   -3:库存未初始化         </span></span><br><span class="line"><span class="comment">        *   -2:库存不足         </span></span><br><span class="line"><span class="comment">        *   -1:不限库存         </span></span><br><span class="line"><span class="comment">        *   大于等于0:剩余库存（扣减之后剩余的库存）         </span></span><br><span class="line"><span class="comment">        *      redis缓存的库存(value)是-1表示不限库存，直接返回1         </span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        </span><br><span class="line">        sb.append(<span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 1) then&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;    local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]));&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;    local num = tonumber(ARGV[1]);&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;    if (stock == -1) then&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;        return -1;&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;    end;&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;    if (stock &gt;= num) then&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;        return redis.call(&#x27;incrby&#x27;, KEYS[1], 0 - num);&quot;</span>); </span><br><span class="line">        sb.append(<span class="string">&quot;    end;&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;    return -2;&quot;</span>); </span><br><span class="line">        sb.append(<span class="string">&quot;end;&quot;</span>);        </span><br><span class="line">        sb.append(<span class="string">&quot;return -3;&quot;</span>);        </span><br><span class="line">        STOCK_LUA = sb.toString();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key           库存key     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire        库存有效时间,单位秒     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num           扣减数量     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stockCallback 初始化库存回调函数     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> -2:库存不足; -1:不限库存; 大于等于0:扣减库存之后的剩余库存     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">stock</span><span class="params">(String key, <span class="type">long</span> expire, <span class="type">int</span> num, IStockCallback stockCallback)</span> &#123; </span><br><span class="line">        <span class="type">long</span> <span class="variable">stock</span> <span class="operator">=</span> stock(key, num);        <span class="comment">// 初始化库存        </span></span><br><span class="line">        <span class="keyword">if</span> (stock == UNINITIALIZED_STOCK) &#123;            </span><br><span class="line">            <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>(redisTemplate, key);            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                <span class="comment">// 获取锁                </span></span><br><span class="line">                <span class="keyword">if</span> (redisLock.tryLock()) &#123;                    </span><br><span class="line">                    <span class="comment">// 双重验证，避免并发时重复回源到数据库                    </span></span><br><span class="line">                    stock = stock(key, num);                    </span><br><span class="line">                    <span class="keyword">if</span> (stock == UNINITIALIZED_STOCK) &#123;                        </span><br><span class="line">                        <span class="comment">// 获取初始化库存                        </span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">initStock</span> <span class="operator">=</span> stockCallback.getStock(); </span><br><span class="line">                        <span class="comment">// 将库存设置到redis</span></span><br><span class="line">                        redisTemplate.opsForValue().set(key, initStock, expire,</span><br><span class="line">                                                        TimeUnit.SECONDS);                 </span><br><span class="line">                        <span class="comment">// 调一次扣库存的操作                        </span></span><br><span class="line">                        stock = stock(key, num);                    </span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line">                logger.error(e.getMessage(), e);            </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;                </span><br><span class="line">                redisLock.unlock();            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> stock;    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**     * 加库存(还原库存)     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key    库存key     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num    库存数量     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addStock</span><span class="params">(String key, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addStock(key, <span class="literal">null</span>, num);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 加库存     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key    库存key     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expire 过期时间（秒）     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num    库存数量     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addStock</span><span class="params">(String key, Long expire, <span class="type">int</span> num)</span> &#123;        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> redisTemplate.hasKey(key);        </span><br><span class="line">        <span class="comment">// 判断key是否存在，存在就直接更新        </span></span><br><span class="line">        <span class="keyword">if</span> (hasKey) &#123;            </span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, num);        </span><br><span class="line">        &#125;</span><br><span class="line">        Assert.notNull(expire,<span class="string">&quot;初始化库存失败，库存过期时间不能为null&quot;</span>);        </span><br><span class="line">        <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>(redisTemplate, key);        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">if</span> (redisLock.tryLock()) &#123;                </span><br><span class="line">                <span class="comment">// 获取到锁后再次判断一下是否有key                </span></span><br><span class="line">                hasKey = redisTemplate.hasKey(key);                </span><br><span class="line">                <span class="keyword">if</span> (!hasKey) &#123;                    </span><br><span class="line">                    <span class="comment">// 初始化库存                    </span></span><br><span class="line">                    redisTemplate.opsForValue().set(key, num, expire, TimeUnit.SECONDS);</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;            </span><br><span class="line">            logger.error(e.getMessage(), e);        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            redisLock.unlock();        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 获取库存     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 库存key     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> -1:不限库存; 大于等于0:剩余库存     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStock</span><span class="params">(String key)</span> &#123;        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> (Integer) redisTemplate.opsForValue().get(key);        </span><br><span class="line">        <span class="keyword">return</span> stock == <span class="literal">null</span> ? -<span class="number">1</span> : stock;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 扣库存     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 库存key     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> num 扣减库存数量     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 扣减之后剩余的库存【-3:库存未初始化; -2:库存不足; -1:不限库存; 大于等于0:扣减库存之后的剩余库存】     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">private</span> Long <span class="title function_">stock</span><span class="params">(String key, <span class="type">int</span> num)</span> &#123;        </span><br><span class="line">        <span class="comment">// 脚本里的KEYS参数        </span></span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">        keys.add(key);        </span><br><span class="line">        <span class="comment">// 脚本里的ARGV参数        </span></span><br><span class="line">        List&lt;String&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">        args.add(Integer.toString(num));</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">RedisCallback</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span>            </span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">nativeConnection</span> <span class="operator">=</span> connection.getNativeConnection();</span><br><span class="line">                <span class="comment">// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</span></span><br><span class="line">                <span class="comment">// 集群模式                </span></span><br><span class="line">                <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> JedisCluster) &#123;                    </span><br><span class="line">                    <span class="keyword">return</span> (Long) ((JedisCluster) nativeConnection).eval(STOCK_LUA, keys,</span><br><span class="line">                                                                         args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 单机模式                </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (Long) ((Jedis) nativeConnection).eval(STOCK_LUA, keys, args);</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="keyword">return</span> UNINITIALIZED_STOCK;            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);        </span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;stock&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">stock</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 商品ID        </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">commodityId</span> <span class="operator">=</span> <span class="number">1</span>;        <span class="comment">// 库存ID        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;redis_key:stock:&quot;</span> + commodityId;        </span><br><span class="line">        <span class="type">long</span> <span class="variable">stock</span> <span class="operator">=</span> stockService.stock(redisKey, <span class="number">60</span> * <span class="number">60</span>, <span class="number">2</span>, () -&gt; </span><br><span class="line">                                        initStock(commodityId));        </span><br><span class="line">        <span class="keyword">return</span> stock &gt;= <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 获取初始的库存     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">initStock</span><span class="params">(<span class="type">long</span> commodityId)</span> &#123;        </span><br><span class="line">        <span class="comment">// TODO 这里做一些初始化库存的操作        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;getStock&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getStock</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 商品ID        </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">commodityId</span> <span class="operator">=</span> <span class="number">1</span>;        <span class="comment">// 库存ID        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;redis_key:stock:&quot;</span> + commodityId;</span><br><span class="line">        <span class="keyword">return</span> stockService.getStock(redisKey);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;addStock&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">addStock</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 商品ID        </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">commodityId</span> <span class="operator">=</span> <span class="number">2</span>;        </span><br><span class="line">        <span class="comment">// 库存ID        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;redis_key:stock:&quot;</span> + commodityId;</span><br><span class="line">        <span class="keyword">return</span> stockService.addStock(redisKey, <span class="number">2</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电商 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybtis使用的9种设计模式</title>
      <link href="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</p><span id="more"></span><p>Mybatis至少遇到了以下的设计模式的使用：</p><ol><li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li><li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式，例如ErrorContext和LogFactory；</li><li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li><li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li><li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li>迭代器模式，例如迭代器模式PropertyTokenizer；</li></ol><h3 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h3><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png" alt="图片"></p><p>在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取*Mapper文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p>对于builder的具体类，方法都大都用build*开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png" alt="图片"></p><p>即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.jpg" alt="图片"></p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.png" alt="图片"></p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">  <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">   <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">   tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call</span></span><br><span class="line">         <span class="comment">// close()</span></span><br><span class="line">   <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。</p><p>在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。</p><p>而对于LogFactory，它的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LogFactory</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; logConstructor;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">LogFactory</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// disable construction</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title function_">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是Constructor&lt;? **extends** Log&gt;，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.jpg" alt="图片"></p><p>在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>ErrorContext的单例实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorContext</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">ErrorContext</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title function_">instance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ErrorContext</span> <span class="variable">context</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">   context = <span class="keyword">new</span> <span class="title class_">ErrorContext</span>();</span><br><span class="line">   LOCAL.set(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.jpg" alt="图片"></p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.jpg" alt="图片"></p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lasse Voss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getMapperInterface</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mapperInterface;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title function_">getMethodCache</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> methodCache;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;,</span><br><span class="line">    mapperProxy);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxymapperProxy)生成代理对象然后返回。</p><p>而查看MapperProxy的代码，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">   <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。</p><p>通过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，而该方法则会调用后续的sqlSession.cud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.png" alt="图片"></p><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.format.dynamicproxy.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE users</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null and birthday != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlNode</span> &#123;</span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.png" alt="图片"></p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">  <span class="type">GenericTokenParser</span> <span class="variable">parser</span> <span class="operator">=</span> </span><br><span class="line">createParser(<span class="keyword">new</span> <span class="title class_">BindingTokenParser</span>(context, injectionFilter));</span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png" alt="图片"></p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png" alt="图片"></p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; </span><br><span class="line"><span class="title function_">doFlushStatements</span><span class="params">(<span class="type">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; List&lt;E&gt; </span><br><span class="line"><span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds,</span></span><br><span class="line"><span class="params">             ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure><p>该模板方法类有几个子类的具体实现，使用了不同的策略：</p><ul><li>简单SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）</li><li>重用ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。（可以是Statement或PrepareStatement对象）</li><li>批量BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</li></ul><p>比如在SimpleExecutor中这样实现update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">   <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(<span class="built_in">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="literal">null</span>,</span><br><span class="line">     <span class="literal">null</span>);</span><br><span class="line">   stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">   <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.jpg" alt="图片"></p><p>在Mybatsi的logging包中，有一个Log接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">isTraceEnabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String s, Throwable e)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String s)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String s)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String s)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png" alt="图片"></p><p>比如对于Log4jImpl的实现来说，该实现持有了org.apache.log4j.Logger的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jImpl</span> <span class="keyword">implements</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FQCN</span> <span class="operator">=</span> Log4jImpl.class.getName();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Logger log;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Log4jImpl</span><span class="params">(String clazz)</span> &#123;</span><br><span class="line">  log = Logger.getLogger(clazz);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTraceEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String s, Throwable e)</span> &#123;</span><br><span class="line">  log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  log.log(FQCN, Level.ERROR, s, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  log.log(FQCN, Level.DEBUG, s, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  log.log(FQCN, Level.TRACE, s, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  log.log(FQCN, Level.WARN, s, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.jpg" alt="图片"></p><p>在mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。如下图：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.jpg" alt="图片"></p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</p><ol><li>FifoCache：先进先出算法，缓存回收策略</li><li>LoggingCache：输出缓存命中的日志信息</li><li>LruCache：最近最少使用算法，缓存回收策略</li><li>ScheduledCache：调度缓存，负责定时清空缓存</li><li>SerializedCache：缓存序列化和反序列化存储</li><li>SoftCache：基于软引用实现的缓存管理策略</li><li>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</li><li>WeakCache：基于弱引用实现的缓存管理策略</li></ol><p>另外，还有一个特殊的装饰器TransactionalCache：事务性的缓存</p><p>正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><ul><li>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。</li><li>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。</li></ul><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p>Cache对象之间的引用顺序为：</p><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.jpg" alt="图片"></p><p>Java的Iterator就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p><img src="/2024/10/26/mybatis/mybatis%E4%BD%BF%E7%94%A8%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png" alt="图片"></p><p>比如Mybatis的PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;PropertyTokenizer&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> String indexedName;</span><br><span class="line"> <span class="keyword">private</span> String index;</span><br><span class="line"> <span class="keyword">private</span> String children;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PropertyTokenizer</span><span class="params">(String fullname)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">delim</span> <span class="operator">=</span> fullname.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">   name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">   children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   name = fullname;</span><br><span class="line">   children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  indexedName = name;</span><br><span class="line">  delim = name.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">   index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">   name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getIndexedName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> indexedName;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getChildren</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> children != <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> PropertyTokenizer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenizer</span>(children);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">    <span class="string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p><p><a href="https://mp.weixin.qq.com/s/7JFjyHGp3MznUDfTY2DEOQ">https://mp.weixin.qq.com/s/7JFjyHGp3MznUDfTY2DEOQ</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存读写一致思考</title>
      <link href="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%9D%E8%80%83/"/>
      <url>/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>更新缓存的步骤特别简单，共两步：更新数据库和更新缓存。但这简单的两步中需要考虑很多问题。</p><p>1）先更新数据库还是先更新缓存？更新缓存时是先删除还是直接更新？</p><p>2）假设第一步成功了，第二步失败了怎么办？</p><p>3）假设两个线程同时更新同一个数据，A线程先完成第一步，B线程先完成第二步怎么办？</p><span id="more"></span><h3 id="组合1：先更新缓存，再更新数据库"><a href="#组合1：先更新缓存，再更新数据库" class="headerlink" title="组合1：先更新缓存，再更新数据库"></a>组合1：先更新缓存，再更新数据库</h3><p>对于这个组合，会遇到这种情况：假设第二步更新数据库失败了，要求回滚缓存的更新，这时该怎么办呢？Redis不支持事务回滚，除非采用手工回滚的方式，这种解决方案有些缺陷。</p><p>这里简单举个例子。</p><p>1）原来缓存中的值是a，两个线程同时更新库存。</p><p>2）线程A将缓存中的值更新成b，且保存了原来的值a，然后更新数据库。</p><p>3）线程B将缓存中的值更新成c，且保存了原来的值b，然后更新数据库。</p><p>4）线程A更新数据库时失败了，它必须回滚，那现在缓存中的值更新成什么呢？理论上应该更新成c，因为数据库中的值是c，但是，线程A里面无从获得c这个值。</p><p>如果在线程A更新缓存与数据库的整个过程中，先把缓存及数据库都锁上，确保别的线程不能更新，是否可行？当然是可行的。但是其他线程能不能读取？</p><p>假设线程A更新数据库失败回滚缓存时，线程C也加入进来，它需要先读取缓存中的值，这时又返回什么值？</p><p>看到这个场景，是不是有点儿熟悉？不错，这就是典型的事务隔离级别场景。所以就不推荐这个组合，因为此处只是需要使用一下缓存，而这个组合就要考虑事务隔离级别的一些逻辑，成本太大。接着考虑别的组合。</p><h3 id="组合2：先删除缓存，再更新数据库"><a href="#组合2：先删除缓存，再更新数据库" class="headerlink" title="组合2：先删除缓存，再更新数据库"></a>组合2：先删除缓存，再更新数据库</h3><p>使用这种方案，即使更新数据库失败了也不需要回滚缓存。这种做法虽然巧妙规避了失败回滚的问题，却引出了两个更大的问题。</p><p>1）假设线程A先删除缓存，再更新数据库。在线程A完成更新数据库之前，后执行的线程B反而超前完成了操作，读取Key发现没有数据后，将数据库中的旧值存放到了缓存中。线程A在线程B都完成后再更新数据库，这样就会出现缓存（旧值）与数据库的值（新值）不一致的问题。</p><p>2）为了解决一致性问题，可以让线程A给Key加锁，因为写操作特别耗时，这种处理方法会导致大量的读请求卡在锁中。以上描述的是典型的高可用和一致性难以两全的问题，如果再加上分区容错 就 是 CAP （ 一 致 性 Consistency 、 可 用 性 Availability 、 分 区 容 错 性Partition Tolerance）了。</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%9D%E8%80%83/1.png"></p><h3 id="组合3：先更新数据库，再更新缓存"><a href="#组合3：先更新数据库，再更新缓存" class="headerlink" title="组合3：先更新数据库，再更新缓存"></a>组合3：先更新数据库，再更新缓存</h3><p>对于组合3，同样需要考虑两个问题。</p><p>1）假设第一步（更新数据库）成功，第二步（更新缓存）失败了怎么办？</p><p>因为缓存不是主流程，数据库才是，所以不会因为更新缓存失败而回滚第一步对数据库的更新。此时一般采取的做法是重试机制，但重试机制如果存在延时还是会出现数据库与缓存不一致的情况，不好处理。</p><p>2）假设两个线程同时更新同一个数据，线程A先完成了第一步，线程B先完成了第二步怎么办？线程A把值更新成a，线程B把值更新成b，此时数据库中的最新值是b，因为线程A先完成了第一步，后完成第二步，所以缓存中的最新值是a，数据库与缓存的值还是不一致，这个逻辑还是有问题的。</p><p>因此，也不建议采用这个组合。</p><h3 id="组合4：先更新数据库，再删除缓存"><a href="#组合4：先更新数据库，再删除缓存" class="headerlink" title="组合4：先更新数据库，再删除缓存"></a>组合4：先更新数据库，再删除缓存</h3><p>针对组合4，先看看它能不能解决组合3的第二个问题。</p><p>假设两个线程同时更新同一个数据，线程A先完成第一步，线程B先完成第二步怎么办？</p><p>线程A把值更新成a，线程B把值更新成b，此时数据库中的最新值是b，因为线程A先完成了第一步，所以第二步谁先完成已经不重要了，因为都是直接删除缓存数据。这个问题解决了。</p><p>那么，它能解决组合3的第一个问题吗？假设第一步成功，第二步失败了怎么办？</p><p>这种情况的出现概率与组合3相比明显低不少，因为删除比更新容易多了。虽然这个组合方案不完美，但出现一致性问题的概率较低。</p><p>除了组合3会碰到的问题，组合4还会碰到别的问题吗？是的。假设线程A要更新数据，先完成第一步更新数据库，在线程A删除缓存之前，线程B要访问缓存，那么取得的就是旧数据。这是一个小小的缺陷。那么，以上问题有办法解决吗？</p><h3 id="组合5：先删除缓存，更新数据库，再删除缓存"><a href="#组合5：先删除缓存，更新数据库，再删除缓存" class="headerlink" title="组合5：先删除缓存，更新数据库，再删除缓存"></a>组合5：先删除缓存，更新数据库，再删除缓存</h3><p>还有一个方案，就是先删除缓存，再更新数据库，再删除缓存。这个方案其实和先更新数据库，再删除缓存差不多，因为还是会出现类似的问题：假设线程A要更新数据库，先删除了缓存，这一瞬间线程C要读缓存，先把数据迁移到缓存；然后线程A完成了更新数据库的操作，这一瞬间线程B也要访问缓存，此时它访问到的就是线程C放到缓存里面的旧数据。相比组合4，概率进一步减小（涉及三个线程）。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内存淘汰机制详解</title>
      <link href="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>​        一般来说，缓存的容量是小于数据总量的，所以，当缓存数据越来越多，Redis 不可避免的会被写满，这时候就涉及到 Redis 的内存淘汰机制了。我们需要选定某种策略将“不重要”的数据从 Redis 中清除，为新的数据腾出空间。</p><span id="more"></span><h3 id="配置Redis内存大小"><a href="#配置Redis内存大小" class="headerlink" title="配置Redis内存大小"></a>配置Redis内存大小</h3><p>​       根据“八二原理“，即 80% 的请求访问了 20% 的数据，因此如果按照这个原理来配置，将 Redis 内存大小设置为数据总量的 20%，就有可能拦截到 80% 的请求。当然，只是有可能，对于不同的业务场景需要进行不同的配置，一般建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p><p>配置方式（以 5GB 为例，如果不带单位则默认单位是字节）：</p><p>命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory 5gb</span><br></pre></td></tr></table></figure><p>配置文件：</p><p><img src="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1.png"></p><p>查看 maxmemory 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get maxmemory</span><br></pre></td></tr></table></figure><h3 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h3><p>在 Redis 4.0 版本之前有 6 种策略，4.0 增加了 2种，主要新增了 LFU 算法。</p><p>下图为 Redis 6.2.0 版本的配置文件：</p><p><img src="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/2.png"></p><p>其中，默认的淘汰策略是 noevition，也就是不淘汰。</p><p>我们可以对 8 种淘汰策略可以分为两大类：</p><h4 id="不进行淘汰的策略"><a href="#不进行淘汰的策略" class="headerlink" title="不进行淘汰的策略"></a><strong>不进行淘汰的策略</strong></h4><p>noevition，此策略不会对缓存的数据进行淘汰，当内存不够了就会报错，因此，如果真实数据集大小大于缓存容量，就不要使用此策略了。</p><p><img src="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/3.png"></p><h4 id="会进行淘汰的策略"><a href="#会进行淘汰的策略" class="headerlink" title="会进行淘汰的策略"></a><strong>会进行淘汰的策略</strong></h4><ul><li>allkeys-random：随机删除</li><li>allkeys-lru：使用 LRU 算法进行筛选删除</li><li>allkeys-lfu：使用 LFU 算法进行筛选删除</li><li>volatile-random：随机删除</li><li>volatile-ttl：根据过期时间先后进行删除，越早过期的越先被删除</li><li>volatile-lru：使用 LRU 算法进行筛选删除</li><li>volatile-lfu：使用 LFU 算法进行筛选删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 以 volatile 开头的策略只针对设置了过期时间的数据，即使缓存没有被写满，如果数据过期也会被删除。</span><br><span class="line"></span><br><span class="line">2)以 allkeys 开头的策略是针对所有数据的，如果数据被选中了，即使过期时间没到，也会被删除。当然，如果它的过期时间到了但未被策略选中，同样会被删除。</span><br></pre></td></tr></table></figure><h5 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h5><p>​         LRU 全称是 Least Recently Used，即最近最少使用，会将最不常用的数据筛选出来，保留最近频繁使用的数据。LRU 会把所有数据组成一个链表，链表头部称为 MRU，代表最近最常使用的数据；尾部称为 LRU代表最近最不常使用的数据；下图是一个简单的例子：</p><p><img src="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/5.png"></p><p><strong>但是，如果直接在 Redis 中使用 LRU 算法也会有一些问题：</strong></p><p>LRU 算法在实现过程中使用链表管理所有缓存的数据，这会给 Redis 带来额外的开销，而且，当有数据访问时就会有链表移动操作，进而降低 Redis 的性能。</p><p>于是，Redis 对 LRU 的实现进行了一些改变：</p><ul><li>记录每个 key 最近一次被访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）</li><li>在第一次淘汰数据时，会先随机选择 N 个数据作为一个候选集合，然后淘汰 lru 值最小的。（N 可以通过 config set maxmemory-samples 100 命令来配置）</li><li>后续再淘汰数据时，会挑选数据进入候选集合，进入集合的条件是：它的 lru 小于候选集合中最小的 lru。</li><li>如果候选集合中数据个数达到了 maxmemory-samples，Redis 就会将 lru 值小的数据淘汰出去。</li></ul><h5 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h5><p>LFU 全称 Least Frequently Used，即最不经常使用策略，它是基于数据访问次数来淘汰数据的，在 Redis 4.0 时添加进来。它在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。</p><p>前面说到，LRU 使用了 RedisObject 中的 lru 字段记录时间戳，lru 是 24bit 的，LFU 将 lru 拆分为两部分：</p><ul><li>ldt 值：lru 字段的前 16bit，表示数据的访问时间戳</li><li>counter 值：lru 字段的后 8bit，表示数据的访问次数 使用 LFU 策略淘汰缓存时，会把访问次数最低的数据淘汰，如果访问次数相同，再根据访问的时间，将访问时间戳最小的淘汰。</li></ul><p><strong>为什么 Redis 有了 LRU 还需要 LFU 呢？</strong></p><p>在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。</p><p>由于 LRU 是基于访问时间的，如果系统对大量数据进行单次查询，这些数据的 lru 值就很大，使用 LFU 算法就不容易被淘汰。</p><h4 id="配置淘汰策略"><a href="#配置淘汰策略" class="headerlink" title="配置淘汰策略"></a>配置淘汰策略</h4><p>命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>配置文件：</p><p><img src="/2024/10/26/redis/Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/4.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录（CAS）</title>
      <link href="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/"/>
      <url>/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>​        单点登录（ Single Sign-On , 简称 SSO ）是目前比较流行的服务于企业业务整合的解决方案之一， SSO 使得在多个应用系统中，用户只需要 登录一次 就可以访问所有相互信任的应用系统。</p><span id="more"></span><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS?"></a>什么是CAS?</h3><p>​        随着SSO技术的流行，相关产品也比较多，其中CAS就是一套解决方案，CAS（Central Authentication Service）中文翻译为统一身份认证服务或中央身份服务，它由服务端和客户端组成，实现SSO,并且容易进行企业应用的集成。CAS具有以下的特点：</p><ul><li>开源的企业级单点登录解决方案</li><li>CAS Server为需要独立部署的web应用</li><li>CAS Client支持非常多的客户端（这里指单点登录系统中的各个web应用），包括 Java、.Net 、ISAPI、Php、Perl、uPortal、Acegi、Ruby、VBScript等客户端</li></ul><p>有了CAS,我们的系统架构就演变成下面这样的：</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/1.png" alt="图片"></p><p>从架构上可以看出，CAS包含两个部分：CAS Server和CAS Client.</p><ul><li>CAS Server需要独立部署，主要负责对用户的认证工作，CAS Client负责处理</li><li>对客户端受保护资源的访问请求，需要登录，重定向到CAS Server。</li></ul><h3 id="CAS-Server服务器端"><a href="#CAS-Server服务器端" class="headerlink" title="CAS Server服务器端"></a><strong>CAS Server服务器端</strong></h3><h4 id="CAS服务器端软件包下载"><a href="#CAS服务器端软件包下载" class="headerlink" title="CAS服务器端软件包下载"></a>CAS服务器端软件包下载</h4><ul><li>下载版本为5.3</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载服务器的overlay地址: https://github.com/apereo/cas-overlay-template/tree/5.3</span><br></pre></td></tr></table></figure><p>压缩包：<code>cas-overlay-template-5.3.zip</code></p><p>解压好后用命令：<code>build.cmd package</code></p><p>然后用编译的目录查看war包:</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/2.png" alt="图片"></p><h4 id="服务器端的基本部署和测试"><a href="#服务器端的基本部署和测试" class="headerlink" title="服务器端的基本部署和测试"></a>服务器端的基本部署和测试</h4><p>将war包放到tomcat的webapp中，然后启动tomcat</p><p>访问地址：<code>http://localhost:8080/cas</code> 或者 <code>http://localhost:8080/cas/login</code></p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/3.png" alt="图片"></p><p>默认用户名和密码在<code>\webapps\cas\WEB-INF\classes\application.properties</code>里面，用户名：casuser 密码：Mellon</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/4.png" alt="图片"></p><h3 id="CAS-Server服务器配置"><a href="#CAS-Server服务器配置" class="headerlink" title="CAS Server服务器配置"></a>CAS Server服务器配置</h3><h4 id="去除https认证"><a href="#去除https认证" class="headerlink" title="去除https认证"></a>去除https认证</h4><p>CAS默认使用的是HTTPS协议，如果使用HTTPS协议需要SSL安全证书（需向特定的机构申请和购买）。如果对安全要求不高或是在开发测试阶段，可使用HTTP协议。我们这里讲解通过修改配置，让CAS使用HTTP协议。</p><p>修改CAS服务端配置文件：<code>\cas\WEB-INF\classes\application.properties</code>里添加如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas.tgc.secure=false</span><br><span class="line">cas.serviceRegistry.initFromJson=true</span><br></pre></td></tr></table></figure><p><code>\cas\WEB-INF\classes\services</code>目录下的HTTPSandIMAPS-10000001.json修改内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;serviceId&quot; : &quot;^(https|http|imaps)://.*&quot;</span><br></pre></td></tr></table></figure><h3 id="CAS-Client客户端配置（自己项目）"><a href="#CAS-Client客户端配置（自己项目）" class="headerlink" title="CAS Client客户端配置（自己项目）"></a><strong>CAS Client客户端配置（自己项目）</strong></h3><p>Pom文件的依赖即pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.unicon.cas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-autoconfig-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置文件</p><p>客户端1</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9010</span></span><br><span class="line"><span class="attr">cas:</span></span><br><span class="line">  <span class="attr">server-url-prefix:</span> <span class="string">http://localhost:8080/cas</span></span><br><span class="line">  <span class="attr">server-login-url:</span> <span class="string">http://localhost:8080/cas/login</span></span><br><span class="line">  <span class="attr">client-host-url:</span> <span class="string">http://localhost:9010</span></span><br><span class="line">  <span class="attr">validation-type:</span> <span class="string">cas3</span></span><br></pre></td></tr></table></figure><p>注：启动类追加开启CAS的注解@EnableCasClient</p><p>测试类1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iimport io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(description = &quot;SSO-CAS的测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test1....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端2</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9011</span></span><br><span class="line"><span class="attr">cas:</span></span><br><span class="line">  <span class="attr">server-url-prefix:</span> <span class="string">http://localhost:8080/cas</span></span><br><span class="line">  <span class="attr">server-login-url:</span> <span class="string">http://localhost:8080/cas/login</span></span><br><span class="line">  <span class="attr">client-host-url:</span> <span class="string">http://localhost:9011</span></span><br><span class="line">  <span class="attr">validation-type:</span> <span class="string">cas3</span></span><br></pre></td></tr></table></figure><p>注：启动类追加开启CAS的注解@EnableCasClient</p><p>测试类2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(description = &quot;SSO-CAS的测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test2....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端1，客户端2和cas服务器搭建好之后，接下来我们进行测试：</p><p>1.首先启动tomcat服务器中的CAS Server。</p><p>2.分别启动客户端1和客户端2，然后在浏览器地址栏输入客户端1的地址<code>http://localhost:9010/test1</code></p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/5.png" alt="图片"></p><p>在不登录的状态，在浏览器的地址栏继续输入客户端2的地址：<code>http://localhost:9011/test2</code></p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/6.png" alt="图片"></p><p>当我们在其中一个登录界面登录账号后（假设登录客户端2）就会跳转到登陆后的界面，如下图：</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/7.png" alt="图片"></p><p>我们再次在浏览器窗口重新输入客户端1，<code>http://localhost:9010/test1</code>，或者在刚刚输入客户端页面重新刷新,不用登录即可进入页面，如下图：</p><p><img src="/2024/10/26/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88CAS%EF%BC%89/8.png" alt="图片"></p><p>以上就是单点登录的测试。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级缓存解决方案设计</title>
      <link href="/2024/05/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/05/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/BkoHiCP-_Co4HevcCH6R5g">有赞：多级缓存解决方案深入剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> 高性能并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高系统的并发能力方案</title>
      <link href="/2024/05/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B%E6%96%B9%E6%A1%88/"/>
      <url>/2024/05/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6F_OGrX-4qThxtZ3rcORkw">提高系统的并发能力方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 高性能并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式应用</title>
      <link href="/2024/04/23/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
      <url>/2024/04/23/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>。</p><p>常用设计模式应用。</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/7E-IHL7DDD6Ru87ltxORFA">如果策略模式的代码有段位，你的是白银？黄金？还是王者？</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统中的补偿机制设计</title>
      <link href="/2024/01/28/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/28/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>应用系统在分布式的情况下，在通信时会有着一个显著的问题，即一个业务流程往往需要组合一组服务，且单单一次通信可能会经过 DNS 服务，网卡、交换机、路由器、负载均衡等设备，而这些服务于设备都不一定是一直稳定的，在数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。因为业务需要在一致性上的保证。也就是说，如果一个步骤失败了，要么不断重试保证所有的步骤都成功，要么回滚到以前的服务调用。</p><span id="more"></span><h3 id="关于业务补偿机制"><a href="#关于业务补偿机制" class="headerlink" title="关于业务补偿机制"></a>关于业务补偿机制</h3><h4 id="什么是业务补偿"><a href="#什么是业务补偿" class="headerlink" title="什么是业务补偿"></a>什么是业务补偿</h4><p>即当某个操作发生了异常时，如何通过内部机制将这个异常产生的「不一致」状态消除掉。</p><h4 id="业务补偿设计的实现方式"><a href="#业务补偿设计的实现方式" class="headerlink" title="业务补偿设计的实现方式"></a>业务补偿设计的实现方式</h4><p>业务补偿设计的实现方式主要可分为两种：</p><ul><li><strong>回滚（事务补偿）</strong>，逆向操作，回滚业务流程，意味着放弃，当前操作必然会失败；</li><li><strong>重试</strong>，正向操作，努力地把一个业务流程执行完成，代表着还有成功的机会。</li></ul><p>一般来说，业务的事务补偿都是需要一个工作流引擎的。这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ps：因为「补偿」已经是一个额外流程了，既然能够走这个额外流程，说明时效性并不是第一考虑的因素。所以做补偿的核心要点是：宁可慢，不可错。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 补偿机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止订单超卖几种方案</title>
      <link href="/2024/01/27/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E9%98%B2%E6%AD%A2%E8%AE%A2%E5%8D%95%E8%B6%85%E5%8D%96%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2024/01/27/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E9%98%B2%E6%AD%A2%E8%AE%A2%E5%8D%95%E8%B6%85%E5%8D%96%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>大厂防止超卖的几种实现。</p><span id="more"></span><h3 id="方案一：Lock锁"><a href="#方案一：Lock锁" class="headerlink" title="方案一：Lock锁"></a>方案一：Lock锁</h3><p>使用事务 + Lock锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 多实例下要用分布式锁</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/start/lock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startLock</span><span class="params">(<span class="type">long</span> skgId)</span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始秒杀方式一...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() * (<span class="number">99999</span> - <span class="number">10000</span> + <span class="number">1</span>)) + <span class="number">10000</span>;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> secondKillService.startSecondKillByLock(skgId, userId);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SkillService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startSecondKillByLock</span><span class="params">(<span class="type">long</span> skgId, <span class="type">long</span> userId)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 校验库存</span></span><br><span class="line">        <span class="type">SecondKill</span> <span class="variable">secondKill</span> <span class="operator">=</span> secondKillMapper.selectById(skgId);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> secondKill.getNumber();</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//扣库存</span></span><br><span class="line">            secondKill.setNumber(number - <span class="number">1</span>);</span><br><span class="line">            secondKillMapper.updateById(secondKill);</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">SuccessKilled</span> <span class="variable">killed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuccessKilled</span>();</span><br><span class="line">            killed.setSeckillId(skgId);</span><br><span class="line">            killed.setUserId(userId);</span><br><span class="line">            killed.setState((<span class="type">short</span>) <span class="number">0</span>);</span><br><span class="line">            killed.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">            successKilledMapper.insert(killed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//支付</span></span><br><span class="line">            <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>();</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setUserId(userId);</span><br><span class="line">            payment.setMoney(<span class="number">40</span>);</span><br><span class="line">            payment.setState((<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">            payment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">            paymentMapper.insert(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(SecondKillStateEnum.END);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================error&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在Transactional方法加上锁，有可能在事务提交之前，就已经把锁释放了，这样会导致商品超卖现象。所以加锁的时机很重要！</p><p><strong>aop实现</strong></p><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span>  <span class="meta">@interface</span> ServiceLock &#123;</span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span>  <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aop切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//order越小越是最先执行，但更重要的是最先执行的最后结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service 默认是单例的，并发下lock只有一个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 互斥锁 参数默认false，不公平锁,分布式环境，用分布式锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Service层切点     用于记录错误日志</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.dx.springboot.aop.ServiceLock)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockAspect</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;lockAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/start/aop&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startAop</span><span class="params">(<span class="type">long</span> skgId)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始秒杀方式二...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() * (<span class="number">99999</span> - <span class="number">10000</span> + <span class="number">1</span>)) + <span class="number">10000</span>;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> secondKillService.startSecondKillByAop(skgId, userId);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：数据库悲观锁"><a href="#方案二：数据库悲观锁" class="headerlink" title="方案二：数据库悲观锁"></a>方案二：数据库悲观锁</h3><p>悲观锁，什么是悲观锁呢？通俗的说，在做任何事情之前，都要进行加锁确认。这种数据库级加锁操作效率较低。使用for update一定要加上事务，当事务处理完后，for update才会将行级锁解除。</p><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/start/pes/lock/one&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startPesLockOne</span><span class="params">(<span class="type">long</span> skgId)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始秒杀方式三...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() * (<span class="number">99999</span> - <span class="number">10000</span> + <span class="number">1</span>)) + <span class="number">10000</span>;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> secondKillService.startSecondKillByUpdate(skgId, userId);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">startSecondKillByUpdate</span><span class="params">(<span class="type">long</span> skgId, <span class="type">long</span> userId)</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 校验库存-悲观锁</span></span><br><span class="line">         <span class="type">SecondKill</span> <span class="variable">secondKill</span> <span class="operator">=</span> secondKillMapper.querySecondKillForUpdate(skgId);</span><br><span class="line">         <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> secondKill.getNumber();</span><br><span class="line">         <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//扣库存</span></span><br><span class="line">             secondKill.setNumber(number - <span class="number">1</span>);</span><br><span class="line">             secondKillMapper.updateById(secondKill);</span><br><span class="line">             <span class="comment">//创建订单</span></span><br><span class="line">             <span class="type">SuccessKilled</span> <span class="variable">killed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuccessKilled</span>();</span><br><span class="line">             killed.setSeckillId(skgId);</span><br><span class="line">             killed.setUserId(userId);</span><br><span class="line">             killed.setState((<span class="type">short</span>) <span class="number">0</span>);</span><br><span class="line">             killed.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">             successKilledMapper.insert(killed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//支付</span></span><br><span class="line">            <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>();</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setUserId(userId);</span><br><span class="line">            payment.setMoney(<span class="number">40</span>);</span><br><span class="line">            payment.setState((<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">            payment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">            paymentMapper.insert(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(SecondKillStateEnum.END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScorpiosException</span>(<span class="string">&quot;异常了个乖乖&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;SELECT * FROM seckill WHERE seckill_id=#&#123;skgId&#125; FOR UPDATE&quot;)</span></span><br><span class="line">SecondKill <span class="title function_">querySecondKillForUpdate</span><span class="params">(<span class="meta">@Param(&quot;skgId&quot;)</span> Long skgId)</span>;</span><br></pre></td></tr></table></figure><p><strong>悲观锁（二）</strong></p><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startSecondKillByUpdateTwo</span><span class="params">(<span class="type">long</span> skgId, <span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不校验，直接扣库存更新</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> secondKillMapper.updateSecondKillById(skgId);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">SuccessKilled</span> <span class="variable">killed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuccessKilled</span>();</span><br><span class="line">            killed.setSeckillId(skgId);</span><br><span class="line">            killed.setUserId(userId);</span><br><span class="line">            killed.setState((<span class="type">short</span>) <span class="number">0</span>);</span><br><span class="line">            killed.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">            successKilledMapper.insert(killed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//支付</span></span><br><span class="line">            <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>();</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setUserId(userId);</span><br><span class="line">            payment.setMoney(<span class="number">40</span>);</span><br><span class="line">            payment.setState((<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">            payment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">            paymentMapper.insert(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(SecondKillStateEnum.END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScorpiosException</span>(<span class="string">&quot;异常了个乖乖&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(value = &quot;UPDATE seckill SET number=number-1 WHERE seckill_id=#&#123;skgId&#125; AND number &gt; 0&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateSecondKillById</span><span class="params">(<span class="meta">@Param(&quot;skgId&quot;)</span> <span class="type">long</span> skgId)</span>;</span><br></pre></td></tr></table></figure><h3 id="方案三：乐观锁"><a href="#方案三：乐观锁" class="headerlink" title="方案三：乐观锁"></a>方案三：乐观锁</h3><p>乐观锁，顾名思义，就是对操作结果很乐观，通过利用version字段来判断数据是否被修改。乐观锁，不进行库存数量的校验，直接做库存扣减。如果并发量特别大，使用的乐观锁会出现大量的数据更新异常（抛异常就会导致购买失败）。</p><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/start/opt/lock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startOptLock</span><span class="params">(<span class="type">long</span> skgId)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始秒杀方式五...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() * (<span class="number">99999</span> - <span class="number">10000</span> + <span class="number">1</span>)) + <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 参数添加了购买数量</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> secondKillService.startSecondKillByPesLock(skgId, userId,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startSecondKillByPesLock</span><span class="params">(<span class="type">long</span> skgId, <span class="type">long</span> userId, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// 乐观锁，不进行库存数量的校验，直接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SecondKill</span> <span class="variable">kill</span> <span class="operator">=</span> secondKillMapper.selectById(skgId);</span><br><span class="line">        <span class="comment">// 剩余的数量应该要大于等于秒杀的数量</span></span><br><span class="line">        <span class="keyword">if</span>(kill.getNumber() &gt;= number) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> secondKillMapper.updateSecondKillByVersion(number,skgId,kill.getVersion());</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//创建订单</span></span><br><span class="line">                <span class="type">SuccessKilled</span> <span class="variable">killed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuccessKilled</span>();</span><br><span class="line">                killed.setSeckillId(skgId);</span><br><span class="line">                killed.setUserId(userId);</span><br><span class="line">                killed.setState((<span class="type">short</span>) <span class="number">0</span>);</span><br><span class="line">                killed.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">                successKilledMapper.insert(killed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//支付</span></span><br><span class="line">                <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>();</span><br><span class="line">                payment.setSeckillId(skgId);</span><br><span class="line">                payment.setSeckillId(skgId);</span><br><span class="line">                payment.setUserId(userId);</span><br><span class="line">                payment.setMoney(<span class="number">40</span>);</span><br><span class="line">                payment.setState((<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">                payment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis()));</span><br><span class="line">                paymentMapper.insert(payment);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.error(SecondKillStateEnum.END);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScorpiosException</span>(<span class="string">&quot;异常了个乖乖&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(value = &quot;UPDATE seckill  SET number=number-#&#123;number&#125;,version=version+1 WHERE seckill_id=#&#123;skgId&#125; AND version = #&#123;version&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateSecondKillByVersion</span><span class="params">(<span class="meta">@Param(&quot;number&quot;)</span> <span class="type">int</span> number, <span class="meta">@Param(&quot;skgId&quot;)</span> <span class="type">long</span> skgId, <span class="meta">@Param(&quot;version&quot;)</span><span class="type">int</span> version)</span>;</span><br></pre></td></tr></table></figure><h3 id="方案三：消息队列"><a href="#方案三：消息队列" class="headerlink" title="方案三：消息队列"></a>方案三：消息队列</h3><p>这里用java队列queue模拟，实际可用MQ中间件。</p><p>队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀队列(固定长度为100)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondKillQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_MAX_SIZE</span>   <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于多线程间下单的队列</span></span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;SuccessKilled&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;SuccessKilled&gt;(QUEUE_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态内部类，实现单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SecondKillQueue</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="comment">// 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">SecondKillQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecondKillQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecondKillQueue <span class="title function_">getSkillQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> kill</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * add(e) 队列未满时，返回true；队列满则抛出IllegalStateException(“Queue full”)异常——AbstractQueue</span></span><br><span class="line"><span class="comment">     * put(e) 队列未满时，直接插入没有返回值；队列满时会阻塞等待，一直等到队列未满时再插入。</span></span><br><span class="line"><span class="comment">     * offer(e) 队列未满时，返回true；队列满时返回false。非阻塞立即返回。</span></span><br><span class="line"><span class="comment">     * offer(e, time, unit) 设定等待的时间，如果在指定时间内还不能往队列中插入数据则返回false，插入成功返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  Boolean  <span class="title function_">produce</span><span class="params">(SuccessKilled kill)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.offer(kill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费出队</span></span><br><span class="line"><span class="comment">     * poll() 获取并移除队首元素，在指定的时间内去轮询队列看有没有首元素有则返回，否者超时后返回null</span></span><br><span class="line"><span class="comment">     * take() 与带超时时间的poll类似不同在于take时候如果当前队列空了它会一直等待其他线程调用notEmpty.signal()才会被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  SuccessKilled <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动消费队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SecondKillService seckillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;队列启动成功&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 进程内队列</span></span><br><span class="line">                    <span class="type">SuccessKilled</span> <span class="variable">kill</span> <span class="operator">=</span> SecondKillQueue.getSkillQueue().consume();</span><br><span class="line">                    <span class="keyword">if</span>(kill != <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> seckillService.startSecondKill(kill.getSeckillId(), kill.getUserId());</span><br><span class="line">                        <span class="keyword">if</span>(result != <span class="literal">null</span> &amp;&amp; result.equals(Result.ok(SecondKillStateEnum.SUCCESS)))&#123;</span><br><span class="line">                            log.info(<span class="string">&quot;TaskRunner,result:&#123;&#125;&quot;</span>,result);</span><br><span class="line">                            log.info(<span class="string">&quot;TaskRunner从消息队列取出用户，用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public Result startSecondKill(long skgId, long userId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 校验库存</span><br><span class="line">        SecondKill secondKill = secondKillMapper.selectById(skgId);</span><br><span class="line">        Integer number = secondKill.getNumber();</span><br><span class="line">        if (number &gt; 0) &#123;</span><br><span class="line">            //扣库存</span><br><span class="line">            secondKill.setNumber(number - 1);</span><br><span class="line">            secondKillMapper.updateById(secondKill);</span><br><span class="line">            //创建订单</span><br><span class="line">            SuccessKilled killed = new SuccessKilled();</span><br><span class="line">            killed.setSeckillId(skgId);</span><br><span class="line">            killed.setUserId(userId);</span><br><span class="line">            killed.setState((short) 0);</span><br><span class="line">            killed.setCreateTime(new Timestamp(System.currentTimeMillis()));</span><br><span class="line">            successKilledMapper.insert(killed);</span><br><span class="line"></span><br><span class="line">            //支付</span><br><span class="line">            Payment payment = new Payment();</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setSeckillId(skgId);</span><br><span class="line">            payment.setUserId(userId);</span><br><span class="line">            payment.setMoney(40);</span><br><span class="line">            payment.setState((short) 1);</span><br><span class="line">            payment.setCreateTime(new Timestamp(System.currentTimeMillis()));</span><br><span class="line">            paymentMapper.insert(payment);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Result.error(SecondKillStateEnum.END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    //            throw new ScorpiosException(&quot;异常了个乖乖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">return Result.ok(SecondKillStateEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列入数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/start/queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startQueue</span><span class="params">(<span class="type">long</span> skgId)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始秒杀方式六...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() * (<span class="number">99999</span> - <span class="number">10000</span> + <span class="number">1</span>)) + <span class="number">10000</span>;</span><br><span class="line">        <span class="type">SuccessKilled</span> <span class="variable">kill</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuccessKilled</span>();</span><br><span class="line">        kill.setSeckillId(skgId);</span><br><span class="line">        kill.setUserId(userId);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> SecondKillQueue.getSkillQueue().produce(kill);</span><br><span class="line">        <span class="comment">// 虽然进入了队列，但是不一定能秒杀成功 进队出队有时间间隙,消费跟不上生产</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,userId,<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConfigurationProperties动态刷新</title>
      <link href="/2024/01/21/SpringBoot/ConfigurationProperties%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/"/>
      <url>/2024/01/21/SpringBoot/ConfigurationProperties%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>详细介绍在Spring Cloud中被@ConfigurationProperties注解的类如何被动态刷新。通过了解其工作原理，我们可以更好地利用Spring Cloud的动态配置功能，实现应用程序的灵活性和可扩展性。</p><span id="more"></span><p>当配置发生变化时，标记为 @RefreshScope 的 Spring @Bean 会得到特殊处理。此功能可解决有状态 Bean 的问题，因为这些 Bean 只有在初始化时才会注入配置。有时，在某些只能初始化一次的 Bean 上甚至必须应用 @RefreshScope 注解。如果某个 Bean 是 “不可变 “的，则必须使用 @RefreshScope 注解或在属性关键字下指定类名：<strong>spring.cloud.refresh.extra-refreshable</strong>，通过该配置指定具体的类后，该类也将能够动态的更新内容。相反，如果你不希望某个Bean被动态改变了，你可以使用<strong>spring.cloud.refresh.never-refreshable</strong>配置属性指定具体的类。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="查找-ConfigurationProperties注解的类"><a href="#查找-ConfigurationProperties注解的类" class="headerlink" title="查找@ConfigurationProperties注解的类"></a>查找@ConfigurationProperties注解的类</h4><p>容器自动配置了如下的Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurationPropertiesBeans <span class="title function_">configurationPropertiesBeans</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBeans</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类用来管理@ConfigurationProperties注解的类。该类还是一个BeanPostProcessor处理器类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesBeans</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, ConfigurationPropertiesBean&gt; beans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 如果这个类已经是refresh作用域了，那么直接跳过。</span></span><br><span class="line">    <span class="comment">// 被@RefreshScope注解的类是被创建代理后重新创建对象的。</span></span><br><span class="line">    <span class="keyword">if</span> (isRefreshScoped(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前的bean</span></span><br><span class="line">    <span class="type">ConfigurationPropertiesBean</span> <span class="variable">propertiesBean</span> <span class="operator">=</span> ConfigurationPropertiesBean.get(<span class="built_in">this</span>.applicationContext, bean, beanName);</span><br><span class="line">    <span class="keyword">if</span> (propertiesBean != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.beans.put(beanName, propertiesBean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入ConfigurationPropertiesBean#get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesBean</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ConfigurationPropertiesBean <span class="title function_">get</span><span class="params">(ApplicationContext applicationContext, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们定义的Bean 可能是通过@Bean的方式@ConfigurationProperties也可以用在方法上，</span></span><br><span class="line">    <span class="comment">// 所以这里要获取对应创建该bean的方法</span></span><br><span class="line">    <span class="comment">// 所以这里可能返回null，不是通过@Bean注解的方式定义的bean</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">factoryMethod</span> <span class="operator">=</span> findFactoryMethod(applicationContext, beanName);</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="keyword">return</span> create(beanName, bean, bean.getClass(), factoryMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ConfigurationPropertiesBean <span class="title function_">create</span><span class="params">(String name, Object instance, Class&lt;?&gt; type, Method factory)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里就先从Method上查找，如果没有在到类上查找</span></span><br><span class="line">    <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> findAnnotation(instance, type, factory, ConfigurationProperties.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找是否有@Validate注解，也就是说咱们定义的属性配置类是支持数据验证的</span></span><br><span class="line">    <span class="type">Validated</span> <span class="variable">validated</span> <span class="operator">=</span> findAnnotation(instance, type, factory, Validated.class);</span><br><span class="line">    Annotation[] annotations = (validated != <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">Annotation</span>[] &#123; annotation, validated &#125;</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">Annotation</span>[] &#123; annotation &#125;;</span><br><span class="line">    <span class="comment">// 下面的操作就是绑定对象与配置属性了。</span></span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">bindType</span> <span class="operator">=</span> (factory != <span class="literal">null</span>) ? ResolvableType.forMethodReturnType(factory)</span><br><span class="line">        : ResolvableType.forClass(type);</span><br><span class="line">    Bindable&lt;Object&gt; bindTarget = Bindable.of(bindType).withAnnotations(annotations);</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">      bindTarget = bindTarget.withExistingValue(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBean</span>(name, instance, annotation, bindTarget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有加了@ConfigurationProperties注解的类都被包装到了ConfigurationPropertiesBean对象中。最后回到ConfigurationPropertiesBeans类中。将创建的所有ConfigurationPropertiesBean都添加到了一个Map集合中。</p><p>到这里就将容器中的所有@ConfigurationProperties注解的类查找完成。接下来就是对属性发生变化的类进行重新绑定操作了。</p><h4 id="重新绑定-ConfigurationProperties注解的类"><a href="#重新绑定-ConfigurationProperties注解的类" class="headerlink" title="重新绑定@ConfigurationProperties注解的类"></a>重新绑定@ConfigurationProperties注解的类</h4><p>容器自动配置了如下的Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> ConfigurationPropertiesRebinder <span class="title function_">configurationPropertiesRebinder</span><span class="params">(ConfigurationPropertiesBeans beans)</span> &#123;</span><br><span class="line">  <span class="comment">// 这里就注入了上一步中我们查找到的所有被@ConfigurationProperties注解的类</span></span><br><span class="line">  <span class="type">ConfigurationPropertiesRebinder</span> <span class="variable">rebinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesRebinder</span>(beans);</span><br><span class="line">  <span class="keyword">return</span> rebinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类是一个事件监听器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ManagedResource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesRebinder</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, ApplicationListener&lt;EnvironmentChangeEvent&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> ConfigurationPropertiesBeans beans;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ConfigurationPropertiesRebinder</span><span class="params">(ConfigurationPropertiesBeans beans)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.beans = beans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听EnvironmentChangeEvent上下文环境发生变化后的事件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(EnvironmentChangeEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了防止当前存在父子容器情况，判断下只处理自身容器中发生变化的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext.equals(event.getSource())</span><br><span class="line">        || event.getKeys().equals(event.getSource())) &#123;</span><br><span class="line">      <span class="comment">// 执行重新绑定</span></span><br><span class="line">      rebind();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebind</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String name : <span class="built_in">this</span>.beans.getBeanNames()) &#123;</span><br><span class="line">      rebind(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rebind</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext;</span><br><span class="line">    <span class="keyword">while</span> (appContext != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 再次判断当前的上下文中存在bean</span></span><br><span class="line">      <span class="keyword">if</span> (appContext.containsLocalBean(name)) &#123;</span><br><span class="line">        <span class="comment">// 重新绑定</span></span><br><span class="line">        <span class="keyword">return</span> rebind(name, appContext);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在从父容器中查找</span></span><br><span class="line">        appContext = appContext.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">rebind</span><span class="params">(String name, ApplicationContext appContext)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从容器中获取bean的实例对象</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> appContext.getBean(name);</span><br><span class="line">      <span class="comment">// 如果是代理对象，则获取被代理的那个真实对象，因为被注入的就是那个真实的对象</span></span><br><span class="line">      <span class="keyword">if</span> (AopUtils.isAopProxy(bean)) &#123;</span><br><span class="line">        bean = ProxyUtils.getTargetObject(bean);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里就会判断spring.cloud.refresh.never-refreshable中你配置的类</span></span><br><span class="line">        <span class="comment">// 与当前要重新绑定的类匹配了那就跳过。</span></span><br><span class="line">        <span class="keyword">if</span> (getNeverRefreshable().contains(bean.getClass().getName())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里执行下当前Bean的生命周期钩子回调</span></span><br><span class="line">        appContext.getAutowireCapableBeanFactory().destroyBean(bean);</span><br><span class="line">        <span class="comment">// 这里就执行绑定操作了，其中就会执行（ConfigurationPropertiesBindingPostProcessor）执行绑定</span></span><br><span class="line">        appContext.getAutowireCapableBeanFactory().initializeBean(bean, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此你也就知道了关于@ConfigurationProperties注解的类是如何被重新绑定的。接下来就是还差一步，是谁来触发ConfigurationPropertiesRebinder监听的EnvironmentChangeEvent事件的。</p><h4 id="触发EnvironmentChangeEvent事"><a href="#触发EnvironmentChangeEvent事" class="headerlink" title="触发EnvironmentChangeEvent事"></a>触发EnvironmentChangeEvent事</h4><p>SpringCloud提供了一个RefreshEndpoint actuator接口，通过调用&#x2F;actuator&#x2F;refresh接口进行触发刷新动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContextRefresher</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;String&gt; <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 刷新上下文</span></span><br><span class="line">    Set&lt;String&gt; keys = refreshEnvironment();</span><br><span class="line">    <span class="comment">// 所有的refresh作用域的Bean都进行刷新</span></span><br><span class="line">    <span class="built_in">this</span>.scope.refreshAll();</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;String&gt; <span class="title function_">refreshEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; before = extract(<span class="built_in">this</span>.context.getEnvironment().getPropertySources());</span><br><span class="line">    updateEnvironment();</span><br><span class="line">    Set&lt;String&gt; keys = changes(before, extract(<span class="built_in">this</span>.context.getEnvironment().getPropertySources())).keySet();</span><br><span class="line">    <span class="comment">// 这里进行事件的发布</span></span><br><span class="line">    <span class="built_in">this</span>.context.publishEvent(<span class="keyword">new</span> <span class="title class_">EnvironmentChangeEvent</span>(<span class="built_in">this</span>.context, keys));</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果您使用的数据源 Bean 是 HikariDataSource，则无法刷新。这是 spring.cloud.refresh.never-refreshable 的默认值。如果需要刷新，请选择不同的数据源实现。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostConstruct注解</title>
      <link href="/2024/01/21/Spring/PostConstruct%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/01/21/Spring/PostConstruct%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>@PostContruct全限定类名是javax.annotation.PostConstruct，可以看出来其本身不是Spring定义的注解，但是Spring提供了具体的实现。</p><span id="more"></span><h4 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h4><p>1、要在依赖加载后，对象调用前执行，并且只执行一次；</p><p>2、所有支持依赖注入的类都需要支持此方法。即使类没有请求注入任何的资源，也必须调用被@PostConstruct注解标记的方法；</p><p>3、一个类中在一个方法上使用@PostConstruct注解；</p><p>4、使用@PostConstruct注解标记的方法不能有参数，除非是拦截器，可以采用拦截器规范定义的InvocationContext对象。</p><p>5、使用@PostConstruct注解标记的方法不能有返回值，实际上如果有返回值，也不会报错，但是会忽略掉；</p><p>6、使用@PostConstruct注解标记的方法的权限，public、private、protected都可以；</p><p>7、使用@PostConstruct注解标记的方法不能被static修饰，但是final是可以的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span> (RUNTIME)</span><br><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostConstruct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的Spring项目中Bean的生命周期里，其执行的时机是：</p><p>1、Bean的实例化；</p><p>2、Bean内依赖属性的注入 ；</p><p>3、Bean里被@PostConstruct标记的方法</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>1、定义一个ExampleController类，采用setter的依赖注入的方式，注入exampleService属性，另外在定义一个myPostConstruct方法用@PostConstruct注解标记；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExampleService exampleService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleController</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;----ExampleController无参数构造方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExampleService</span><span class="params">(ExampleService exampleService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.exampleService = exampleService;</span><br><span class="line">        log.info(<span class="string">&quot;----ExampleController类的setExampleService方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPostConstruct</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;----ExampleController类的myPostConstruct方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义ExampleService类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleService</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;----ExampleService的无参数构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义一个单元测试，在单元测试中启动Spring容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;----单元测试执行开始&quot;</span>);</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.fanfu&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;----单元测试执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从单元测试的执行结果来看，首先，ExampleConstroller被实例化，接着是ExampleService被实例化，然后通过setter依赖注入的方式把ExampleService对象注入到了ExampleConstroller对象中，之后才开始了被@PostConstruct注解标记的myPostConstruct方法的执行。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1、Spring容器启动过程的最后一步，即把需要提前注册的一些非懒加载的单例Bean时，如ExampleController，注意这时exampleController对象实例化完成，需要注入的exampleService的属性已经被实例化，且已经注入到exampleController对象中，在BeanPostProcessor接口的扩展方法中，被@PostConstruct标记的方法开始触发执行，入口位置在AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      result = current;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、那么触发被@PostConstruct注解标记的方法执行的BeanPostProcessor接口的具体是实现是哪个类呢？通过debug分析，是CommonAnnotationBeanPostProcessor类；CommonAnnotationBeanPostProcessor类继承于InitDestroyAnnotationBeanPostProcessor，实际的触发@PostConstruct标记方法执行的入口是在InitDestroyAnnotationBeanPostProcessor的postProcessBeforeInitialization()</p><p>3、InitDestroyAnnotationBeanPostProcessor的postProcessBeforeInitialization()内，逻辑相对比较简洁，先查询bean中被@PostConstruct标记的方法，然后再使用java反射来执行这个方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//查询bean中被@PostConstruct标记的方法，相关的信息封在LifecycleMetadata对象的</span></span><br><span class="line">    <span class="type">LifecycleMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findLifecycleMetadata(bean.getClass());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用java反射执行被@PostConstruct标记的方法</span></span><br><span class="line">      metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex.getTargetException());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Failed to invoke init method&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>从以上几步的分析来看，被@PostConstruct标记的方法是怎么被执行的：在Bean实例化、属性注入后，被@PostConstruct标记的方法是在BeanPostProcessor的扩展方法postProcessBeforeInitialization()触发执行的，具体实现类是InitDestroyAnnotationBeanPostProcessor，具体的逻辑是：先查询被@PostConstruct标记的方法，然后使用java反射去执行这个方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConfigurationProperties注解</title>
      <link href="/2024/01/21/SpringBoot/ConfigurationProperties%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/01/21/SpringBoot/ConfigurationProperties%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>@ConfigurationProperties注解，常用于属性参数松散绑定、数据校验等。</p><span id="more"></span><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>@ConfigurationProperties</code>主要作用就是将prefix属性指定的前缀配置项的值绑定到这个JavaBean上 ，通过指定的前缀，来绑定配置文件中的配置，通过如下源码可以看出， 如果你想绑定和验证一些外部属性，可以将它添加到类定义或<code>@Configuration</code>类中的<code>@Bean</code>方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation for externalized configuration. Add this to a class definition or a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method in a &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class if you want to bind and validate</span></span><br><span class="line"><span class="comment"> * some external Properties (e.g. from a .properties file).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Binding is either performed by calling setters on the annotated class or, if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConstructorBinding <span class="doctag">@ConstructorBinding</span>&#125; is in use, by binding to the constructor</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that contrary to &#123;<span class="doctag">@code</span> <span class="doctag">@Value</span>&#125;, SpEL expressions are not evaluated since property</span></span><br><span class="line"><span class="comment"> * values are externalized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationPropertiesScan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConstructorBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableConfigurationProperties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The prefix of the properties that are valid to bind to this object. Synonym for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #prefix()&#125;. A valid prefix is defined by one or more words separated with</span></span><br><span class="line"><span class="comment"> * dots (e.g. &#123;<span class="doctag">@code</span> &quot;acme.system.feature&quot;&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the prefix of the properties to bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;prefix&quot;)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The prefix of the properties that are valid to bind to this object. Synonym for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #value()&#125;. A valid prefix is defined by one or more words separated with</span></span><br><span class="line"><span class="comment"> * dots (e.g. &#123;<span class="doctag">@code</span> &quot;acme.system.feature&quot;&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the prefix of the properties to bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flag to indicate that when binding to this object invalid fields should be ignored.</span></span><br><span class="line"><span class="comment"> * Invalid means invalid according to the binder that is used, and usually this means</span></span><br><span class="line"><span class="comment"> * fields of the wrong type (or that cannot be coerced into the correct type).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the flag value (default false)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flag to indicate that when binding to this object unknown fields should be ignored.</span></span><br><span class="line"><span class="comment"> * An unknown field could be a sign of a mistake in the Properties.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the flag value (default true)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>标注在类上</strong></p><p>application.yml文件配置内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userInfo:</span></span><br><span class="line">  <span class="attr">userId:</span> <span class="number">1001</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lucy</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   <span class="comment">//使用该注解需要导入Lombok依赖</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;userinfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性类注入使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">getUserInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标注在方法上</strong></p><p>源码中说到可以将它添加到<code>@Configuration</code>类中的<code>@Bean</code>方法上。比如我们用到druid数据源的操作，这个数据源是属于第三方的，所以我们不能操作源码，不能再源码里面找到它的对象来给他添加注解，但我们可以在yml文件中给他配置，来拿到它的属性。</p><p>添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml文件中配置数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>创建一个配置类，然后在类方法上添加注解，并通过prefix绑定数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatasourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.database.druid&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">database</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="松散绑定"><a href="#松散绑定" class="headerlink" title="松散绑定"></a>松散绑定</h4><p>在使用 <code>@ConfigurationProperties</code>注解的时候，<code>@ConfigurationProperties(prefix = “userinfo”)</code>，这里给prefix的属性值与yml文件中的属性名称不一致，但是依旧绑定成功了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userInfo:</span></span><br><span class="line">  <span class="attr">userId:</span> <span class="number">1001</span> <span class="comment"># 驼峰命名方式</span></span><br><span class="line">  <span class="comment">#user_id: 1002 #下划线方式</span></span><br><span class="line">  <span class="comment">#user-id: 1003 #烤肉串方式</span></span><br><span class="line">  <span class="comment">#USER_ID: 1004 # 常量方式</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lucycd</span></span><br></pre></td></tr></table></figure><p>这是因为Spring的松散绑定属性规则；需要注意的是，prefix的属性值必须全部为小写，就像下图所示，就会报错：前缀必须是规范形式。</p><p><img src="/2024/01/21/SpringBoot/ConfigurationProperties%E6%B3%A8%E8%A7%A3/1.png" alt="image-20240121122118642"></p><p><img src="/2024/01/21/SpringBoot/ConfigurationProperties%E6%B3%A8%E8%A7%A3/2.png" alt="image-20240121122118642"></p><h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>Spring Boot中有很多配置文件，配置文件中我们可以自定义一些对应的属性值。那么这些属性值是否合法呢？我们如何来校验？在Java中有一种JSR303规范，我们可以针对一些对应的数值来进行校验。按照规范来进行书写，如果不符合要求就说明校验失败，反之，则成功！</p><p>添加依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给属性添加验证规则，（<code>@Validated</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;userinfo&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Max(value = 1000,message = &quot;userid超出范围了！&quot;)</span></span><br><span class="line">   <span class="meta">@Min(value = 0,message = &quot;userid不能小于0！&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Size(min = 2,max = 5,message = &quot;name长度应该在2-5之间&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若配置数据不符合规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userInfo:</span></span><br><span class="line">  <span class="attr">userId:</span> <span class="number">1001</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">aafsfsdf</span></span><br></pre></td></tr></table></figure><p>重新运行程序</p><p><img src="/2024/01/21/SpringBoot/ConfigurationProperties%E6%B3%A8%E8%A7%A3/3.png" alt="image-20240121122911881"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【面试】TCP是如何保证可靠传输的?</title>
      <link href="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/"/>
      <url>/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>网络中存在多种因素可能导致数据在传输过程中丢失、损坏或乱序，如传输媒介的不稳定性、拥塞、丢包等。为应对这些问题，TCP引入了一系列机制来保证数据的可靠传输。</p><span id="more"></span><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/1.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/2.png" alt="图片"></p><h4 id="连接管理机制"><a href="#连接管理机制" class="headerlink" title="连接管理机制"></a><strong>连接管理机制</strong></h4><p>TCP是一种面向连接的可靠传输协议，TCP使用三次握手和四次挥手来建立和终止连接。通过三次握手，发送方和接收方交换序列号、窗口大小等信息，确保双方都准备好进行数据传输。在传输过程中，通过四次挥手正常终止连接，确保最后的数据能够完整传输。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/3.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/4.png" alt="图片"></p><h4 id="序列号和确认应答机制"><a href="#序列号和确认应答机制" class="headerlink" title="序列号和确认应答机制"></a><strong>序列号和确认应答机制</strong></h4><p>TCP通过给每个字节分配一个序列号来跟踪数据的传输。发送方按序列号将数据分割成多个报文段，并发送到网络中。接收方通过确认应答（ACK）机制告知发送方已成功接收到数据。如果发送方在一定时间内未收到确认应答，则会重新发送相应的数据。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/5.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/6.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/7.png" alt="图片"></p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a><strong>重传机制</strong></h4><p>为了确保数据的可靠传输，TCP在发送数据后启动一个定时器。如果在定时器时间内未接收到确认应答，则认为数据丢失，发送方会重新发送该数据（超时重传）。此外，如果收到同一个数据包的多次确认，说明也有数据丢失，也会触发重传（快速重传）。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/8.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/9.png" alt="图片"></p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h4><p>流量控制，就是接收方调控发送方的发送速度不要太快的机制 。滑动窗口机制允许发送方在未收到确认应答之前发送多个数据报文段，提高传输效率。接收方通过窗口大小来告知发送方可以接收的数据量。发送方根据窗口大小进行流量控制，确保不会发送超出接收方处理能力的数据。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/10.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/11.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/12.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/13.png" alt="图片"></p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h4><p>TCP还通过拥塞控制机制来优化网络性能并避免网络拥塞。拥塞控制算法根据网络的拥塞情况自适应地调整发送方的发送速率，防止过多的数据注入网络，避免网络拥塞和数据丢失。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/14.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/15.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/16.png" alt="图片"></p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/17.png" alt="图片"></p><p>TCP通过上述机制来保证数据的可靠传输，确保数据在网络中的完整性、一致性和正确性。无论是处理网络丢包、乱序、拥塞还是其他异常情况，TCP都能自适应地调整传输策略，提供可靠的传输服务。</p><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84/18.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conditional注解</title>
      <link href="/2024/01/20/SpringBoot/Conditional%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/01/20/SpringBoot/Conditional%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><code>@Conditional</code>注解是Spring Boot中条件化装配的关键工具，它提供了一种方式，根据特定的条件决定是否装配Bean。</p><span id="more"></span><h3 id="SpringBoot常见Condition"><a href="#SpringBoot常见Condition" class="headerlink" title="SpringBoot常见Condition"></a>SpringBoot常见Condition</h3><p> <strong>使用@ConditionalOnMissingBean</strong></p><p><code>@ConditionalOnMissingBean</code>注解用于判断是否存在某个Bean，如果不存在则进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果容器中不存在名为<code>myBean</code>的Bean，则<code>MyBeanConfiguration</code>将被装配。</p><p><strong>使用@ConditionalOnExpression</strong></p><p><code>@ConditionalOnExpression</code>注解允许使用SpEL表达式进行更为灵活的条件判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression(&quot;$&#123;myapp.environment&#125; == &#x27;prod&#x27;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 生产环境下的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ProductionConfiguration</code>将只在<code>myapp.environment</code>属性的值为<code>prod</code>时才被装配。</p><h3 id="Conditional注解的原理"><a href="#Conditional注解的原理" class="headerlink" title="@Conditional注解的原理"></a>@Conditional注解的原理</h3><p><code>@Conditional</code>注解的原理是通过<code>Condition</code>接口的实现类来判断条件是否成立。在<code>ConfigurationClassPostProcessor</code>的处理过程中，会根据条件的判断结果来决定是否将配置类加入到ApplicationContext中。</p><h3 id="自定义Condition"><a href="#自定义Condition" class="headerlink" title="自定义Condition"></a>自定义Condition</h3><p>可以创建自定义的<code>Condition</code>实现，实现更为灵活的条件判断。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据复杂逻辑判断是否进行装配</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在配置类中使用自定义Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCustomCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义条件下的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过自定义<code>Condition</code>，可以根据更为复杂的业务逻辑和外部条件来决定是否装配某个Bean。</p><h3 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h3><p>有时候，需要根据多个条件的组合来进行装配判断。Spring Boot允许使用<code>@ConditionalOn...</code>注解的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.springframework.web.servlet.DispatcherServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFeatureWebAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 组合条件下的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyFeatureWebAutoConfiguration</code>将只在<code>myapp.feature.enabled</code>为<code>true</code>且类路径中存在<code>DispatcherServlet</code>时才会被装配。</p><p><strong>组合自定义Condition</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(&#123;MyCustomCondition.class, AnotherCustomCondition.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinedConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 组合自定义条件下的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Conditional</code>的组合，可以实现更为灵活的条件判断，满足复杂场景下的需求。</p><h3 id="条件属性的动态化"><a href="#条件属性的动态化" class="headerlink" title="条件属性的动态化"></a>条件属性的动态化</h3><p>在实际应用中，有时候需要根据外部配置来动态调整条件的属性值。Spring Boot允许使用SpEL表达式来实现这一目的</p><p><strong>使用SpEL表达式动态化属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.environment&quot;, havingValue = &quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 开发环境下的配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.environment&quot;, havingValue = &quot;prod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 生产环境下的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DevConfiguration</code>将在<code>myapp.environment</code>为<code>dev</code>时被装配，而<code>ProdConfiguration</code>将在<code>myapp.environment</code>为<code>prod</code>时被装配。</p><p><strong>使用外部配置文件动态化属性</strong></p><p>application.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp:</span><br><span class="line">  environment: dev</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.environment&quot;, havingValue = &quot;$&#123;myapp.environment&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 根据外部配置文件动态化的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DynamicConfiguration</code>将根据<code>myapp.environment</code>属性的值进行动态装配，而该值可以通过外部配置文件进行灵活配置。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>模块化配置</strong></p><p>通过<code>@Conditional</code>注解，可以根据项目的模块化结构，灵活选择性地进行配置装配。例如，将不同的配置拆分为不同的模块，根据项目需要选择性地加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyModuleCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyModuleConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 模块化配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>版本化配置</strong></p><p>有时候，需要根据不同的版本要求加载不同的配置。通过<code>@Conditional</code>注解，我们可以实现版本化的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.version&quot;, havingValue = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version1Configuration</span> &#123;</span><br><span class="line">    <span class="comment">// 版本1的配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.version&quot;, havingValue = &quot;2.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version2Configuration</span> &#123;</span><br><span class="line">    <span class="comment">// 版本2的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conditional </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Controller参数注入</title>
      <link href="/2024/01/13/SpringBoot/Controller%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/01/13/SpringBoot/Controller%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>动态为Controller方法注入参数，比如当前用户对象。</p><span id="more"></span><p><img src="/2024/01/13/SpringBoot/Controller%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/1.png" alt="image-20240113194536519"></p><p>pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.dx.springboot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springboot-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">  &lt;name&gt;springboot-test&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;modules&gt;</span><br><span class="line">    &lt;module&gt;swagger-test&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;json-test&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;argumentResolver-test&lt;/module&gt;</span><br><span class="line">  &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>指定参数注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绑定当前登录用户</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CurrentUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义参数动态注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态为Controller方法注入当前登录用户对象</span><br><span class="line"> */</span><br><span class="line">public class CurrentUserMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">        //判断当前Controller的方法中参数类、是否加入了CurrentUser注解</span><br><span class="line">        if(parameter.getParameterType().equals(User.class) &amp;&amp;</span><br><span class="line">                parameter.hasParameterAnnotation(CurrentUser.class))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">        //动态获取当前登录用户信息</span><br><span class="line"></span><br><span class="line">        //最终封装成User对象返回即可，这样在Controller的方法形参就可以直接引用到User对象了</span><br><span class="line">        User user = new User(1L,&quot;admin&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ArgumentResolverConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line">    public CurrentUserMethodArgumentResolver getCurrentUserMethodArgumentResolver()&#123;</span><br><span class="line">        return new CurrentUserMethodArgumentResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //注册自定义参数解析器</span><br><span class="line">    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;</span><br><span class="line">        resolvers.add(getCurrentUserMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(UserController.class);</span><br><span class="line"></span><br><span class="line">    //获取当前系统登录用户</span><br><span class="line">    @GetMapping(&quot;/getCurrentUser&quot;)</span><br><span class="line">    public String getCurrentUser(@CurrentUser User user) &#123;</span><br><span class="line">        String name = user.getUsername();</span><br><span class="line">        logger.info(&quot;UserController getCurrentUser方法...&#123;&#125;&quot;, user);</span><br><span class="line">        return user.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动应用，访问接口，查看日志</p><p><img src="/2024/01/13/SpringBoot/Controller%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/2.png" alt="image-20240113194923529"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章合集</title>
      <link href="/2024/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/"/>
      <url>/2024/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>计算机网络相关文章合集</p><span id="more"></span><p><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA">一个故事讲完https</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子商城</title>
      <link href="/2024/01/10/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%94%B5%E5%AD%90%E5%95%86%E5%9F%8E/"/>
      <url>/2024/01/10/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%94%B5%E5%AD%90%E5%95%86%E5%9F%8E/</url>
      
        <content type="html"><![CDATA[<p>电子商城系统相关业务说明与系统架构。</p><span id="more"></span><p>浅析电商系统架构设计:<a href="https://mp.weixin.qq.com/s/lwKiIyWNuxs--DS8t7JEEA">https://mp.weixin.qq.com/s/lwKiIyWNuxs--DS8t7JEEA</a></p><p>大厂防止超卖的 7 种实现，很受用：<a href="https://mp.weixin.qq.com/s/rdwMy81hrrHEg0Xs0YgXeQ">https://mp.weixin.qq.com/s/rdwMy81hrrHEg0Xs0YgXeQ</a></p><p>携程商旅订单系统架构设计和优化实践：<a href="https://mp.weixin.qq.com/s/s6PEuoemmf_npeZFbDqRFg">https://mp.weixin.qq.com/s/s6PEuoemmf_npeZFbDqRFg</a></p><p>一文讲透阿里商旅账单系统架构设计实践：<a href="https://mp.weixin.qq.com/s/n7mUcdSGxfC2tfBqFNguJA">https://mp.weixin.qq.com/s/n7mUcdSGxfC2tfBqFNguJA</a></p><p>Java 生鲜电商平台 - API 接口设计之 token、timestamp、sign 具体架构与实现：<a href="https://mp.weixin.qq.com/s/b5sNUJswdfeoDuvdokVKyA">https://mp.weixin.qq.com/s/b5sNUJswdfeoDuvdokVKyA</a></p><p>扫码登陆：<a href="https://mp.weixin.qq.com/s/wxOcTnR-z_IhB_M_80w9wA">https://mp.weixin.qq.com/s/wxOcTnR-z_IhB_M_80w9wA</a></p><p>小型电商Web架构：<a href="https://mp.weixin.qq.com/s/BJKx3dP3MZtfD1Yx3olbAw">https://mp.weixin.qq.com/s/BJKx3dP3MZtfD1Yx3olbAw</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis合集</title>
      <link href="/2024/01/10/redis/redis%E5%90%88%E9%9B%86/"/>
      <url>/2024/01/10/redis/redis%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>redis合集</p><span id="more"></span><p>Redis到底是单线程还是多线程程序？:<a href="https://mp.weixin.qq.com/s/krvb4H9ljaQz3fBVSCyv8Q">https://mp.weixin.qq.com/s/krvb4H9ljaQz3fBVSCyv8Q</a></p><p>Redis 集群模式：<a href="https://mp.weixin.qq.com/s/nOFGPTydhMjF9zPOv1GSRg">https://mp.weixin.qq.com/s/nOFGPTydhMjF9zPOv1GSRg</a></p><p>得物 Redis 设计与实践：<a href="https://mp.weixin.qq.com/s/dnlxCXgAxHsfyVNYTDsewA">https://mp.weixin.qq.com/s/dnlxCXgAxHsfyVNYTDsewA</a></p><p>Spring Cache 操作 Redis 实现数据缓存-上：<a href="https://mp.weixin.qq.com/s/eowKXZ1Bp42g9gSCEka9TA">https://mp.weixin.qq.com/s/eowKXZ1Bp42g9gSCEka9TA</a></p><p>Spring Cache 操作 Redis 实现数据缓存-下：<a href="https://mp.weixin.qq.com/s/heTAQ-H-DeldQcVIaheN3A">https://mp.weixin.qq.com/s/heTAQ-H-DeldQcVIaheN3A</a></p><p>Redis 是如何实现点赞、取消点赞的：<a href="https://mp.weixin.qq.com/s/JGM9FnuzxmPCg8-Q-t9j-Q">https://mp.weixin.qq.com/s/JGM9FnuzxmPCg8-Q-t9j-Q</a></p><p>Redis常见、常用的知识点：<a href="https://mp.weixin.qq.com/s/RPSxd-DjtLxqN2nsgW_QMQ">https://mp.weixin.qq.com/s/RPSxd-DjtLxqN2nsgW_QMQ</a></p><p><a href="https://mp.weixin.qq.com/s/ZPXEF28il4BIOlIBAYXFzA">高可用之战：Redis Sentinal（哨兵模式）</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付系统</title>
      <link href="/2024/01/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/01/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>支付系统相关业务说明与系统架构。</p><span id="more"></span><p>支付业务：</p><p><a href="https://mp.weixin.qq.com/s/JfeNT9EnTeIpwMbA7HWaeA">支付与清结算的区别</a></p><p><a href="https://mp.weixin.qq.com/s/5hZX6CwWAn2Kz-Zb63chuw">直连与间连的区别</a></p><p><a href="https://mp.weixin.qq.com/s/4SlgVwSM9z9Kpm7_3HB7Vw">详解快捷支付</a></p><br/><br/><p>陈天宇宙：</p><p><a href="https://mp.weixin.qq.com/s/MiSsqFVzGnxYim4NP6drvQ">3.5万字：一文搞懂“支付系统”</a></p><p><a href="https://mp.weixin.qq.com/s/Ader32GWLIfHfI_rjfMOAA">对账系统，从入门到精通</a></p><p><a href="https://mp.weixin.qq.com/s/Df9ei0UR-2J-wFQNJx-tbg">支付清算生态</a></p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwOTYyODA4Nw==&action=getalbum&album_id=3250352738602024961&scene=173&subscene=&sessionid=undefined&enterid=0&from_msgid=2247486262&from_itemidx=1&count=3&nolastread=1#wechat_redirect">隐没星辰：百图解码支付系统设计与实现</a></p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MDIwNjAxMA==&action=getalbum&album_id=3342638180210098178&scene=173&subscene=&sessionid=undefined&enterid=0&from_msgid=2247485198&from_itemidx=1&count=3&nolastread=1#wechat_redirect">刚哥白话：支付设计</a></p><hr><p>系统设计：</p><p><a href="https://mp.weixin.qq.com/s/NvG9wR_GwEnKTHMfkTJWng">订单视角看支付｜得物技术</a></p><p><a href="https://mp.weixin.qq.com/s/gkIgj0Dp2b9X28owEGziiA">Spring Boot 集成支付宝支付</a></p><p><a href="https://mp.weixin.qq.com/s/X7aIBNdOm7NUr8gP4HZxcA">如何对接第三方支付通道</a></p><p><a href="https://mp.weixin.qq.com/s/z1me9clFSARX7jlJR1YwRQ">优雅的支付系统设计</a></p><p><a href="https://mp.weixin.qq.com/s/powqEKSsoNCwIdLP4ZGXAw">支付系统就该这么设计，稳的一批！！</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支付系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger2集成</title>
      <link href="/2024/01/07/SpringBoot/Swagger2%E9%9B%86%E6%88%90/"/>
      <url>/2024/01/07/SpringBoot/Swagger2%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>springboot整合swagger2。</p><span id="more"></span><p>项目结构</p><p><img src="/2024/01/07/SpringBoot/Swagger2%E9%9B%86%E6%88%90/1.png" alt="image-20240107234434446"></p><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>swagger2配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自动配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi1()&#123;</span><br><span class="line">        ApiInfo apiInfo = new ApiInfoBuilder().title(&quot;我的接口文档&quot;)</span><br><span class="line">                .contact(new Contact(&quot;xiangger&quot;,&quot;http://www.example.cn&quot;,&quot;xiangger@123.cn&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .description(&quot;接口文档描述&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //docket对象用于封装接口文档相关信息</span><br><span class="line">        Docket docket = new Docket(DocumentationType.SWAGGER_2).</span><br><span class="line">                        apiInfo(apiInfo).</span><br><span class="line">                        groupName(&quot;用户接口组&quot;)</span><br><span class="line">                        .select()</span><br><span class="line">                        .apis(RequestHandlerSelectors.basePackage(&quot;com.dx.springboot.controller.user&quot;)).</span><br><span class="line">                        build();</span><br><span class="line">        return docket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi2()&#123;</span><br><span class="line">        ApiInfo apiInfo = new ApiInfoBuilder().title(&quot;我的接口文档&quot;)</span><br><span class="line">                .contact(new Contact(&quot;xiangger&quot;,&quot;http://www.example.cn&quot;,&quot;xiangger@123.cn&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .description(&quot;接口文档描述&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //docket对象用于封装接口文档相关信息</span><br><span class="line">        Docket docket = new Docket(DocumentationType.SWAGGER_2).</span><br><span class="line">                apiInfo(apiInfo).</span><br><span class="line">                groupName(&quot;菜单接口组&quot;).select().</span><br><span class="line">                apis(RequestHandlerSelectors.basePackage(&quot;com.dx.springboot.controller.menu&quot;)).</span><br><span class="line">                build();</span><br><span class="line">        return docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>api接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 菜单控制器</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/menu&quot;)</span><br><span class="line">@Api(tags = &quot;菜单控制器&quot;)</span><br><span class="line">public class MenuController &#123;</span><br><span class="line">    @GetMapping(&quot;/getMenus&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;查询所有菜单&quot;, notes = &quot;查询所有菜单信息&quot;)</span><br><span class="line">    public List&lt;Menu&gt; getMenus() &#123;</span><br><span class="line">        Menu menu = new Menu();</span><br><span class="line">        menu.setId(100);</span><br><span class="line">        menu.setName(&quot;itcast&quot;);</span><br><span class="line">        List&lt;Menu&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(menu);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/save&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;新增菜单&quot;, notes = &quot;新增菜单信息&quot;)</span><br><span class="line">    public String save(@RequestBody Menu menu) &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;/update&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;修改菜单&quot;, notes = &quot;修改菜单信息&quot;)</span><br><span class="line">    public String update(@RequestBody Menu menu) &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/delete&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;删除菜单&quot;, notes = &quot;删除菜单信息&quot;)</span><br><span class="line">    public String delete(int id) &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;pageNum&quot;, value = &quot;页码&quot;,</span><br><span class="line">                    required = true, type = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;pageSize&quot;, value = &quot;每页条数&quot;,</span><br><span class="line">                    required = true, type = &quot;Integer&quot;),</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiOperation(value = &quot;分页查询菜单信息&quot;)</span><br><span class="line">    @GetMapping(value = &quot;page/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="line">    public String findByPage(@PathVariable Integer pageNum,</span><br><span class="line">                             @PathVariable Integer pageSize) &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户控制器</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@Api(tags = &quot;用户控制器&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/getUsers&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;查询所有用户&quot;, notes = &quot;查询所有用户信息&quot;)</span><br><span class="line">    public List&lt;User&gt; getAllUsers()&#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setId(100);</span><br><span class="line">        user.setName(&quot;itcast&quot;);</span><br><span class="line">        user.setAge(20);</span><br><span class="line">        user.setAddress(&quot;bj&quot;);</span><br><span class="line">        List&lt;User&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(user);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/save&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;新增用户&quot;, notes = &quot;新增用户信息&quot;)</span><br><span class="line">    public String save(@RequestBody User user)&#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;/update&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;修改用户&quot;, notes = &quot;修改用户信息&quot;)</span><br><span class="line">    public String update(@RequestBody User user)&#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/delete&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;删除用户&quot;, notes = &quot;删除用户信息&quot;)</span><br><span class="line">    public String delete(int id)&#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;pageNum&quot;, value = &quot;页码&quot;,</span><br><span class="line">                    required = true, type = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;pageSize&quot;, value = &quot;每页条数&quot;,</span><br><span class="line">                    required = true, type = &quot;Integer&quot;),</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiOperation(value = &quot;分页查询用户信息&quot;)</span><br><span class="line">    @GetMapping(value = &quot;page/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="line">    public String findByPage(@PathVariable Integer pageNum,</span><br><span class="line">                             @PathVariable Integer pageSize) &#123;</span><br><span class="line">        return &quot;OK&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动应用，访问：<a href="http://localhost:9000/swagger-ui.html">http://localhost:9000/swagger-ui.html</a></p><p><img src="/2024/01/07/SpringBoot/Swagger2%E9%9B%86%E6%88%90/2.png" alt="image-20240107235006796"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger2 </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信扫码登录</title>
      <link href="/2023/12/23/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"/>
      <url>/2023/12/23/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>什么是扫码登录。现在大部分同学手机上都装有微信、qq和淘宝这一类的软件。而这些app都有他们相对应的网页端。为了让用户在使用他们的网页时登录更加方便和安全，使用手机扫一扫就可以登录的服务，就显得自然而然了。 </p><span id="more"></span><p>几个主流大厂应用扫码登录时的界面效果如下：</p><p><img src="/2023/12/23/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/1.png" alt="图片"></p><h3 id="扫码登录功能的完整技术逻辑"><a href="#扫码登录功能的完整技术逻辑" class="headerlink" title="扫码登录功能的完整技术逻辑"></a>扫码登录功能的完整技术逻辑</h3><p><strong>1）网页端与服务器的配合逻辑</strong></p><p>首先用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，过期后，用户登录二维码需要进行刷新重新获取。</p><p>同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片。然后，将二维码图片和uuid一起返回给用户浏览器。</p><p>浏览器拿到二维码和uuid后，会每隔一秒向服务器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？</p><p><strong>2）手机端与服务器的配合逻辑：</strong></p><p>浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：请掏出您的手机，打开扫一扫进行登录。用户拿出手机扫描二维码，就可以得到一个验证信息和一个uuid。</p><p>由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都会携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多，也可以通过验签方式保证参数未被修改）。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。</p><p>服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。如果是，返回一个确认信息给手机端。</p><p>手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。</p><p><strong>3）登录成功时的逻辑：</strong></p><p>然后，浏览器再次发送请求的时候，浏览器端的服务器就可以得到一个用户Id，并调用登录的方法，生成一个浏览器端的token，再浏览器再次发送请求的时候，将用户信息返回给浏览器，登录成功。这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</p><p><img src="/2023/12/23/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/2.jpg" alt="图片"></p><h3 id="淘宝扫描登录示例"><a href="#淘宝扫描登录示例" class="headerlink" title="淘宝扫描登录示例"></a>淘宝扫描登录示例</h3><p>登录界面 <a href="https://login.taobao.com/member/login.jhtml">https://login.taobao.com/member/login.jhtml</a> 传回来的参数为：</p><p><img src="/2023/12/23/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/3.jpg" alt="图片"></p><p>然后请求(GET)报文是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://qrlogin.taobao.com/qrcodelogin/qrcodeLoginCheck.do?</span><br><span class="line">lgToken=2c3b4d53ef0513787bf4ce711ea5ba53&amp;defaulturl=&amp;_ksTS=1540106757739_2804&amp;callback=jsonp2805</span><br></pre></td></tr></table></figure><p>关键的就是lgToken，是网页的唯一ID，当打开了二维码登录的时候，网页在轮询(应该是长轮询long polling)调用接口去请求服务器。</p><p>如果扫了的话则会返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: &quot;10001&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;message&quot;: &quot;mobile scan QRCode success&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;success&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长时间没有扫码的话，网页端会停止轮询，二维码失效！</p><p>手机扫描登录成功后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">&quot;code&quot;: &quot;10006&quot;, </span><br><span class="line">&quot;success&quot;: true,</span><br><span class="line"> &quot;url&quot;: &quot;https://login.taobao.com/member/loginByIm.do?uid=cntaobaoxxx&amp;token=ff82fc0d1d395a33d3b38ec5a4981336&amp;time=1530179143250&amp;asker=qrcodelogin&amp;ask_version=1.0.0&amp;defaulturl=https://www.taobao.com&amp;webpas=0b7aed2d43f01825183e4a49c6cae47d1479929926&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示登录成功，当然手机端与服务端在点击”确认登录”之间的交互可能就是这样：网页端生成的lgToken去请求服务端，服务端记住了这个lgToken并认为登录了，当网页端再次轮询请求接口时，就返回真正的登录态Token，网页端此时就可以凭着这个Token来登录了。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础架构</title>
      <link href="/2023/12/10/MySQL/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/12/10/MySQL/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>MySQL分为Server和存储引擎层两部分，其中： Server层包括：连接池、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数字和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等； 存储引擎层负责数据的存储和提取。其架构模式是插件式，支持InnoDB、MyISAM、Memory等多个存储引擎，现在最常用的存储引擎是InnoDB（5.5.5版本后默认存储引擎）。</p><span id="more"></span><p>MySQL的连接器、分析器、优化器和执行器是MySQL的核心组件，它们分别负责不同的功能，如下所述：</p><ol><li>连接器（Connection Manager）：连接器是MySQL的一个独立组件，用于建立与服务器之间的连接，并负责用户身份验证、权限管理和调用其他MySQL模块来完成用户请求。一旦连接成功建立，它就会开始扮演协调器的角色，接收来自客户端的请求，将请求转发到查询分析器进行处理，并将结果返回给客户端。</li><li>分析器（Parser）：查询分析器从连接器接收SQL语句，并验证语法和解析其中的各个部分，如表名、列名、运算符和条件等。如果SQL语句不符合MySQL的语法和标准，则查询分析器将返回错误消息。</li><li>优化器（Optimizer）：查询优化器接收查询分析器的请求，并选择执行查询的最有效计划。优化器将尝试找到最佳的执行方案，以便在查询时最小化资源消耗，同时尽可能快地返回结果。</li><li>执行器（Executor）：查询执行器将执行优化的查询计划，并将结果返回给查询分析器。如果需要检索数据，则执行器将访问存储引擎，以在磁盘上找到数据并将其返回给查询分析器。在这个过程中，执行器还会进行权限检查和事务管理等操作。</li></ol><p>这些组件共同协作，完成了MySQL的核心功能，如语法分析、查询优化、数据管理和权限验证等操作。MySQL的性能和可靠性得益于这个复杂的体系结构，其中每个组件都有自己独特的功能和优点。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>binlog和redolog</title>
      <link href="/2023/12/10/MySQL/binlog%E5%92%8Credolog/"/>
      <url>/2023/12/10/MySQL/binlog%E5%92%8Credolog/</url>
      
        <content type="html"><![CDATA[<p>继续聊一下binlog和redo log。</p><span id="more"></span><h3 id="两阶段提交不同时刻异常重启分析"><a href="#两阶段提交不同时刻异常重启分析" class="headerlink" title="两阶段提交不同时刻异常重启分析"></a><strong>两阶段提交不同时刻异常重启分析</strong></h3><p><img src="/2023/12/10/MySQL/binlog%E5%92%8Credolog/1.png" alt="图片"></p><p>在图中时刻A崩溃crash，此时redo log处于prepare状态，binlog还没有写，redo log也没有提交，所以崩溃恢复时，事务会回滚。由于Binlog也没有写，所以不会传到备库。</p><p>在时刻B崩溃，binlog已经写完，redo log没有commit。根据3.2.3两阶段提交的实现逻辑，这时候B属于redo log已经处于prepare状态，并且binlog完整的情况，因此，事务会提交。</p><p><strong>实际上这就是两阶段提交算法的一种业务使用，如果接受者接受建议失败，则事务失败。</strong></p><h3 id="MySQL如何确认binlog的完整性"><a href="#MySQL如何确认binlog的完整性" class="headerlink" title="MySQL如何确认binlog的完整性"></a><strong>MySQL如何确认binlog的完整性</strong></h3><p>一个事务的binlog是有完整格式：</p><ul><li>statement格式的binlog，最后会有commit;</li><li>row格式的binlog，最后会有一个XID event；</li></ul><p>MySQL5.6.2版本后，引入binlog-checksum参数，验证binlog内容正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog 的完整性的。</p><p>即：checksum用于保证binlog数据的完整性，commit标签、XID event标签保证事务完整性。</p><h3 id="redo-log和binlog的关联"><a href="#redo-log和binlog的关联" class="headerlink" title="redo log和binlog的关联"></a><strong>redo log和binlog的关联</strong></h3><p>redo log和binlog有一个共同的字段XID，崩溃恢复的时候，会按照顺序扫描redo log：</p><ul><li>如果碰到既有prepare又有commit的redo log，直接提交；</li><li>如果碰到只有prepare没有commit的redo log，拿着XID去binlog找对应的事务；</li></ul><h3 id="prepare状态的redo-log-binlog可以实现事务"><a href="#prepare状态的redo-log-binlog可以实现事务" class="headerlink" title="prepare状态的redo log+binlog可以实现事务"></a><strong>prepare状态的redo log+binlog可以实现事务</strong></h3><p>实际上这个说的就是时刻B，这时候由于binlog已经写入，之后就会被从库（或者这个binlog恢复的库）使用。</p><p>为了保证主从的数据一致性，主库也必须提交这个事务。因此说：</p><ul><li>集群正常运行时，要有完成的binlog保证从库的数据一致性，要有commit状态的redo log保证主库的数据一致性；</li><li>发生crash时，有prepare状态的redo log和完整的binlog也能保证主从库的数据一致性；</li></ul><h3 id="是否可以只使用binlog"><a href="#是否可以只使用binlog" class="headerlink" title="是否可以只使用binlog"></a><strong>是否可以只使用binlog</strong></h3><p>如果只使用binlog，过程可能是：数据更新到内存 -&gt; 写binlog -&gt;提交事务</p><p>但是这种方式无法支持事务，因为binlog没有崩溃恢复的能力。binlog由于WAL技术，有些修改是还没有落盘但是事务已经提交，这时候如果crash，重启后根据binlog可能认为这些修改已经落盘，从而导致丢失修改。</p><p><img src="/2023/12/10/MySQL/binlog%E5%92%8Credolog/2.png" alt="图片"></p><p>如图所示，一旦发生crash，那么事务2会回滚，然后应用binlog2可以补回来。但是对于事务1，系统已经提交完成，不会再应用一次binlog1。</p><p>InnoDB使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成。crash之后，依赖日志恢复数据页。即：图中的事务1可能已经丢失，而且是数据页级的丢失，无法找回。</p><h4 id="binlog不具备checkpoint"><a href="#binlog不具备checkpoint" class="headerlink" title="binlog不具备checkpoint"></a><strong>binlog不具备checkpoint</strong></h4><p>从理论上分析就是：InnoDB设计思路是数据写入时，写到内存、redo log和binlog就算是写入成功，内存中的数据是否落盘主要看redo log有没有日志数据，只要redo log日志数据没有被checkpoint擦除，就代表数据还在内存中，crash恢复时，就会把redo log的数据先恢复到内存的数据页中，执行一次重放就可以恢复数据了。当然也存在说，可能落盘的redo log也还没有被checkpoint擦除，但是这种场景，可以通过redo log的LSN和数据页的LSN对比判定，如果相同，就会跳过这个checkpoint进行下一个数据页的恢复。</p><p>而binlog是追加写，既有落盘数据，也有未落盘的数据，因此，crash恢复时无法确定是从哪个点开始的数据已经刷盘，如果binlog也有checkpoint机制，好像就可以做数据补偿，但是这不就是redo log吗？</p><p>如果优化Binlog实现记录数据页的修改，那就是实现了另一个redo log。</p><p>因此说，Binlog不具备恢复“数据页”的能力，无法支持崩溃恢复。</p><h4 id="binlog的粒度问题"><a href="#binlog的粒度问题" class="headerlink" title="binlog的粒度问题"></a><strong>binlog的粒度问题</strong></h4><p>首先要清晰的是，数据的落盘是以page为最小单位，redo log记录的维度就是page。对于binlog，是以单条执行语句为维度进行记录。</p><p>redo log与Page直接相关，语句大体含义为“page#11, table, a,old value 1,new value 5”,这种物理日志执行重放，a的值不会有问题。</p><p>binlog是逻辑日志，包含的是多个page甚至是所有page的修改，以文中作者的示例：</p><ul><li>一个事务更新了page ABC</li><li>然后崩溃回复了，B坏了，AC没问题，而且AC还落盘了。</li><li>这样如果重做事务，B好了，AC又坏了</li></ul><p>详细解释就是：比如一个事务更新了page ABC，崩溃了之后，B坏了，AC没问题，而且AC还落盘了，这时候如果用redo log恢复，只用单独恢复B这个数据页，就保证了ABC 3个数据页都正常，而binlog并不具备恢复单个数据页的能力，所以如果用binlog恢复，会同时恢复ABC三个数据页的内容，而AC数据页本来内容已经是对的，这样恢复后反而就坏了。（比如原先对AC是新增操作，那等于又对正确数据错误的新增了）</p><h4 id="row级别的binlog是否可以"><a href="#row级别的binlog是否可以" class="headerlink" title="row级别的binlog是否可以"></a><strong>row级别的binlog是否可以</strong></h4><p>那是不是开启row格式binlog也可以实现这样的操作？答案是依旧不可以。</p><p>row格式的binlog记录的数据的前后项的变化，从一个值变成了另一个值，是操作的逻辑日志，类似于SQL语句。这里说的损坏是page的损坏，通过逻辑日志是无法恢复page的。redo log记录的是page的物理修改，操作是幂等的，因此page损坏时，通过redo log可以恢复这个损坏的page。</p><h3 id="是否可以只用redo-log"><a href="#是否可以只用redo-log" class="headerlink" title="是否可以只用redo log"></a><strong>是否可以只用redo log</strong></h3><p>单单使用redo log可以实现crash-safe，但是binlog对于MySQL还有如下用途：</p><ul><li>归档：redo log是循环写，写到末尾就回到开头继续写，这样历史日志无法保留，无法实现归档的能力；</li><li>MySQL系统依赖binlog：MySQL的高可用等能力，就是依赖了binlog的复制能力；</li><li>数据异构同步：很多公司通过消费binlog实现从MySQL到hive的备份，比如说阿里的canal就是消费binlog给应用通知.</li></ul><h3 id="redo-log与最终数据落盘"><a href="#redo-log与最终数据落盘" class="headerlink" title="redo log与最终数据落盘"></a><strong>redo log与最终数据落盘</strong></h3><p>redo log没有记录数据页完整数据，因此，没有能力自己去更新磁盘数据。</p><p>如果是正常运行实例，数据页被修改后，跟磁盘的数据页不一致，成为脏页。最终的数据落盘就是将内存中的数据页写盘，这个过程与redo log无关。</p><p>在崩溃恢复场景，InnoDB判断一个数据也可能在崩溃恢复时丢失了更新，就会将它读到内存，然后让redo log更新内存内容，这是因为redo log记录的是“在某个数据页执行了什么修改”，而不是“这个数据修改前后的值是什么”，因此，需要先把磁盘的数据读入内存在执行redo log操作的回放。更新完成后，内存页变为脏页，回到了上面的状态。</p><p>因此，我们说，只有在崩溃恢复时，redo log才会参与数据落盘过程中。</p><h3 id="redo-log先写内存还是先写文件"><a href="#redo-log先写内存还是先写文件" class="headerlink" title="redo log先写内存还是先写文件"></a><strong>redo log先写内存还是先写文件</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>在开启事务后执行数据插入，此时，会更新内存中的数据，并将执行语句写入redo log buffer中（标记为prepare状态），只有当执行commit语句时才会<strong>主动</strong>将日志刷盘写入redo log file（文件名为：ib_logfile+数字），以减少不必要的IO消耗。然后写binlog，再将redo log标记为commited。</p><p>但是上文也说了是主动，既然有主动，那自然也就有被动。由于redo log buffer是所有线程共用的，别的线程提交也会向buffer中提交日志。redo log并不保证事务的顺序性，当redo log写满了以及后台的每秒自动刷盘、其他事务的提交都会将redo log刷盘，因此，redo log不会阻塞其他的事务写。</p><p>但是，binlog虽然采用的是组提交（并发写入），但是binlog必须需要保证事务的顺序性，所以大事务提交 binlog写会阻塞后续的所有提交。</p><p>因此说，大事务一方面会导致事务的所有日志全部在redo log buffer中（非主动提交场景），同时binlog还要阻塞后续的所有事务，因此，要尽可能的避免大事务的出现。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL两阶段提交</title>
      <link href="/2023/12/09/MySQL/MySQL%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
      <url>/2023/12/09/MySQL/MySQL%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>MySQL两阶段的提交主要就是为了binlog和redo log两份日志之间的逻辑一致。如果要保证可以恢复到某一秒数据，则备份系统中一定会保存最近半个月或者更久的所有binlog。系统也会定期做整库备份，根据重要性决定一天一备还是一周一备。</p><span id="more"></span><h3 id="两阶段提交的逻辑"><a href="#两阶段提交的逻辑" class="headerlink" title="两阶段提交的逻辑"></a>两阶段提交的逻辑</h3><ul><li>首先找到最近的一次全量备份，从这个备份恢复到临时库；</li><li>从备份的时间点开始，将备份的binlog依次取出来，重放在需要重放的时间的时刻；</li><li>此时的临时库与误删前的库一致，可以把表数据从临时库取出来，按需要恢复到线上库；</li></ul><p><img src="/2023/12/09/MySQL/MySQL%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/1.jpg" alt="图片"></p><h3 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a><strong>为什么需要两阶段提交</strong></h3><p>假设当前ID&#x3D;2 的行，字段c的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><p><img src="/2023/12/09/MySQL/MySQL%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/2.png" alt="图片"></p><h4 id="先写redo-log后写binlog"><a href="#先写redo-log后写binlog" class="headerlink" title="先写redo log后写binlog"></a><strong>先写redo log后写binlog</strong></h4><p>假设在redo log写完，binlog还没写完时，MySQL进程异常重启。</p><p>此时，因为redo log已经写完，可以将数据恢复，恢复后c&#x3D;1；但是由于binlog没写完，binlog没有记录这个语句，因此，之后备份日志的时候，存起来的binlog没有这条数据，之后备份时候存起来的binlog也没有这条语句。</p><p>如果使用此时的binlog恢复临时库，则该条更新语句丢失，此时c&#x3D;0。</p><p>总结一下就是：<strong>先写redo log后写binlog，在写完redo log后，写binlog时发生crash，数据库恢复后，数据没有丢失，因为能够通过redo log恢复回来，但是这个操作少了binlog。而在进行数据库备份的时候使用的是binlog，所以备份的数据里面就丢失了这次更改，以后在使用这个备份恢复的时候，恢复回来的数据有数据丢失。</strong></p><h4 id="先写binlog后写redo-log"><a href="#先写binlog后写redo-log" class="headerlink" title="先写binlog后写redo log"></a><strong>先写binlog后写redo log</strong></h4><p>如果binlog写完crash，由于redo log没有写入，在事务恢复的时候需要结合两份日志，两份日志通过xid关联，通过xid找不到redo log中对应的日志，无法恢复事务，因此崩溃恢复后这个事务无效，所以c&#x3D;0；但是binlog已经记录了“把c从0改为1”这个日志。所以，在之后使用Binlog恢复就多了一个事务，恢复出来的数据c&#x3D;1；</p><h3 id="两阶段重要性"><a href="#两阶段重要性" class="headerlink" title="两阶段重要性"></a>两阶段重要性</h3><p>如果不使用两阶段提交，那么数据库的状态就可能和用它的日志恢复出来的库状态不一致。</p><p>不只是在误操作恢复数据，当需要扩容时，现在常见的做法也是用全量备份加上应用binlog来实现，这个不一致也会导致线上出现主从数据库不一致的情况。</p><p>redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h3 id="两阶段提交的实现"><a href="#两阶段提交的实现" class="headerlink" title="两阶段提交的实现"></a><strong>两阶段提交的实现</strong></h3><p>两阶段提交是指对redo log进行两阶段提交，先prepare，再Commit。数据库crash重启后，会对redo log进行check：</p><ul><li><p>如果redo log已经commit（事务是完整的），则视为有效，直接提交；</p></li><li><p>如果redo log处于prepare但是没有commit，则check对应的binlog记录是否记录成功；</p></li><li><ul><li>binlog记录成功，则将该prepare状态的redo log视为有效，直接提交；</li><li>binlog记录不成功，则将该prepare状态的redo log视为无效，回滚事务；</li></ul></li></ul><p>两阶段提交主要就是为了保证两份日志文件的逻辑一致性，这样用日志恢复的准备库就是一模一样的。</p><p>换句话说，在恢复数据时，redo log用于恢复主机故障时的未更新的物理数据，binlog用于备份操作。每个阶段的log操作都是记录在磁盘的，在恢复数据时，redo log状态为commit则说明binlog也成功，直接恢复数据；如果redo log是prepare，则需要查询对应的binlog事务是否成功，决定是回滚还是执行。即：<strong>只要binlog已经提交，事务就必须提交，因为写入binlog，就代表着可能已经同步到从库。</strong></p><h4 id="commit实现"><a href="#commit实现" class="headerlink" title="commit实现"></a><strong>commit实现</strong></h4><p>如果一个事务中有多条SQL语句，实际上还是只会执行一次commit操作。</p><p>从binlog内容可以看出，binlog在statement格式时，内容也是一个begin…commit，多条语句可以看为一个整体，执行过程中就写入binlog cache，然后在执行commit语句时触发两阶段提交，假如redo log处于prepare状态（也会刷盘到磁盘），将binlog cache刷盘到磁盘，最后二阶段提交的commit步骤再将redo log改为commit状态。</p><h4 id="优化的Basic-Paxos算法"><a href="#优化的Basic-Paxos算法" class="headerlink" title="优化的Basic Paxos算法"></a><strong>优化的Basic Paxos算法</strong></h4><p>这里的提议者只有一个（可以认为是主节点），也就是redo log，redo log发起prepare请求，binlog收到请求后，将日志写入后，表示接受事务的提议，这时候redo log直接做commit操作，表示事务完成。</p><p>如果Binlog返回异常，或者当前还没有准备好，比如binlog脏页过多，需要先刷盘等等，等到binlog准备好后再执行。如果执行失败，则表示事务失败，执行回滚。</p><h4 id="两阶段提交不同时刻异常重启分析"><a href="#两阶段提交不同时刻异常重启分析" class="headerlink" title="两阶段提交不同时刻异常重启分析"></a><strong>两阶段提交不同时刻异常重启分析</strong></h4><p>在图中时刻A崩溃crash，此时redo log处于prepare状态，binlog还没有写，redo log也没有提交，所以崩溃恢复时，事务会回滚。由于Binlog也没有写，所以不会传到备库。</p><p>在时刻B崩溃，binlog已经写完，redo log没有commit。根据3.2.3两阶段提交的实现逻辑，这时候B属于redo log已经处于prepare状态，并且binlog完整的情况，因此，事务会提交。</p><h4 id="两阶段提交作用"><a href="#两阶段提交作用" class="headerlink" title="两阶段提交作用"></a><strong>两阶段提交作用</strong></h4><p>两阶段提交可以看成是两个分布式服务，redo log在InnoDB引擎内操作，binlog在server层操作，并且这两个操作属于相关联操作，需要实现分布式事务，两阶段提交就是其中的一种解决方案，在必要性上，可以说主要是为了事务持久性。</p><p>对于InnoDB，如果redo log提交完成事务就不能回滚（如果还允许回滚，就可能覆盖掉别的事务的更新）。如果redo log直接提交，然后binlog写入失败，InnoDB无法回滚，就会导致数据和日志不一致。即：两阶段提交是为了在binlog写入失败时还允许redo log回滚。</p><p><strong>为什么不能用处于prepare的redo log来补全binlog？</strong></p><p>这里有两个原因：</p><ol><li>redo log在异常情况下也可能会丢失（redo log buffer内数据没刷盘前宕机）；</li><li>MySQL可以更换引擎，如果MySQL更改代码以实现redo log补全binlog，那么就与InnoDB的耦合性太高了；</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志</title>
      <link href="/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>MySQL中有六种日志文件，分别是：<code>重做日志</code>（redo log）、<code>回滚日志</code>（undo log）、<code>二进制日志</code>（binlog）、<code>错误日志</code>（errorlog）、<code>慢查询日志</code>（slow query log）、<code>一般查询日志</code>（general log），<code>中继日志</code>（relay log）。</p><span id="more"></span><p>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。</p><h3 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3><p><strong>作用：</strong></p><ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li></ul><p><strong>内容：</strong></p><ul><li>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</li></ul><p><strong>什么时候产生：</strong></p><ul><li>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</li></ul><p><strong>什么时候释放：</strong></p><ul><li>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</li></ul><p><strong>对应的物理文件：</strong></p><ul><li>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2</li><li>innodb_log_group_home_dir 指定日志文件组所在的路径，默认.&#x2F; ，表示在数据库的数据目录下。</li><li>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</li></ul><p>关于文件的大小和数量，由一下两个参数配置</p><ul><li>innodb_log_file_size 重做日志文件的大小。</li><li>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</li></ul><p><strong>其他：</strong></p><ul><li>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</li><li>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</li></ul><p><img src="/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/1.png" alt="图片"></p><p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘</p><ul><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li><li>每个事务提交时会将重做日志刷新到重做日志文件。</li><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li></ul><p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p><h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><p><strong>作用：</strong></p><ul><li>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li></ul><p><strong>内容：</strong></p><ul><li>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</li></ul><p><strong>什么时候产生：</strong></p><ul><li>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</li></ul><p><strong>什么时候释放：</strong></p><ul><li>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</li></ul><p>对应的物理文件：MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</p><p>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数，如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p><p>关于MySQL5.7之后的独立undo 表空间配置参数如下</p><ul><li>innodb_undo_directory &#x3D; &#x2F;data&#x2F;undospace&#x2F; –undo独立表空间的存放目录</li><li>innodb_undo_logs &#x3D; 128 –回滚段为128KB</li><li>innodb_undo_tablespaces &#x3D; 4 –指定有4个undo log文件</li></ul><p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p><p><img src="/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/2.png" alt="图片"></p><p><strong>其他：</strong></p><ul><li>undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。</li><li>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</li><li>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</li><li>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</li></ul><h3 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h3><p><strong>作用：</strong></p><ul><li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li><li>用于数据库的基于时间点的还原。</li></ul><p><strong>内容：</strong></p><ul><li>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</li><li>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，</li><li>也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</li><li>在使用mysqlbinlog解析binlog之后一些都会真相大白。</li><li>因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</li></ul><p><strong>什么时候产生：</strong></p><ul><li>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</li><li>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</li><li>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</li><li>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</li></ul><p><strong>什么时候释放：</strong></p><ul><li>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</li></ul><p><img src="/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/3.png" alt="图片"></p><p>对应的物理文件：</p><ul><li>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</li><li>对于每个binlog日志文件，通过一个统一的index文件来组织。</li></ul><p><img src="/2023/12/05/MySQL/MySQL%E6%97%A5%E5%BF%97/4.png" alt="图片"></p><p><strong>其他：</strong></p><p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p><ul><li>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li><li>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</li><li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</li><li>恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li></ul><p>关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> MySQL日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幂等实现方案</title>
      <link href="/2023/12/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E5%B9%82%E7%AD%89/"/>
      <url>/2023/12/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。 例如： </p><ol><li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。 </li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li><li>发送消息，也应该只发一次； </li><li>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。</li></ol><span id="more"></span><h3 id="幂等性概念"><a href="#幂等性概念" class="headerlink" title="幂等性概念"></a>幂等性概念</h3><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 </p><p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数. </p><p>简单理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的 。</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ol><li><p>查询操作 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作 。</p></li><li><p>删除操作 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) 。</p></li><li><p>唯一索引，防止新增脏数据。</p></li></ol><p>要点： 唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。</p><ol start="4"><li>token机制，防止页面重复提交 。</li></ol><p>处理流程： 1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间 。</p><p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用。 </p><ol start="5"><li>悲观锁 获取数据的时候加锁获取 select * from table_xxx where id&#x3D;’xxx’ for update;</li></ol><p> 注意：id字段一定是主键或者唯一索引，不然是锁表， 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用 。</p><ol start="6"><li>乐观锁 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</li></ol><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p><p>（1）. 通过版本号实现 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> name<span class="operator">=</span>#name#,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> version<span class="operator">=</span>#version# </span><br></pre></td></tr></table></figure><p>（2）通过条件限制 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> avaiamount<span class="operator">=</span>avaiamount<span class="operator">-</span>#subAmount# <span class="keyword">where</span> avaiamount<span class="operator">-</span>#subAmount# <span class="operator">&gt;=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p> 要求：quality-#subQuality# &gt;&#x3D; ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高 。</p><p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tablexxx <span class="keyword">set</span> name<span class="operator">=</span>#name#,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span>#id# <span class="keyword">and</span> version<span class="operator">=</span>#version# </span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tablexxx <span class="keyword">set</span> avaiamount<span class="operator">=</span>avaiamount<span class="operator">-</span>#subAmount# <span class="keyword">where</span> id<span class="operator">=</span>#id# <span class="keyword">and</span> avai_amount<span class="operator">-</span>#subAmount# <span class="operator">&gt;=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><ol start="7"><li>分布式锁 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</li></ol><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供) </p><ol start="8"><li><p>select + insert 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了; 注意：核心高并发流程不要用这种方法</p></li><li><p>状态机幂等 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p></li></ol><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。 </p><ol start="10"><li>对外提供接口的api如何保证幂等 如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</li></ol><p><strong>重点</strong>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。 </p>]]></content>
      
      
      <categories>
          
          <category> 高性能并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口设计 </tag>
            
            <tag> 幂等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot接口加密解密</title>
      <link href="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h3><p>在我们日常的Java开发中，免不了和其他系统的业务交互，或者微服务之间的接口调用，如果我们想保证数据传输的安全，就需要对接口出参加密，入参解密。但是不想写重复代码，我们可以提供一个通用starter，提供通用加密解密功能。</p><span id="more"></span><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="hutool-crypto加密解密工具"><a href="#hutool-crypto加密解密工具" class="headerlink" title="hutool-crypto加密解密工具"></a>hutool-crypto加密解密工具</h4><p>hutool-crypto提供了很多加密解密工具，包括对称加密，非对称加密，摘要加密等等。</p><h4 id="request流只能读取一次的问题"><a href="#request流只能读取一次的问题" class="headerlink" title="request流只能读取一次的问题"></a>request流只能读取一次的问题</h4><p>在接口调用链中，request的请求流只能调用一次，处理之后，如果之后还需要用到请求流获取数据，就会发现数据为空。比如使用了filter或者aop在接口处理之前，获取了request中的数据，对参数进行了校验，那么之后就不能在获取request请求流了。</p><p>解决办法：继承HttpServletRequestWrapper，将请求中的流copy一份，复写getInputStream和getReader方法供外部使用。每次调用后的getInputStream方法都是从复制出来的二进制数组中进行获取，这个二进制数组在对象存在期间一致存在。使用Filter过滤器，在一开始，替换request为自己定义的可以多次读取流的request。</p><p>这样就实现了流的重复获取InputStreamHttpServletRequestWrapper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ReadListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求流支持多次获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于缓存输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream cachedBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;    </span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedBytes == <span class="literal">null</span>) &#123;   </span><br><span class="line">            <span class="comment">// 首次获取流时，将流放入 缓存输入流 中</span></span><br><span class="line">            cacheInputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 缓存输入流 中获取流并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CachedServletInputStream</span>(cachedBytes.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首次获取流时，将流放入 缓存输入流 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 缓存输入流以便多次读取。为了方便, 我使用 org.apache.commons IOUtils</span></span><br><span class="line">        cachedBytes = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        IOUtils.copy(<span class="built_in">super</span>.getInputStream(), cachedBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存的请求正文的输入流</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 用于根据 缓存输入流 创建一个可返回的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CachedServletInputStream</span> <span class="keyword">extends</span> <span class="title class_">ServletInputStream</span> &#123;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteArrayInputStream input;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CachedServletInputStream</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存的请求正文创建一个新的输入流</span></span><br><span class="line">            input = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServletRequestInputStreamFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> xyz.hlh.cryptotest.utils.InputStreamHttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.core.Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HLH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> *      请求流转换为多次读取的请求流 过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> 17703595860@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : Created in 2022/2/4 9:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(HIGHEST_PRECEDENCE + 1)</span>  <span class="comment">// 优先级最高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletRequestInputStreamFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   </span><br><span class="line">             <span class="comment">// 转换为可以多次获取流的request</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">InputStreamHttpServletRequestWrapper</span> <span class="variable">inputStreamHttpServletRequestWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamHttpServletRequestWrapper</span>(httpServletRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        chain.doFilter(inputStreamHttpServletRequestWrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringBoot的参数校验validation"><a href="#SpringBoot的参数校验validation" class="headerlink" title="SpringBoot的参数校验validation"></a>SpringBoot的参数校验validation</h4><p>SpringBoot-validation提供了优雅的参数校验，入参都是实体类，在实体类字段上加上对应注解，就可以在进入方法之前，进行参数校验，如果参数错误，会抛出错误BindException，是不会进入方法的。这种方法，必须要求在接口参数上加注解@Validated或者是@Valid</p><p>但是很多情况下，我们希望在代码中调用某个实体类的校验功能，所以需要如下工具类：</p><p>ParamException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义参数异常</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; fieldList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; msgList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamException</span><span class="params">(List&lt;String&gt; fieldList, List&lt;String&gt; msgList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fieldList = fieldList;</span><br><span class="line">        <span class="built_in">this</span>.msgList = msgList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValidationUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationUtils</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Validator</span> <span class="variable">VALIDATOR</span> <span class="operator">=</span> Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object object)</span> <span class="keyword">throws</span> CustomizeException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validate(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证结果异常</span></span><br><span class="line">        throwParamException(validate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证数据(分组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groups 所在组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object object, Class&lt;?&gt; ... groups)</span> <span class="keyword">throws</span> CustomizeException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validate(object, groups);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证结果异常</span></span><br><span class="line">        throwParamException(validate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证数据中的某个字段(分组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyName 字段名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object object, String propertyName)</span> <span class="keyword">throws</span> CustomizeException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validateProperty(object, propertyName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证结果异常</span></span><br><span class="line">        throwParamException(validate);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证数据中的某个字段(分组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyName 字段名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groups 所在组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object object, String propertyName, Class&lt;?&gt; ... groups)</span> <span class="keyword">throws</span> CustomizeException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validateProperty(object, propertyName, groups);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证结果异常</span></span><br><span class="line">        throwParamException(validate);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证结果异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> validate 验证结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwParamException</span><span class="params">(Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate)</span> <span class="keyword">throws</span> CustomizeException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (validate.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            List&lt;String&gt; fieldList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; msgList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstraintViolation&lt;Object&gt; next : validate) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                fieldList.add(next.getPropertyPath().toString());</span><br><span class="line">                msgList.add(next.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(fieldList, msgList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h4><p>自定义starter步骤</p><ul><li>创建工厂，编写功能代码</li><li>声明自动配置类，把需要对外提供的对象创建好，通过配置类统一向外暴露</li><li>在resource目录下准备一个名为spring&#x2F;spring.factories的文件，以org.springframework.boot.autoconfigure.EnableAutoConfiguration为key，自动配置类为value列表，进行注册。</li></ul><h4 id="RequestBodyAdvice和ResponseBodyAdvice"><a href="#RequestBodyAdvice和ResponseBodyAdvice" class="headerlink" title="RequestBodyAdvice和ResponseBodyAdvice"></a>RequestBodyAdvice和ResponseBodyAdvice</h4><p><strong>1、</strong> RequestBodyAdvice是对请求的json串进行处理，一般使用场景是处理接口参数的自动解密；<br><strong>2、</strong> ResponseBodyAdvice是对请求相应的jsoin传进行处理，一般用于相应结果的加密；</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p><strong>1、</strong> 接口响应数据的时候，返回的是加密之后的数据；<br><strong>2、</strong> 接口入参的时候，接收的是解密之后的数据，但是在进入接口之前，会自动解密，取得对应的数据；</p><h4 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h4><p><strong>1、</strong> 加密解密使用对称加密的AES算法，使用hutool-crypto模块进行实现；<br><strong>2、</strong> 所有的实体类提取一个公共父类，包含属性时间戳，用于加密数据返回之后的实效性，如果超过60分钟，那么其他接口将不进行处理；<br><strong>3、</strong> 如果接口加了加密注解<code>EncryptionAnnotation</code>，并且返回统一的json数据<code>Result</code>类，则自动对数据进行加密如果是继承了统一父类<code>RequestBase</code>的数据，自动注入时间戳，确保数据的时效性；<br><strong>4、</strong> 如果接口加了解密注解<code>DecryptionAnnotation</code>，并且参数使用RequestBody注解标注，传入json使用统一格式<code>RequestData</code>类，并且内容是继承了包含时间长的父类<code>RequestBase</code>，则自动解密，并且转为对应的数据类型；<br><strong>5、</strong> 功能提供Springboot的starter，实现开箱即用；</p><p>代码：<a href="https://gitee.com/xiangger/web-test/tree/spring-web-crypto">web-test: web开发 - Gitee.com</a></p><p><img src="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/1.png" alt="image-20231204220121602"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求流支持多次获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于缓存输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream cachedBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首次获取流时，将流放入 缓存输入流 中</span></span><br><span class="line">            cacheInputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 缓存输入流 中获取流并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CachedServletInputStream</span>(cachedBytes.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首次获取流时，将流放入 缓存输入流 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 缓存输入流以便多次读取。为了方便, 我使用 org.apache.commons IOUtils</span></span><br><span class="line">        cachedBytes = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        IOUtils.copy(<span class="built_in">super</span>.getInputStream(), cachedBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存的请求正文的输入流</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 用于根据 缓存输入流 创建一个可返回的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CachedServletInputStream</span> <span class="keyword">extends</span> <span class="title class_">ServletInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteArrayInputStream input;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CachedServletInputStream</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存的请求正文创建一个新的输入流</span></span><br><span class="line">            input = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE + 1)</span>  <span class="comment">// 优先级最高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletRequestInputStreamFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 转换为可以多次获取流的request</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">InputStreamHttpServletRequestWrapper</span> <span class="variable">inputStreamHttpServletRequestWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamHttpServletRequestWrapper</span>(httpServletRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        chain.doFilter(inputStreamHttpServletRequestWrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/2.png" alt="image-20231204220121602"></p><p>请求参数解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: requestBody 自动解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecryptRequestBodyAdvice</span> <span class="keyword">implements</span> <span class="title class_">RequestBodyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法上有DecryptionAnnotation注解的，进入此拦截器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter 方法参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      参数的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   消息转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true，进入，false，跳过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> methodParameter.hasMethodAnnotation(DecryptionAnnotation.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HttpInputMessage <span class="title function_">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换之后，执行此方法，解密，赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body          spring解析完的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage  输入参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter     参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType    参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType 消息转换类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 真实的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取request</span></span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">servletRequestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) requestAttributes;</span><br><span class="line">        <span class="keyword">if</span> (servletRequestAttributes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(<span class="string">&quot;request错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> servletRequestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">ServletInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        <span class="type">RequestData</span> <span class="variable">requestData</span> <span class="operator">=</span> objectMapper.readValue(inputStream, RequestData.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestData == <span class="literal">null</span> || StringUtils.isBlank(requestData.getText())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取加密的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> requestData.getText();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入解密之前的数据</span></span><br><span class="line">        request.setAttribute(CryptoConstant.INPUT_ORIGINAL_DATA, text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decryptText</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decryptText = AESUtil.decrypt(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(<span class="string">&quot;解密失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(decryptText)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(<span class="string">&quot;解密失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入解密之后的数据</span></span><br><span class="line">        request.setAttribute(CryptoConstant.INPUT_DECRYPT_DATA, decryptText);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> objectMapper.readValue(decryptText, body.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制所有实体类必须继承RequestBase类，设置时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> RequestBase) &#123;</span><br><span class="line">            <span class="comment">// 获取时间戳</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> ((RequestBase) result).getCurrentTimeMillis();</span><br><span class="line">            <span class="comment">// 有效期 60秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">effective</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 时间差</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> System.currentTimeMillis() - currentTimeMillis;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否在有效期内</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(expire) &gt; effective) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(<span class="string">&quot;时间戳不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回解密之后的数据</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamException</span>(String.format(<span class="string">&quot;请求参数类型：%s 未继承：%s&quot;</span>, result.getClass().getName(), RequestBase.class.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果body为空，转为空对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body          spring解析完的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage  输入参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter     参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType    参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType 消息转换类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 真实的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">handleEmptyBody</span><span class="params">(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> targetType.getTypeName();</span><br><span class="line">        Class&lt;?&gt; bodyClass = Class.forName(typeName);</span><br><span class="line">        <span class="keyword">return</span> bodyClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应自动加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: responseBody自动解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptResponseBodyAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Result&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="type">ParameterizedTypeImpl</span> <span class="variable">genericParameterType</span> <span class="operator">=</span> (ParameterizedTypeImpl) returnType.getGenericParameterType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果直接是Result并且有解密注解，则处理</span></span><br><span class="line">        <span class="keyword">if</span> (genericParameterType.getRawType() == Result.class &amp;&amp; returnType.hasMethodAnnotation(EncryptionAnnotation.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是ResponseBody或者是Result，则放行</span></span><br><span class="line">        <span class="keyword">if</span> (genericParameterType.getRawType() != ResponseEntity.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是ResponseEntity&lt;Result&gt;并且有解密注解，则处理</span></span><br><span class="line">        <span class="keyword">for</span> (Type type : genericParameterType.getActualTypeArguments()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((ParameterizedTypeImpl) type).getRawType() == Result.class &amp;&amp; returnType.hasMethodAnnotation(EncryptionAnnotation.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; beforeBodyWrite(Result&lt;?&gt; body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? <span class="keyword">extends</span> <span class="title class_">HttpMessageConverter</span>&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真实数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> body.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果data为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是实体，并且继承了Request，则放入时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> RequestBase) &#123;</span><br><span class="line">            ((RequestBase) data).setCurrentTimeMillis(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataText</span> <span class="operator">=</span> JSONUtil.toJsonStr(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果data为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(dataText)) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果位数小于16，报错</span></span><br><span class="line">        <span class="keyword">if</span> (dataText.length() &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CryptoException</span>(<span class="string">&quot;加密失败，数据小于16位&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptText</span> <span class="operator">=</span> AESUtil.encryptHex(dataText);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.builder()</span><br><span class="line">                .status(body.getStatus())</span><br><span class="line">                .data(encryptText)</span><br><span class="line">                .message(body.getMessage())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AESUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AES aes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AES iocAes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAes</span><span class="params">()</span> &#123;</span><br><span class="line">        AESUtil.aes = <span class="built_in">this</span>.iocAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AES <span class="title function_">getAes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHex</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.encryptHex(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHex</span><span class="params">(InputStream data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.encryptHex(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHex</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.encryptHex(data, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.decryptStr(data, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(InputStream data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.decryptStr(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aes.decryptStr(data, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/3.png" alt="image-20231204220121602"></p><p>请求测试controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> <span class="keyword">implements</span> <span class="title class_">ResultBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接返回对象，不加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> teacher Teacher对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 不加密的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&lt;?&gt;&gt; get(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Teacher teacher) &#123;</span><br><span class="line">        <span class="keyword">return</span> success(teacher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回加密后的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> teacher Teacher对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回加密后的数据 ResponseBody&lt;Result&gt;格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/encrypt&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptionAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&lt;?&gt;&gt; encrypt(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Teacher teacher) &#123;</span><br><span class="line">        <span class="keyword">return</span> success(teacher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回加密后的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> teacher Teacher对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回加密后的数据 Result格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/encrypt1&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptionAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; encrypt1(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Teacher teacher) &#123;</span><br><span class="line">        <span class="keyword">return</span> success(teacher).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回解密后的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> teacher Teacher对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回解密后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/decrypt&quot;)</span></span><br><span class="line">    <span class="meta">@DecryptionAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&lt;?&gt;&gt; decrypt(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Teacher teacher) &#123;</span><br><span class="line">        <span class="keyword">return</span> success(teacher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/4.png" alt="image-20231204220121602"></p><p><img src="/2023/12/03/SpringBoot/SpringBoot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/5.png" alt="image-20231204220121602"></p><p>参考转载：<a href="https://mp.weixin.qq.com/s/F4RrC11uJrvbRugTnlbqKw">https://mp.weixin.qq.com/s/F4RrC11uJrvbRugTnlbqKw</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口设计 </tag>
            
            <tag> 加解密 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2023/12/03/Spring/Spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/12/03/Spring/Spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>事务其实是一个并发控制单位，是用户定义的一个操作序列，这些操作要么全部完成，要不全部不完成，是一个不可分割的工作单位。事务有 ACID 四个特性，即：</p><span id="more"></span><ol><li>Atomicity（原子性）：事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。</li><li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li><li>事务隔离（Isolation）：多个事务之间是独立的，不相互影响的。</li><li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ol><p>而我们说的 Spring 事务，其实是事务在 Spring 中的实现。</p><p><img src="/2023/12/03/Spring/Spring%E4%BA%8B%E5%8A%A1/1.jpg" alt="图片"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>我们举个简单的例子：银行里树哥要给小黑转 1000 块钱，这时候会有两个必要的操作：</p><ol><li>将树哥的账户余额减少 1000 元。</li><li>将小黑的账户余额增加 1000 元。</li></ol><p>这两个操作，要么一起都完成，要么都不完成。如果其中某个成功，另外一个失败，那么就会出现严重的问题。<strong>而我们要保证这个操作的原子性，就必须通过 Spring 事务来完成，这就是 Spring 事务存在的原因。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL 默认情况下，对于所有的单条语句都作为一个单独的事务来执行。我们要使用 MySQL 事务的时候，可以通过手动提交事务来控制事务范围。Spring 事务的本质，其实就是通过 Spring AOP 切面技术，在合适的地方开启事务，接着在合适的地方提交事务或回滚事务，从而实现了业务编程层面的事务操作。</span><br></pre></td></tr></table></figure><h4 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h4><p>Spring 事务支持两种使用方式，分别是：声明式事务（注解方式）、编程式事务（代码方式）。</p><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>创建 tablea 和 tableb 两张表，两张表都只有 id 和 name 两列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tablea` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(45) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1;</span><br><span class="line">CREATE TABLE `tableb` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(45) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1;</span><br></pre></td></tr></table></figure><p>创建一个 SpringBoot 项目，随后加入 MyBatis 及 MySQL 的 POM 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建controller、service、entity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTransactionController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionServiceA transactionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/spring-transaction&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        transactionService.methodA();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TableMapper tableMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTableA</span><span class="params">(TableEntity tableEntity)</span> &#123;</span><br><span class="line">        tableMapper.insertTableA(tableEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTableB</span><span class="params">(TableEntity tableEntity)</span> &#123;</span><br><span class="line">        tableMapper.insertTableB(tableEntity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TableService tableService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionServiceB transactionServiceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">        tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add A&quot;</span>));</span><br><span class="line">        transactionServiceB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TableService tableService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB&quot;</span>);</span><br><span class="line">        tableService.insertTableB(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add B&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO tablea(id, name) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;VALUES(#&#123;id&#125;, #&#123;name&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertTableA</span><span class="params">(TableEntity tableEntity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO tableb(id, name) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;VALUES(#&#123;id&#125;, #&#123;name&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertTableB</span><span class="params">(TableEntity tableEntity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TableEntity</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TableEntity</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * web启动类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WebApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicaiton.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111111</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># MyBatis 配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.dx.web.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h5><p>使用声明式事务的方法很简单，其实就是在 Service 层对应方法上配置 <code>@Transaction</code> 注解即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void methodA() &#123;</span><br><span class="line">    System.out.println(&quot;methodA&quot;);</span><br><span class="line">    tableService.insertTableA(new TableEntity(&quot;add A&quot;));</span><br><span class="line">    transactionServiceB.methodB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void methodB() &#123;</span><br><span class="line">    System.out.println(&quot;methodB&quot;);</span><br><span class="line">    int i = 1 / 0;</span><br><span class="line">    tableService.insertTableB(new TableEntity(&quot;add B&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们查看数据库，会发现 tablea 和 tableb 都没有插入数据。这说明事务起作用了。</p><h5 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h5><p>Spring提供两种编程式事务管理方法：</p><ol><li>使用TransactionTemplate 或 TransactionalOperator</li><li>直接创建TransactionManager的实现</li></ol><p>Spring官方推荐使用TransactionTemplate方式</p><p><strong>有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">doInTransaction</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">        tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add A&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">        tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事务回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"> <span class="keyword">return</span> transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;TableEntity&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> TableEntity <span class="title function_">doInTransaction</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> tableMapper.selectById(<span class="number">1</span>) ;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         status.setRollbackOnly() ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure><p>配置事务属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate ;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.transactionTemplate = <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager) ;</span><br><span class="line">  <span class="built_in">this</span>.transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED);</span><br><span class="line">  <span class="built_in">this</span>.transactionTemplate.setTimeout(<span class="number">30</span>); <span class="comment">//seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TransactionManager</strong></p><p>使用TransactionManager管理事务也有两种</p><ol><li>PlatformTransactionManager</li><li>ReactiveTransactionManager</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager ;</span><br><span class="line"><span class="keyword">private</span> DefaultTransactionDefinition definition ;</span><br><span class="line"><span class="keyword">private</span> TransactionStatus status ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UsersRepository usersRepository ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService3</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.transactionManager = transactionManager ;</span><br><span class="line">  definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>() ;</span><br><span class="line">  definition.setName(<span class="string">&quot;pgName&quot;</span>) ;</span><br><span class="line">  definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED) ;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">saveUsers</span><span class="params">(Users users)</span> &#123;</span><br><span class="line">  <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionManager.getTransaction(definition) ;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = usersMapper.insertUser(users) ;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status) ;</span><br><span class="line">    <span class="keyword">throw</span> e ;</span><br><span class="line">  &#125;</span><br><span class="line">  transactionManager.commit(status) ;</span><br><span class="line">    </span><br><span class="line">  publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UsersEvent</span>(users));</span><br><span class="line">  <span class="keyword">return</span> result ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务事件监听</strong></p><p>通过@TransactionalEventListener注解监听事务的不同阶段的事件信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line">  TransactionPhase <span class="title function_">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">  Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">  Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  String <span class="title function_">condition</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fallbackExecution: 默认值false；如果设置为true，当前即便没有事务也会触发事件。</p><p>TransactionPhase：默认值是事务提交以后；有如下几个取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransactionPhase</span> &#123;</span><br><span class="line">  BEFORE_COMMIT, <span class="comment">// 事务提交前触发</span></span><br><span class="line">  AFTER_COMMIT, <span class="comment">// 事务提交后触发</span></span><br><span class="line">  AFTER_ROLLBACK, <span class="comment">// 事务回滚触发</span></span><br><span class="line">  AFTER_COMPLETION <span class="comment">// 事务完成后 触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：@TransactionalEventListener注解只对声明式事务起作用，对编程式事务无效。仅适用于由PlatformTransactionManager管理的线程绑定事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxListenerComponent</span> &#123;</span><br><span class="line">  <span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUsersAfterCommit</span><span class="params">(UsersEvent usersEvent)</span> &#123;</span><br><span class="line">    <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> (Users) usersEvent.getSource() ;</span><br><span class="line">    System.out.println(<span class="string">&quot;AfterCommit收到事件通知：&quot;</span> + user.getPassword()) ;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUsersAfterCompletion</span><span class="params">(UsersEvent usersEvent)</span> &#123;</span><br><span class="line">    <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> (Users) usersEvent.getSource() ;</span><br><span class="line">    System.out.println(<span class="string">&quot;AfterCompletion收到事件通知：&quot;</span> + user.getPassword()) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUsersAfterRollback</span><span class="params">(UsersEvent usersEvent)</span> &#123;</span><br><span class="line">    <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> (Users) usersEvent.getSource() ;</span><br><span class="line">    System.out.println(<span class="string">&quot;AfterRollback收到事件通知：&quot;</span> + user.getPassword()) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUsersBeforeCommit</span><span class="params">(UsersEvent usersEvent)</span> &#123;</span><br><span class="line">    <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> (Users) usersEvent.getSource() ;</span><br><span class="line">    System.out.println(<span class="string">&quot;BeforeCommit收到事件通知：&quot;</span> + user.getPassword()) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventPublisher publisher ;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UsersMapper usersMapper ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">saveUsers</span><span class="params">(Users users)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">doInTransaction</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> usersMapper.insertUser(users) ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) ;</span><br><span class="line">  publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UsersEvent</span>(users));</span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021-06-17 14:02:56.830 DEBUG 10000 --- [nio-8081-exec-1] com.pack.mapper.UsersMapper.insertUser   : ==&gt;  Preparing: insert into bc_users (id, username, password) values (?, ?, ?)</span><br><span class="line">2021-06-17 14:02:56.840 DEBUG 10000 --- [nio-8081-exec-1] com.pack.mapper.UsersMapper.insertUser   : ==&gt; Parameters: mmmmm(String), mmmmm(String), mmmmm(String)</span><br><span class="line">2021-06-17 14:02:56.842 DEBUG 10000 --- [nio-8081-exec-1] com.pack.mapper.UsersMapper.insertUser   : &lt;==    Updates: 1</span><br><span class="line">BeforeCommit收到事件通知：mmmmm</span><br><span class="line">AfterCommit收到事件通知：mmmmm</span><br><span class="line">AfterCompletion收到事件通知：mmmmm</span><br></pre></td></tr></table></figure><p>编程式的事务适合少量的事务操作；比如在一个服务的调用中有大量的计算操作，最后将计算结果进行事务的操作这种情况就适合应用事务编程式的进行事务控制。如果一个操作有很多的事务的操作那声明式的事务方式就更加的合适。</p><h5 id="事务传播类型"><a href="#事务传播类型" class="headerlink" title="事务传播类型"></a>事务传播类型</h5><p>事务传播类型，指的是事务与事务之间的交互策略。例如：在事务方法 A 中调用事务方法 B，当事务方法 B 失败回滚时，事务方法 A 应该如何操作？这就是事务传播类型。Spring 事务中定义了 7 种事务传播类型，分别是：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。其中最常用的只有 3 种，即：REQUIRED、REQUIRES_NEW、NESTED。</p><p>针对事务传播类型，我们要弄明白的是 4 个点：</p><ol><li>子事务与父事务的关系，是否会启动一个新的事务？</li><li>子事务异常时，父事务是否会回滚？</li><li>父事务异常时，子事务是否会回滚？</li><li>父事务捕捉异常后，父事务是否还会回滚？</li></ol><p><strong>REQUIRED</strong></p><p>REQUIRED 是 Spring 默认的事务传播类型，该传播类型的特点是：<strong>当前方法存在事务时，子方法加入该事务。此时父子方法共用一个事务，无论父子方法哪个发生异常回滚，整个事务都回滚。即使父方法捕捉了异常，也是会回滚。而当前方法不存在事务时，子方法新建一个事务。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">    tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add A&quot;</span>));</span><br><span class="line">    transactionServiceB.methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;methodB&quot;</span>);</span><br><span class="line">    tableService.insertTableB(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add B&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 methodA 和 methodB 的例子;当 methodA 不开启事务，methodB 开启事务，这时候 methodB 就是独立的事务，而 methodA 并不在事务之中。因此当 methodB 发生异常回滚时，methodA 中的内容就不会被回滚。最终的结果是：tablea 插入了数据，tableb 没有插入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">    tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add A&quot;</span>));</span><br><span class="line">    transactionServiceB.methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;methodB&quot;</span>);</span><br><span class="line">    tableService.insertTableB(<span class="keyword">new</span> <span class="title class_">TableEntity</span>(<span class="string">&quot;add B&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 methodA 开启事务，methodB 也开启事务。按照我们的结论，此时 methodB 会加入 methodA 的事务。此时，父子事务分别回滚时，另外一个事务是也会回滚。</p><p><strong>REQUIRES_NEW</strong></p><p>REQUIRES_NEW 也是常用的一个传播类型，该传播类型的特点是：<strong>无论当前方法是否存在事务，子方法都新建一个事务。此时父子方法的事务时独立的，它们都不会相互影响。但父方法需要注意子方法抛出的异常，避免因子方法抛出异常，而导致父方法回滚。</strong></p><p><strong>NESTED</strong></p><p>NESTED 也是常用的一个传播类型，该方法的特性与 REQUIRED 非常相似，其特性是：<strong>当前方法存在事务时，子方法加入在嵌套事务执行。当父方法事务回滚时，子方法事务也跟着回滚。当子方法事务发送回滚时，父事务是否回滚取决于是否捕捉了异常。如果捕捉了异常，那么就不回滚，否则回滚。</strong></p><p>NESTED 与 REQUIRED 的区别在于：父方法与子方法对于共用事务的描述是不一样的，REQUIRED 说的是共用同一个事务，而 NESTED 说的是在嵌套事务执行。这一个区别的具体体现是：<strong>在子方法事务发生异常回滚时，父方法有着不同的反应动作。</strong></p><table><thead><tr><th align="center">事务传播类型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">REQUIRED</td><td align="center">当前方法存在事务时，子方法加入该事务。此时父子方法共用一个事务，无论父子方法哪个发生异常回滚，整个事务都回滚。即使父方法捕捉了异常，也是会回滚。而当前方法不存在事务时，子方法新建一个事务。</td></tr><tr><td align="center">REQUIRES_NEW</td><td align="center">无论当前方法是否存在事务，子方法都新建一个事务。此时父子方法的事务时独立的，它们都不会相互影响。但父方法需要注意子方法抛出的异常，避免因子方法抛出异常，而导致父方法回滚。</td></tr><tr><td align="center">NESTED</td><td align="center">当前方法存在事务时，子方法加入在嵌套事务执行。当父方法事务回滚时，子方法事务也跟着回滚。当子方法事务发送回滚时，父事务是否回滚取决于是否捕捉了异常。如果捕捉了异常，那么就不回滚，否则回滚。</td></tr></tbody></table><p>使用 Spring 事务的步骤为：</p><ol><li>根据业务场景，分析要达成的事务效果，确定使用的事务传播类型。</li><li>在 Service 层使用 @Transaction 注解，配置对应的 propogation 属性。</li></ol><h5 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h5><p>1)若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效，这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p><p>2）如果直接调用，不通过对象调用，也是会失效的。因为 Spring 事务是通过 AOP 实现的。</p><p>3）@Transactional 注解只有作用到 public 方法上事务才生效。</p><p>4）被 @Transactional 注解的方法所在的类必须被 Spring 管理。</p><p>5）底层使用的数据库必须支持事务机制，否则不生效。</p><p>6）Spring 事务执行过程中，如果抛出非 RuntimeException 和非 Error 错误的其他异常，那么是不会回滚的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    tableService.insertTableA(<span class="keyword">new</span> <span class="title class_">TableEntity</span>());</span><br><span class="line">    transactionServiceB.methodB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    tableService.insertTableB(<span class="keyword">new</span> <span class="title class_">TableEntity</span>());</span><br><span class="line">    <span class="comment">// 非 RuntimeException</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/splKrRnvrsMXJSiGLny-aw">https://mp.weixin.qq.com/s/splKrRnvrsMXJSiGLny-aw</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用数据结构与算法总结</title>
      <link href="/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文采用Java语言来进行描述，帮大家好好梳理一下数据结构与算法，在工作和面试中用的上。亦即总结常见的的数据结构，以及在Java中相应的实现方法，务求理论与实践一步总结到位。</p><span id="more"></span><p>Java集合框架的基本接口&#x2F;类层次结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    +--java.util.List [I]</span><br><span class="line">       +--java.util.ArrayList [C]    </span><br><span class="line">       +--java.util.LinkedList [C]  </span><br><span class="line">       +--java.util.Vector [C]    //线程安全</span><br><span class="line">          +--java.util.Stack [C]  //线程安全</span><br><span class="line">    +--java.util.Set [I]                   </span><br><span class="line">       +--java.util.HashSet [C]      </span><br><span class="line">       +--java.util.SortedSet [I]    </span><br><span class="line">          +--java.util.TreeSet [C]    </span><br><span class="line">    +--Java.util.Queue[I]</span><br><span class="line">        +--java.util.Deque[I]   </span><br><span class="line">        +--java.util.PriorityQueue[C]  </span><br><span class="line">java.util.Map [I]</span><br><span class="line">    +--java.util.SortedMap [I]</span><br><span class="line">       +--java.util.TreeMap [C]</span><br><span class="line">    +--java.util.Hashtable [C]   //线程安全</span><br><span class="line">    +--java.util.HashMap [C]</span><br><span class="line">    +--java.util.LinkedHashMap [C]</span><br><span class="line">    +--java.util.WeakHashMap [C]</span><br><span class="line"></span><br><span class="line">[I]：接口</span><br><span class="line">[C]：类</span><br></pre></td></tr></table></figure><h3 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h3><p><img src="/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.jpg" alt="图片"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是相同数据类型的元素按一定顺序排列的集合，是一块连续的内存空间。数组的优点是：get和set操作时间上都是O(1)的；缺点是：add和remove操作时间上都是O(N)的。</p><p>Java中，Array就是数组，此外，ArrayList使用了数组Array作为其实现基础,它和一般的Array相比，最大的好处是，我们在添加元素时不必考虑越界，元素超出数组容量时，它会自动扩张保证容量。</p><p>Vector和ArrayList相比，主要差别就在于多了一个线程安全性，但是效率比较低下。如今java.util.concurrent包提供了许多线程安全的集合类（比如 LinkedBlockingQueue），所以不必再使用Vector了。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是一种非连续、非顺序的结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，链表由一系列结点组成。链表的优点是：add和remove操作时间上都是O(1)的；缺点是：get和set操作时间上都是O(N)的，而且需要额外的空间存储指向其他数据地址的项。查找操作对于未排序的数组和链表时间上都是O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">linkedList.add(<span class="string">&quot;addd&quot;</span>);<span class="comment">//add</span></span><br><span class="line">linkedList.set(<span class="number">0</span>,<span class="string">&quot;s&quot;</span>);<span class="comment">//set，必须先保证 linkedList中已经有第0个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span>  linkedList.get(<span class="number">0</span>);<span class="comment">//get</span></span><br><span class="line">linkedList.contains(<span class="string">&quot;s&quot;</span>);<span class="comment">//查找</span></span><br><span class="line">linkedList.remove(<span class="string">&quot;s&quot;</span>);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，亦即所谓的先进先出（FIFO）。</p><p>Java中，LinkedList实现了Deque，可以做为双向队列（自然也可以用作单向队列）。另外PriorityQueue实现了带优先级的队列，亦即队列的每一个元素都有优先级，且元素按照优先级排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; integerDeque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 尾部入队，区别在于如果失败了</span></span><br><span class="line"><span class="comment">// add方法会抛出一个IllegalStateException异常，而offer方法返回false</span></span><br><span class="line">integerDeque.offer(<span class="number">122</span>);</span><br><span class="line">integerDeque.add(<span class="number">122</span>);</span><br><span class="line"><span class="comment">// 头部出队,区别在于如果失败了</span></span><br><span class="line"><span class="comment">// remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> integerDeque.poll();<span class="comment">//返回第一个元素，并在队列中删除</span></span><br><span class="line">head = integerDeque.remove();<span class="comment">//返回第一个元素，并在队列中删除</span></span><br><span class="line"><span class="comment">// 头部出队，区别在于如果失败了</span></span><br><span class="line"><span class="comment">// element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span></span><br><span class="line">head = integerDeque.peek();<span class="comment">//返回第一个元素，不删除</span></span><br><span class="line">head = integerDeque.element();<span class="comment">//返回第一个元素，不删除</span></span><br></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。它体现了后进先出（LIFO）的特点。</p><p>Java中，Stack实现了这种特性，但是Stack也继承了Vector，所以具有线程安全线和效率低下两个特性，最新的JDK8中，推荐用Deque来实现栈，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">stack.push(<span class="number">12</span>);<span class="comment">//尾部入栈</span></span><br><span class="line">stack.push(<span class="number">16</span>);<span class="comment">//尾部入栈</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> stack.pop();<span class="comment">//尾部出栈，并删除该元素</span></span><br><span class="line">tail = stack.peek();<span class="comment">//尾部出栈，不删除该元素</span></span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h4><p>集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素，其主要特性是元素不可重复。</p><p>在Java中，HashSet 体现了这种数据结构，而HashSet是在MashMap的基础上构建的。LinkedHashSet继承了HashSet，使用HashCode确定在集合中的位置，使用链表的方式确定位置，所以有顺序。TreeSet实现了SortedSet 接口，是排好序的集合（在TreeMap 基础之上构建），因此查找操作比普通的Hashset要快（log(N)）；插入操作要慢（log（N））,因为要维护有序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integerHashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">integerHashSet.add(<span class="number">12121</span>);<span class="comment">//添加</span></span><br><span class="line">integerHashSet.contains(<span class="number">121</span>);<span class="comment">//是否包含</span></span><br><span class="line">integerHashSet.size();<span class="comment">//集合大小</span></span><br><span class="line">integerHashSet.isEmpty();<span class="comment">//是否为空</span></span><br></pre></td></tr></table></figure><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表也叫哈希表，是根据关键键值(Keyvalue)进行访问的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。</p><p>Java中HashMap实现了散列表，而Hashtable比它多了一个线程安全性，但是由于使用了全局锁导致其性能较低，所以现在一般用ConcurrentHashMap来实现线程安全的HashMap（类似的，以上的数据结构在最新的java.util.concurrent的包中几乎都有对应的高性能的线程安全的类）。TreeMap实现SortMap接口，能够把它保存的记录按照键排序。LinkedHashMap保留了元素插入的顺序。WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收，而不需要我们手动删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="number">1</span>,<span class="string">&quot;asdsa&quot;</span>);<span class="comment">//添加</span></span><br><span class="line">hashMap.get(<span class="number">1</span>);<span class="comment">//获得</span></span><br><span class="line">hashMap.size();<span class="comment">//元素个数</span></span><br></pre></td></tr></table></figure><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树（tree）是包含n（n&gt;0）个节点的有穷集合，其中：</p><ul><li><p>每个元素称为节点（node）</p></li><li><p>有一个特定的节点被称为根节点或树根（root）</p></li></ul><p>除根节点之外的其余数据元素被分为m（m≥0）个互不相交的结合T1，T2，……Tm-1，其中每一个集合Ti（1&lt;&#x3D;i&lt;&#x3D;m）本身也是一棵树，被称作原树的子树（subtree）。</p><p>树这种数据结构在计算机世界中有广泛的应用，比如操作系统中用到了红黑树，数据库用到了B+树，编译器中的语法树，内存管理用到了堆（本质上也是树），信息论中的哈夫曼编码等等，在Java中TreeSet和TreeMap用到了树来排序（二分查找提高检索速度），不过一般都需要程序员自己去定义一个树的类，并实现相关性质，而没有现成的API。下面就用Java来实现各种常见的树。</p><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h5><p>二叉树是一种基础而且重要的数据结构，其每个结点至多只有二棵子树，二叉树有左右子树之分，第i层至多有2^(i-1)个结点（i从1开始）；深度为k的二叉树至多有2^(k)-1)个结点，对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</p><p>二叉树的性质：</p><ol><li><p>在非空二叉树中，第i层的结点总数不超过2^(i-1), i&gt;&#x3D;1;</p></li><li><p>深度为h的二叉树最多有2^h-1个结点(h&gt;&#x3D;1)，最少有h个结点;</p></li><li><p>对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0&#x3D;N2+1;</p></li><li><p>具有n个结点的完全二叉树的深度为log2(n+1);</p></li></ol><p>5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：</p><p>若I为结点编号则 如果I&gt;1，则其父结点的编号为I&#x2F;2；<br>如果2I&lt;&#x3D;N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子；<br>如果2I+1&lt;&#x3D;N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。　　　　</p><p>6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)&#x3D;C(2*n, n)&#x2F;(n+1)。</p><p>7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J&#x3D;I+2i。</p><h5 id="满二叉树、完全二叉树"><a href="#满二叉树、完全二叉树" class="headerlink" title="满二叉树、完全二叉树"></a>满二叉树、完全二叉树</h5><p>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</p><p>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树；</p><p>满二叉树是完全二叉树的一个特例。</p><h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>二叉查找树，又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ol><li><p>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</p></li><li><p>左、右子树也分别为二叉排序树；</p></li><li><p>没有键值相等的节点。</p></li></ol><p>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡二叉树设计的初衷。</p><p>二叉查找树可以这样表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;             <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;           <span class="comment">// 排序的间</span></span><br><span class="line">        <span class="keyword">private</span> Value val;         <span class="comment">// 相应的值</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// 左子树，右子树</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;          <span class="comment">// 以该节点为根的树包含节点数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value val, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="comment">//获得该二叉树节点数量</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node x)</span> &#123;获得以该节点为根的树包含节点数量</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node x, Key key)</span> &#123;<span class="comment">//在以x节点为根的树中查找key</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left, key);<span class="comment">//递归左子树查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right, key);<span class="comment">//递归右子树查找</span></span><br><span class="line">    <span class="keyword">else</span>              <span class="keyword">return</span> x.val;<span class="comment">//找到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value val)</span> &#123;</span><br><span class="line">    root = put(root, key, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span> &#123;在以x节点为根的树中查找key，val</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(x == <span class="literal">null</span>)</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) x.left  = put(x.left,  key, val);<span class="comment">//递归左子树插入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val);<span class="comment">//递归右子树插入</span></span><br><span class="line">    <span class="keyword">else</span>              x.val   = val;</span><br><span class="line">    x.size = <span class="number">1</span> + size(x.left) + size(x.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">min</span><span class="params">(Node x)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="literal">null</span>) <span class="keyword">return</span> x; </span><br><span class="line">    <span class="keyword">else</span>                <span class="keyword">return</span> min(x.left); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">deleteMin</span><span class="params">(Node x)</span> &#123;<span class="comment">//删除以x为根节点的子树最小值</span></span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="literal">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">    x.left = deleteMin(x.left);</span><br><span class="line">    x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">     root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node x, Key key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) x.left  = delete(x.left,  key);<span class="comment">//递归删除左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right, key);<span class="comment">//递归删除右子树</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//该节点就是所要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="literal">null</span>) <span class="keyword">return</span> x.left;<span class="comment">//没有右子树，把左子树挂在原节点父节点上</span></span><br><span class="line">        <span class="keyword">if</span> (x.left  == <span class="literal">null</span>) <span class="keyword">return</span> x.right;<span class="comment">//没有左子树，，把右子树挂在原节点父节点上</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> x;<span class="comment">//用右子树中最小的节点来替代被删除的节点，仍然保证树的有序性</span></span><br><span class="line">        x = min(t.right);</span><br><span class="line">        x.right = deleteMin(t.right);</span><br><span class="line">        x.left = t.left;</span><br><span class="line">    &#125; </span><br><span class="line">    x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><p>平衡二叉树又被称为AVL树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。它的出现就是解决二叉查找树不平衡导致查找效率退化为线性的问题，因为在删除和插入之时会维护树的平衡，使得查找时间保持在O(logn)，比二叉查找树更稳定。</p><p>ALLTree 的 Node 由 BST 的 Node 加上 private int height; 节点高度属性即可，这是为了便于判断树是否平衡。</p><p>维护树的平衡关键就在于旋转。对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：</p><p>1、6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。</p><p>2、6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。</p><p>3、2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。</p><p>4、2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。</p><p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p><p>单旋转是针对于左左和右右这两种情况，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p><p>为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p><p>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private int height(Node t)&#123;  </span><br><span class="line">    return t == null ? -1 : t.height;  </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">//左左情况单旋转  </span><br><span class="line">private Node rotateWithLeftChild(Node k2)&#123;  </span><br><span class="line">    Node k1 = k2.left;  </span><br><span class="line">    k2.left = k1.right;       </span><br><span class="line">    k1.right = k2;        </span><br><span class="line">    k1.size = k2.size;</span><br><span class="line">    k2.size = size(k2.right)+size(k2.left)+1;</span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height = Math.max(height(k1.left), k2.height) + 1;         </span><br><span class="line">    return k1;      //返回新的根  </span><br><span class="line">&#125;     </span><br><span class="line">//右右情况单旋转  </span><br><span class="line">private Node rotateWithRightChild(Node k2)&#123;  </span><br><span class="line">    Node k1 = k2.right;  </span><br><span class="line">    k2.right = k1.left;  </span><br><span class="line">    k1.left = k2;  </span><br><span class="line">    k1.size = k2.size;</span><br><span class="line">    k2.size = size(k2.right)+size(k2.left)+1;       </span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height = Math.max(height(k1.right), k2.height) + 1;        </span><br><span class="line">    return k1;      //返回新的根   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>双旋转是针对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p><p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树树。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右情况  </span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">doubleWithLeftChild</span><span class="params">(Node k3)</span>&#123;        </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        k3.left = rotateWithRightChild(k3.left);  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;k.left.right为：&quot;</span>+k3.left.right);  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> rotateWithLeftChild(k3);       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右左情况  </span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">doubleWithRightChild</span><span class="params">(Node k3)</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        k3.right = rotateWithLeftChild(k3.right);  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;k.right.left为：&quot;</span>+k3.right.left);  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">return</span> rotateWithRightChild(k3);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>AVL查找操作与BST相同，AVL的删除与插入操作在BST基础之上需要检查是否平衡，如果不平衡就要使用旋转操作来维持平衡:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">balance</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor(x) &lt; -<span class="number">1</span>) &#123;<span class="comment">//右边高</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(x.right) &gt; <span class="number">0</span>) &#123;<span class="comment">//右左</span></span><br><span class="line">            x.right = rotateWithLeftChild(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        x = rotateWithRightChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor(x) &gt; <span class="number">1</span>) &#123;<span class="comment">//左边高</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(x.left) &lt; <span class="number">0</span>) &#123;<span class="comment">//左右</span></span><br><span class="line">            x.left = rotateWithRightChild(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        x = rotateWithLeftChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">balanceFactor</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(x.left) - height(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是一颗完全二叉树，在这棵树中，所有父节点都满足大于等于其子节点的堆叫大根堆，所有父节点都满足小于等于其子节点的堆叫小根堆。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。如下图的小根堆及存储它的数组：</p><p>值：7,8,9,12,13,11</p><p>数组索引：0,1,2,3, 4, 5</p><p>通过一个节点在数组中的索引怎么计算出它的父节点及左右孩子节点的索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// i为根结点</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护大根堆的性质：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(T[] a, <span class="type">int</span> i, <span class="type">int</span> heapLength)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//寻找根节点及其左右子节点，三个元素中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapLength &amp;&amp; a[i].compareTo(a[l]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        largest = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapLength &amp;&amp; a[largest].compareTo(a[r]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果i处元素不是最大的，就把i处的元素与最大处元素交换，使得i处元素变为最大的</span></span><br><span class="line">    <span class="keyword">if</span> (i != largest) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[largest];</span><br><span class="line">        a[largest] = temp;</span><br><span class="line">        <span class="comment">// 交换元素后，以a[i]为根的树可能不在满足大根堆性质，于是递归调用该方法</span></span><br><span class="line">        heapify(a, largest, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造堆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(T[] a, <span class="type">int</span> heapLength)</span> &#123;</span><br><span class="line">    <span class="comment">//从后往前看lengthParent处的元素是第一个有子节点的元素，所以从它开始，进行堆得维护</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthParent</span> <span class="operator">=</span> parent(heapLength - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lengthParent; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(a, i, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的用途：堆排序，优先级队列。此外由于调整代价较小，也适合实时类型的排序与变更。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis延时任务</title>
      <link href="/2023/11/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/11/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>在开发中，往往会遇到一些关于延时任务的需求。例如</p><ul><li>生成订单30分钟未支付，则自动取消</li><li>生成订单60秒后,给用户发短信</li></ul><span id="more"></span><p>对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别</p><ul><li>定时任务有明确的触发时间，延时任务没有(一般是相对某个时间触发)</li><li>定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期</li><li>定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据库轮询"><a href="#数据库轮询" class="headerlink" title="数据库轮询"></a>数据库轮询</h4><p>该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作。</p><p><strong>代码实现</strong></p><p>引入quartz</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Job实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span></span><br><span class="line">        <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;要去数据库扫描啦。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class)</span><br><span class="line">                                        .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建触发器 每3秒钟执行一次</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                                        .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group3&quot;</span>)                                                    .withSchedule(SimpleScheduleBuilder.simpleSchedule()                                                                       .withIntervalInSeconds(<span class="number">3</span>).repeatForever()).build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>().getScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务及其触发器放入调度器</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器开始调度任务</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>优点:</p><ul><li>简单易行，支持集群操作</li></ul><p>缺点:</p><ul><li>对服务器内存消耗大</li><li>存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟</li><li>假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大</li></ul><h4 id="JDK的延迟队列"><a href="#JDK的延迟队列" class="headerlink" title="JDK的延迟队列"></a>JDK的延迟队列</h4><p>该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。</p><p>DelayedQueue实现工作流程如下图所示:</p><p><img src="/2023/11/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/1.png" alt="图片"></p><p>其中</p><ul><li><code>Poll()</code>:获取并移除队列的超时元素，没有则返回空</li><li><code>take()</code>:获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。</li></ul><p><strong>代码实现</strong></p><p>定义一个类OrderDelay</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDelay</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    OrderDelay(String orderId, <span class="type">long</span> timeout) &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout + System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDelay</span> <span class="variable">t</span> <span class="operator">=</span> (OrderDelay) other;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">            t.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? (-<span class="number">1</span>) : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回距离你自定义的超时时间还有多少</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(timeout - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(orderId + <span class="string">&quot;编号的订单要删除啦。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的测试Demo，我们设定延迟时间为3秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        List &lt; String &gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span> &lt; String &gt; ();</span><br><span class="line">        list.add(<span class="string">&quot;00000001&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;00000002&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;00000003&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;00000004&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;00000005&quot;</span>);</span><br><span class="line">        DelayQueue &lt; OrderDelay &gt; queue = newDelayQueue &lt; OrderDelay &gt; ();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延迟三秒取出</span></span><br><span class="line">            queue.put(<span class="keyword">new</span> <span class="title class_">OrderDelay</span>(list.get(i), TimeUnit.NANOSECONDS.convert(<span class="number">3</span>, TimeUnit.SECONDS)));</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                queue.take().print();</span><br><span class="line">                System.out.println(<span class="string">&quot;After &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; MilliSeconds&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00000001编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After 3003 MilliSeconds</span><br><span class="line"></span><br><span class="line">00000002编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After 6006 MilliSeconds</span><br><span class="line"></span><br><span class="line">00000003编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After 9006 MilliSeconds</span><br><span class="line"></span><br><span class="line">00000004编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After 12008 MilliSeconds</span><br><span class="line"></span><br><span class="line">00000005编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After 15009 MilliSeconds</span><br></pre></td></tr></table></figure><p>可以看到都是延迟3秒，订单被删除</p><p><strong>优缺点</strong></p><p>优点:</p><ul><li>效率高,任务触发时间延迟低。</li></ul><p>缺点:</p><ul><li>服务器重启后，数据全部消失，怕宕机</li><li>集群扩展相当麻烦</li><li>因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常</li><li>代码复杂度较高</li></ul><h4 id="时间轮算法"><a href="#时间轮算法" class="headerlink" title="时间轮算法"></a>时间轮算法</h4><p><img src="/2023/11/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/2.png" alt="图片"></p><p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel&#x3D;60，tickDuration&#x3D;1，timeUnit&#x3D;秒，这就和现实中的始终的秒针走动完全类似了。</p><p>如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）。</p><p><strong>代码实现</strong></p><p>用Netty的HashedWheelTimer来实现</p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.24.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码HashedWheelTimerTest如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashedWheelTimerTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">implements</span> <span class="title class_">TimerTask</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTimerTask</span><span class="params">(<span class="type">boolean</span> flag)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            System.out.println(<span class="string">&quot;要去数据库删除订单了。。。。&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyTimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimer</span>();</span><br><span class="line">        timer.newTimeout(timerTask, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(timerTask.flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;秒过去了&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1秒过去了</span><br><span class="line"></span><br><span class="line">2秒过去了</span><br><span class="line"></span><br><span class="line">3秒过去了</span><br><span class="line"></span><br><span class="line">4秒过去了</span><br><span class="line"></span><br><span class="line">5秒过去了</span><br><span class="line"></span><br><span class="line">要去数据库删除订单了。。。。</span><br><span class="line"></span><br><span class="line">6秒过去了</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>优点:</p><ul><li>效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。</li></ul><p>缺点:</p><ul><li>服务器重启后，数据全部消失，怕宕机</li><li>集群扩展相当麻烦</li><li>因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常</li></ul><h4 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h4><p>利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值</p><ul><li>添加元素:<code>ZADD key score member [[score member] [score member] …]</code></li><li>按顺序查询元素:<code>ZRANGE key start stop [WITHSCORES]</code></li><li>查询元素：<code>score:ZSCORE key member</code></li><li>移除元素:<code>ZREM key member [member …]</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 添加单个元素</span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加多个元素</span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line"></span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line"></span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"># 查询元素的score值</span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE page_rank bing.com</span><br><span class="line">&quot;8&quot;</span><br><span class="line"></span><br><span class="line"># 移除单个元素</span><br><span class="line"> </span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line"></span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br></pre></td></tr></table></figure><p>那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示</p><p><img src="/2023/11/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/3.png" alt="图片"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADDR</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(ADDR, PORT);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//生产者,生成5个订单放进去</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productionDelayMessage</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">//延迟3秒</span></span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    cal1.add(Calendar.SECOND, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">second3later</span> <span class="operator">=</span> (<span class="type">int</span>)(cal1.getTimeInMillis() / <span class="number">1000</span>);</span><br><span class="line">    AppTest.getJedis().zadd(<span class="string">&quot;OrderId&quot;</span>, second3later, <span class="string">&quot;OID0000001&quot;</span> + i);</span><br><span class="line">    System.out.println(System.currentTimeMillis() + <span class="string">&quot;ms:redis生成了一个订单任务：订单ID为&quot;</span> + <span class="string">&quot;OID0000001&quot;</span> + i);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//消费者，取订单</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerDelayMessage</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> AppTest.getJedis();</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   Set &lt; Tuple &gt; items = jedis.zrangeWithScores(<span class="string">&quot;OrderId&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span>(items == <span class="literal">null</span> || items.isEmpty())</span><br><span class="line">   &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前没有等待的任务&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">     Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> (<span class="type">int</span>)((Tuple) items.toArray()[<span class="number">0</span>]).getScore();</span><br><span class="line">   <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">   <span class="type">int</span> <span class="variable">nowSecond</span> <span class="operator">=</span> (<span class="type">int</span>)(cal.getTimeInMillis() / <span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">if</span>(nowSecond &gt;= score)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> ((Tuple) items.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line">    jedis.zrem(<span class="string">&quot;OrderId&quot;</span>, orderId);</span><br><span class="line">    System.out.println(System.currentTimeMillis() + <span class="string">&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;</span> + orderId);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">AppTest</span> <span class="variable">appTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppTest</span>();</span><br><span class="line">  appTest.productionDelayMessage();</span><br><span class="line">  appTest.consumerDelayMessage();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：在高并发条件下，多消费者会取到同一个订单号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> newCountDownLatch(threadNum);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelayMessage</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">    cdl.await();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">AppTest</span> <span class="variable">appTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppTest</span>();</span><br><span class="line">   appTest.consumerDelayMessage();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">AppTest</span> <span class="variable">appTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppTest</span>();</span><br><span class="line">  appTest.productionDelayMessage();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DelayMessage</span>()).start();</span><br><span class="line">   cdl.countDown();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><p>(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。</p><p>(2)对ZREM的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerDelayMessage()方法里的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nowSecond &gt;= score)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> ((Tuple) items.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line"> <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> jedis.zrem(<span class="string">&quot;OrderId&quot;</span>, orderId);</span><br><span class="line"> <span class="keyword">if</span>(num != <span class="literal">null</span> &amp;&amp; num &gt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  System.out.println(System.currentTimeMillis() + <span class="string">&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;</span> + orderId);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><p>该方案使用redis的Keyspace Notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。</p><p>在redis.conf中，加入一条配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADDR</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(ADDR, PORT);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">RedisSub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSub</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">    jedis.getResource().subscribe(sub, <span class="string">&quot;__keyevent@0__:expired&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> &#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="string">&quot;OID000000&quot;</span> + i;</span><br><span class="line">   jedis.getResource().setex(orderId, <span class="number">3</span>, orderId);</span><br><span class="line">   System.out.println(System.currentTimeMillis() + <span class="string">&quot;ms:&quot;</span> + orderId + <span class="string">&quot;订单生成&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RedisSub</span> <span class="keyword">extends</span> <span class="title class_">JedisPubSub</span></span><br><span class="line"> &#123; &lt; ahref = <span class="string">&#x27;http://www.jobbole.com/members/wx610506454&#x27;</span> &gt; <span class="meta">@Override</span> &lt; /a&gt;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span></span><br><span class="line">  &#123;</span><br><span class="line">   System.out.println(System.currentTimeMillis() + <span class="string">&quot;ms:&quot;</span> + message + <span class="string">&quot;订单取消&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:redis的pub&#x2F;sub机制存在一个硬伤，官网内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Because Redis Pub/Sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.</span><br><span class="line"></span><br><span class="line">// 翻译</span><br><span class="line">Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。</span><br></pre></td></tr></table></figure><p>不太推荐，如果可靠性不高，可以使用</p><h4 id="使用消息队列"><a href="#使用消息队列" class="headerlink" title="使用消息队列"></a>使用消息队列</h4><p>我们可以采用rabbitMQ的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列</p><p>RabbitMQ可以针对Queue和Message设置 <code>x-message-tt</code>，来控制消息的生存时间，如果超时，则消息变为<code>dead letter</code></p><p>RabbitMQ的Queue可以配置<code>x-dead-letter-exchange</code> 和<code>x-dead-letter-routing-key</code>（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。</p><p>结合以上两个特性，就可以模拟出延迟消息的功能。</p><p><strong>优缺点</strong></p><p>优点:</p><ul><li>高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。</li></ul><p>缺点：</p><ul><li>本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任务调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位操作</title>
      <link href="/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>在计算机世界里，再复杂，再美的程序，到最后都会变成0与1。也就是我们常说的：<strong>二进制</strong>。二进制位中的一些常用运算。例如：**&amp; (位与)<strong>，</strong>| (位或)** ，<strong>^(异或)<strong>，</strong>&lt;&lt;(左移)**，**&gt;&gt;(右移)</strong> 等等。</p><span id="more"></span><h4 id="真与假"><a href="#真与假" class="headerlink" title="真与假"></a>真与假</h4><p> 在Java中，用 true 值表示真，false 值表示假。其实在计算机中，通常使用 1 表示真，0表示假。</p><h4 id="位与"><a href="#位与" class="headerlink" title="&amp; (位与)"></a>&amp; (位与)</h4><p>在说位与之前，我们先来说说我们熟悉的 <strong>&amp;&amp;</strong> 逻辑与操作。简单来说： A&amp;&amp;B  也就是：A且B同时成立时为真，否则为假。也有人称之为：“一假必假”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a binary: &quot;</span>+Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(<span class="string">&quot;b binary: &quot;</span>+Integer.toBinaryString(b));</span><br><span class="line">    System.out.println(<span class="string">&quot;a &amp; b binary: &quot;</span>+Integer.toBinaryString(a&amp;b));</span><br><span class="line">    System.out.println(<span class="string">&quot;a &amp; b result: &quot;</span>+(a&amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong>：</p><p>位与：我们从字面意思上来理解，也是二进制位的与操作。</p><ol><li>数字 8 的十进制是： 1000 。</li><li>数字 9 的十进制是： 1001。</li></ol><p>我们再来进行位于操作：</p><p>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8：1000</span><br><span class="line">9：1001</span><br><span class="line">&amp;</span><br><span class="line">8  1000</span><br></pre></td></tr></table></figure><p>最左边的 1&amp;1 &#x3D; 1，中间的 0&amp;0 &#x3D; 0，最右边的0&amp;1 &#x3D; 0。</p><p>二进制的结果为：1000，转换为10进制后为 8。</p><p>程序运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a binary: 1000</span><br><span class="line">b binary: 1001</span><br><span class="line">a &amp; b binary: 1000</span><br><span class="line">a &amp; b result: 8</span><br></pre></td></tr></table></figure><h4 id="位或"><a href="#位或" class="headerlink" title="| (位或)"></a>| (位或)</h4><p>上面说 <strong>&amp; (位与)</strong> 操作，现在我们来看看位或操作，继续使用上面的例子：如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testBit()&#123;</span><br><span class="line">    int a = 8;</span><br><span class="line">    int b = 9;</span><br><span class="line">    System.out.println(&quot;a binary: &quot;+Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(&quot;b binary: &quot;+Integer.toBinaryString(b));</span><br><span class="line">    System.out.println(&quot;a &amp; b binary: &quot;+Integer.toBinaryString(a|b));</span><br><span class="line">    System.out.println(&quot;a &amp; b result: &quot;+(a|b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8：1000</span><br><span class="line">9：1001</span><br><span class="line">|</span><br><span class="line">9  1001</span><br></pre></td></tr></table></figure><p>最左边的 1|1 &#x3D; 1，中间的0|0 &#x3D; 0 ，最右边的 0|1 &#x3D; 1。</p><p>结果二进制为： 1001 对应的10进制为 9。</p><p>运算结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a binary: 1000</span><br><span class="line">b binary: 1001</span><br><span class="line">a &amp; b binary: 1001</span><br><span class="line">a &amp; b result: 9</span><br></pre></td></tr></table></figure><h4 id="异或"><a href="#异或" class="headerlink" title="^(异或)"></a>^(异或)</h4><p> 这个运算符比较有意思，异从字面上来理解是：不同的。放在位操作里也是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a binary: &quot;</span>+Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(<span class="string">&quot;b binary: &quot;</span>+Integer.toBinaryString(b));</span><br><span class="line">    System.out.println(<span class="string">&quot;a &amp; b binary: &quot;</span>+Integer.toBinaryString(a^b));</span><br><span class="line">    System.out.println(<span class="string">&quot;a &amp; b result: &quot;</span>+(a^b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8:1000</span><br><span class="line">9:1001</span><br><span class="line">^</span><br><span class="line">1  0001</span><br></pre></td></tr></table></figure><p>位相同时取假，不同时取真。左边的 1&#x3D;1 相同取假，也就是0。中间的0&#x3D;0 也为假为0。最右边的0不等于1，为真。结果也就为1。</p><h4 id=""><a href="#" class="headerlink" title="&lt;&lt;(左移)"></a>&lt;&lt;(左移)</h4><p>在现实世界里，我们经常使用乘法。&lt;&lt; 则表示二进制中的左移操作，低位补0。例如：8&lt;&lt;1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCode</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">8</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a toBinaryString: &quot;</span>+Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(<span class="string">&quot;a&lt;&lt;1 toBinaryString: &quot;</span>+Integer.toBinaryString(a&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;result: &quot;</span>+(a&lt;&lt;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8  1000</span><br><span class="line">8&lt;&lt;1</span><br><span class="line">16 10000</span><br></pre></td></tr></table></figure><p>结果为： 2^4  &#x3D; 16。  &lt;&lt; 左边 a 表示基数， 右边 1 则表示需要位移动的位数。 箭头指向哪边，则向哪边位移。程序运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a toBiryString: 1000</span><br><span class="line">a&lt;&lt;1 toBinaryString: 10000</span><br><span class="line">result: 16</span><br></pre></td></tr></table></figure><h4 id="右移"><a href="#右移" class="headerlink" title="&gt;&gt; 右移"></a>&gt;&gt; 右移</h4><p> &gt;&gt;(右移) 与左移 &lt;&lt;  则是相反的，高位补0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCode</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">8</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a toBinaryString: &quot;</span>+Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(<span class="string">&quot;1&gt;&gt;a toBinaryString: &quot;</span>+Integer.toBinaryString(a&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;result: &quot;</span>+(a&gt;&gt;<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8 : 1000</span><br><span class="line">8&gt;&gt;1</span><br><span class="line">4 : 0100</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a toBinaryString: 1000</span><br><span class="line">a&gt;&gt;1 toBinaryString: 100</span><br><span class="line">result: 4</span><br></pre></td></tr></table></figure><p>其实这里还有一个比较好记的口诀：</p><p>a&gt;&gt;n 则表示： a &#x2F; (2^n) 次方。  (取整)</p><p>a&lt;&lt;n 则结果为： a * (2^n) 次方。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理重复请求</title>
      <link href="/2023/11/25/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/"/>
      <url>/2023/11/25/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>对于一些用户请求，在某些情况下是可能重复发送的，如果是查询类操作并无大碍，但其中有些是涉及写入操作的，一旦重复了，可能会导致很严重的后果，例如交易的接口如果重复请求可能会重复下单。</p><span id="more"></span><p>重复的场景有可能是：</p><ol><li>黑客拦截了请求，重放</li><li>前端&#x2F;客户端因为某些原因请求重复发送了，或者用户在很短的时间内重复点击了。</li><li>网关重发</li><li>….</li></ol><h3 id="利用唯一请求编号去重"><a href="#利用唯一请求编号去重" class="headerlink" title="利用唯一请求编号去重"></a>利用唯一请求编号去重</h3><p>只要请求有唯一的请求编号，那么就能借用Redis做这个去重——只要这个唯一请求编号在redis存在，证明处理过，那么就认为是重复的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;REQ12343456788&quot;</span>;<span class="comment">//请求唯一编号</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span>  <span class="number">1000</span>;<span class="comment">// 1000毫秒过期，1000ms内的重复请求会认为重复</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="string">&quot;expireAt@&quot;</span> + expireAt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis key还存在的话要就认为请求是重复的</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">firstSet</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">    (RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(KEY.getBytes(), val.getBytes(), Expiration.milliseconds(expireTime), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isConsiderDup;</span><br><span class="line"><span class="keyword">if</span> (firstSet != <span class="literal">null</span> &amp;&amp; firstSet) &#123;<span class="comment">// 第一次访问</span></span><br><span class="line">    isConsiderDup = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// redis值已存在，认为是重复了</span></span><br><span class="line">    isConsiderDup = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务参数去重"><a href="#业务参数去重" class="headerlink" title="业务参数去重"></a>业务参数去重</h3><p>上面的方案能解决具备唯一请求编号的场景，例如每次写请求之前都是服务端返回一个唯一编号给客户端，客户端带着这个请求号做请求，服务端即可完成去重拦截。但是，很多的场景下，请求并不会带这样的唯一编号！那么我们能否针对请求的参数作为一个请求的标识呢？</p><p>先考虑简单的场景，假设请求参数只有一个字段reqParam，我们可以利用以下标识去判断这个请求是否重复。<strong>用户ID:接口名:请求参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String KEY = &quot;dedup:U=&quot;+userId + &quot;M=&quot; + method + &quot;P=&quot; + reqParam;</span><br></pre></td></tr></table></figure><p>那么当同一个用户访问同一个接口，带着同样的reqParam过来，我们就能定位到他是重复的了。</p><p><strong>计算请求参数的摘要作为参数标识</strong></p><p>假设我们把请求参数（JSON）按KEY做升序排序，排序后拼成一个字符串，作为KEY值呢？但这可能非常的长，所以我们可以考虑对这个字符串求一个MD5作为参数的摘要，以这个摘要去取代reqParam的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String KEY = &quot;dedup:U=&quot;+userId + &quot;M=&quot; + method + &quot;P=&quot; + reqParamMD5;</span><br></pre></td></tr></table></figure><p>注：MD5理论上可能会重复，但是去重通常是短时间窗口内的去重（例如一秒），一个短时间内同一个用户同样的接口能拼出不同的参数导致一样的MD5几乎是不可能的。</p><p><strong>考虑剔除部分时间因子</strong></p><p>上面的问题其实已经是一个很不错的解决方案了，但是实际投入使用的时候可能发现有些问题：某些请求用户短时间内重复的点击了（例如1000毫秒发送了三次请求），但绕过了上面的去重判断（不同的KEY值）。</p><p>原因是这些请求参数的字段里面，<strong>是带时间字段的</strong>，这个字段标记用户请求的时间，服务端可以借此丢弃掉一些老的请求（例如5秒前）。如下面的例子，请求的其他参数是一样的，除了请求时间相差了一秒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//两个请求一样，但是请求时间差一秒</span><br><span class="line">String req = &quot;&#123;\n&quot; +</span><br><span class="line">    &quot;\&quot;requestTime\&quot; :\&quot;20190101120001\&quot;,\n&quot; +</span><br><span class="line">    &quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot; +</span><br><span class="line">    &quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot; +</span><br><span class="line">    &quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">String req2 = &quot;&#123;\n&quot; +</span><br><span class="line">    &quot;\&quot;requestTime\&quot; :\&quot;20190101120002\&quot;,\n&quot; +</span><br><span class="line">    &quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot; +</span><br><span class="line">    &quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot; +</span><br><span class="line">    &quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>这种请求，我们也很可能需要挡住后面的重复请求。所以求业务参数摘要之前，需要剔除这类时间字段。还有类似的字段可能是GPS的经纬度字段（重复请求间可能有极小的差别）。</p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqDedupHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reqJSON 请求的参数，这里通常是JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excludeKeys 请求参数里面要去除哪些字段再求摘要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去除参数的MD5摘要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dedupParamMD5</span><span class="params">(<span class="keyword">final</span> String reqJSON, String... excludeKeys)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">decreptParam</span> <span class="operator">=</span> reqJSON;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">paramTreeMap</span> <span class="operator">=</span> JSON.parseObject(decreptParam, TreeMap.class);</span><br><span class="line">        <span class="keyword">if</span> (excludeKeys!=<span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; dedupExcludeKeys = Arrays.asList(excludeKeys);</span><br><span class="line">            <span class="keyword">if</span> (!dedupExcludeKeys.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dedupExcludeKey : dedupExcludeKeys) &#123;</span><br><span class="line">                    paramTreeMap.remove(dedupExcludeKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">paramTreeMapJSON</span> <span class="operator">=</span> JSON.toJSONString(paramTreeMap);</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5deDupParam</span> <span class="operator">=</span> jdkMD5(paramTreeMapJSON);</span><br><span class="line">        log.debug(<span class="string">&quot;md5deDupParam = &#123;&#125;, excludeKeys = &#123;&#125; &#123;&#125;&quot;</span>, md5deDupParam, Arrays.deepToString(excludeKeys), paramTreeMapJSON);</span><br><span class="line">        <span class="keyword">return</span> md5deDupParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">jdkMD5</span><span class="params">(String src)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] mdBytes = messageDigest.digest(src.getBytes());</span><br><span class="line">            res = DatatypeConverter.printHexBinary(mdBytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//两个请求一样，但是请求时间差一秒</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120001\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">req2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120002\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全参数比对，所以两个参数MD5不同</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD52</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req2);</span><br><span class="line">    System.out.println(<span class="string">&quot;req1MD5 = &quot;</span>+ dedupMD5+<span class="string">&quot; , req2MD5=&quot;</span>+dedupMD52);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除时间参数比对，MD5相同</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD53</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req,<span class="string">&quot;requestTime&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD54</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req2,<span class="string">&quot;requestTime&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;req1MD5 = &quot;</span>+ dedupMD53+<span class="string">&quot; , req2MD5=&quot;</span>+dedupMD54);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req1MD5 = 9E054D36439EBDD0604C5E65EB5C8267 , req2MD5=A2D20BAC78551C4CA09BEF97FE468A3F</span><br><span class="line">req1MD5 = C2A36FED15128E9E878583CAAAFEFDE9 , req2MD5=C2A36FED15128E9E878583CAAAFEFDE9</span><br></pre></td></tr></table></figure><p>日志说明：</p><ul><li>一开始两个参数由于requestTime是不同的，所以求去重参数摘要的时候可以发现两个值是不一样的</li><li>第二次调用的时候，去除了requestTime再求摘要（第二个参数中传入了”requestTime”），则发现两个摘要是一样的，符合预期。</li></ul><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String userId= <span class="string">&quot;12345678&quot;</span>;<span class="comment">//用户</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;pay&quot;</span>;<span class="comment">//接口名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dedupMD5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req,<span class="string">&quot;requestTime&quot;</span>);<span class="comment">//计算请求参数摘要，其中剔除里面请求时间的干扰</span></span><br><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;dedup:U=&quot;</span> + userId + <span class="string">&quot;M=&quot;</span> + method + <span class="string">&quot;P=&quot;</span> + dedupMD5;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span>  <span class="number">1000</span>;<span class="comment">// 1000毫秒过期，1000ms内的重复请求会认为重复</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="string">&quot;expireAt@&quot;</span> + expireAt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span>直接SETNX不支持带过期时间，所以设置+过期不是原子操作，极端情况下可能设置了就不过期了，后面相同请求可能会误以为需要去重，所以这里使用底层API，保证SETNX+过期时间是原子操作</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">firstSet</span> <span class="operator">=</span> stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(KEY.getBytes(), val.getBytes(), Expiration.milliseconds(expireTime),</span><br><span class="line">        RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isConsiderDup;</span><br><span class="line"><span class="keyword">if</span> (firstSet != <span class="literal">null</span> &amp;&amp; firstSet) &#123;</span><br><span class="line">    isConsiderDup = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isConsiderDup = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK中定时器</title>
      <link href="/2023/11/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JDK%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/11/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JDK%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>jdk中能够实现定时器功能的大致有三种方式：</p><ul><li>java.util.Timer</li><li>java.util.concurrent.DelayQueue</li><li>java.util.concurrent.ScheduledThreadPoolExecutor</li></ul><span id="more"></span><h3 id="java-util-Timer"><a href="#java-util-Timer" class="headerlink" title="java.util.Timer"></a><strong>java.util.Timer</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安排指定的任务task在指定的时间firstTime开始进行重复的固定速率period执行</span></span><br><span class="line"><span class="comment"> * 每天中午12点都执行一次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">12</span>);<span class="comment">//控制小时</span></span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">0</span>);<span class="comment">//控制分钟</span></span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);<span class="comment">//控制秒</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();<span class="comment">//执行任务时间为12:00:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时12:00执行操作，每隔2秒执行一次</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;执行任务。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time, <span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该任务在12点开始执行，并且每隔2秒执行一次。</p><p>顺手牵羊：查看源码时，无意发现Timer中有schedule与scheduleAtFixedRate，它俩都可以到约定时间按照指定时间间隔执行。然而它俩的区别是什么呢？官方解释：一个是Fixed-delay，一个是Fixed-rate。那么这两个词到底是什么意思呢？把demo中的代码运行一遍,然后把schedule换成scheduleAtFixedRate，就全部了然了。</p><p>示例代码中较为简洁，能看出控制执行时间的方法应该是 timer.schedule()，跟进去看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="type">long</span> period)</span> &#123;        </span><br><span class="line"><span class="keyword">if</span> (period &lt;= <span class="number">0</span>)            </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Non-positive period.&quot;</span>);        </span><br><span class="line">sched(task, firstTime.getTime(), -period);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>task 表示要执行的任务逻辑</li><li>firstTime 表示第一次执行的时间</li><li>period 表示每次间隔时间</li></ul><p>继续跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sched</span><span class="params">(TimerTask task, <span class="type">long</span> time, <span class="type">long</span> period)</span> &#123;        </span><br><span class="line"><span class="comment">//省略非重点代码        </span></span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;            </span><br><span class="line"><span class="keyword">if</span> (!thread.newTasksMayBeScheduled)                </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Timer already cancelled.&quot;</span>);            <span class="keyword">synchronized</span>(task.lock) &#123;                </span><br><span class="line"><span class="keyword">if</span> (task.state != TimerTask.VIRGIN)                    </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Task already scheduled or cancelled&quot;</span>);              </span><br><span class="line">task.nextExecutionTime = time;                </span><br><span class="line">task.period = period;               </span><br><span class="line">task.state = TimerTask.SCHEDULED;           </span><br><span class="line">&#125;            </span><br><span class="line">queue.add(task);            </span><br><span class="line"><span class="keyword">if</span> (queue.getMin() == task)                </span><br><span class="line">queue.notify();        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实做了两个事情</p><ul><li>给task设定了一些参数，类似于初始化task。</li><li>把初始化后的task加入到queue中。</li></ul><p>进入queu.add(task)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**    * Adds a new task to the priority queue.    */</span>   </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TimerTask task)</span> &#123;       </span><br><span class="line"><span class="comment">// Grow backing store if necessary       </span></span><br><span class="line"><span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)           </span><br><span class="line">queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);       </span><br><span class="line">queue[++size] = task;       </span><br><span class="line">fixUp(size);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注释提到，加入一个新任务到优先级队列中去。其实这里的TimerTask[]是一个优先级队列，使用数组存储方式。并且它的数据结构是heap。包括从fixUp()我们也能看出来，它是在保持堆属性，即堆化(heapify)。</p><p>Timer一共有4个构造方法，看最底层的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name)</span> &#123;        </span><br><span class="line">thread.setName(name);        </span><br><span class="line">thread.start();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里在启动一个thread，那么既然是一个Thread，那肯定就得关注它的 run()方法了。进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        </span><br><span class="line"><span class="keyword">try</span> &#123;            </span><br><span class="line">mainLoop();        </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line"><span class="comment">// Someone killed this Thread, behave as if Timer cancelled            synchronized(queue) &#123;                </span></span><br><span class="line">newTasksMayBeScheduled = <span class="literal">false</span>;                </span><br><span class="line">queue.clear();  </span><br><span class="line"><span class="comment">// Eliminate obsolete references            </span></span><br><span class="line">&#125;        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续进入mainLoop()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main timer loop.  (See class comment.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mainLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                <span class="type">boolean</span> taskFired;</span><br><span class="line">                <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                    <span class="comment">//省略</span></span><br><span class="line">                    <span class="type">long</span> currentTime, executionTime；</span><br><span class="line">                    task = queue.getMin();</span><br><span class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        executionTime = task.nextExecutionTime;</span><br><span class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                                queue.removeMin();</span><br><span class="line">                                task.state = TimerTask.EXECUTED;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                                : executionTime + task.period);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn&#x27;t yet fired; wait</span></span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述源码中，可以看出有两个重要的if</p><ul><li>if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime))，表示已经到了执行时间，那么下面执行任务就好了；</li><li>if (!taskFired)，表示未到执行时间，那么等待就好了。那么是如何等待的呢？再仔细一看，原来是调用了Object.wait(long timeout)。</li></ul><p>到这里我们知道了，原来jdk中的定时器是这样实现的啊，等待是使用最简单的Object.wait()实现的啊！</p><h3 id="java-util-concurrent-DelayQueue"><a href="#java-util-concurrent-DelayQueue" class="headerlink" title="java.util.concurrent.DelayQueue"></a><strong>java.util.concurrent.DelayQueue</strong></h3><p>DelayQueue它本质上是一个队列，而这个队列里也只有存放Delayed的子类才有意义，所有定义了DelayTask：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayTask</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;    </span><br><span class="line"><span class="keyword">private</span> <span class="type">Date</span> <span class="variable">startDate</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DelayTask</span><span class="params">(Long delayMillions)</span> &#123;        </span><br><span class="line"><span class="built_in">this</span>.startDate.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime() + delayMillions);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;        </span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getDelay(TimeUnit.NANOSECONDS)  </span><br><span class="line">                 - o.getDelay(TimeUnit.NANOSECONDS);        </span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;            </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;        </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;            </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;        </span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        </span><br><span class="line"><span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> startDate.getTime() - now.getTime();        </span><br><span class="line"><span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        </span><br><span class="line">BlockingQueue&lt;DelayTask&gt; queue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();        </span><br><span class="line"><span class="type">DelayTask</span> <span class="variable">delayTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="number">1000</span> * <span class="number">5L</span>);        </span><br><span class="line">queue.put(delayTask);        </span><br><span class="line"><span class="keyword">while</span> (queue.size()&gt;<span class="number">0</span>)&#123;            </span><br><span class="line">queue.take();        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看main方法，主要做了三件事：</p><ul><li>构造DelayTask，其中的延迟时间是5秒</li><li>将任务放入队列</li><li>从队列中取任务</li></ul><p>DelayQueue跟刚才的Timer.TaskQueue是比较相似的，都是优先级队列，放入元素时，都得堆化(DelayQueue.put()如果元素满了，会阻塞。自行研究)。重点看queue.take()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        </span><br><span class="line"><span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;        </span><br><span class="line">lock.lockInterruptibly();        </span><br><span class="line"><span class="keyword">try</span> &#123;            </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;                </span><br><span class="line"><span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();                </span><br><span class="line"><span class="keyword">if</span> (first == <span class="literal">null</span>)                    </span><br><span class="line">available.await();                </span><br><span class="line"><span class="keyword">else</span> &#123;                    </span><br><span class="line"><span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> first.getDelay(NANOSECONDS);                    </span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)                        </span><br><span class="line"><span class="keyword">return</span> q.poll();                    </span><br><span class="line">first = <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// don&#x27;t retain ref while waiting                    </span></span><br><span class="line"><span class="keyword">if</span> (leader != <span class="literal">null</span>)                        </span><br><span class="line">available.await();                    </span><br><span class="line"><span class="keyword">else</span> &#123;                        </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();                        leader = thisThread;                        </span><br><span class="line"><span class="keyword">try</span> &#123;                            </span><br><span class="line">available.awaitNanos(delay);                        </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;                            </span><br><span class="line"><span class="keyword">if</span> (leader == thisThread)                                </span><br><span class="line">leader = <span class="literal">null</span>;              </span><br><span class="line">            &#125;                   </span><br><span class="line">         &#125;                </span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;        </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">   <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; q.peek() != <span class="literal">null</span>)                </span><br><span class="line">   available.signal();            </span><br><span class="line">   lock.unlock();        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中出现了三次await字眼：</p><ul><li>第一次是当队列为空时，等待；</li><li>第二次等待是因为，发现有任务，没有到执行时间，并且有准备执行的线程(leader)。咱们得讲理吧，既然已经有人在准备执行了，咱们就得等吧。</li><li>第三次是真正延时的地方了，available.awaitNanos(delay),此时也没有别的线程要执行，也就是我将要执行，所有等待剩下的延迟时间即可。</li></ul><p>这里咱们明白了，DelayQueue的等待是通过Condition.await()来实现的。</p><h3 id="java-util-concurrent-ScheduledThreadPoolExecutor"><a href="#java-util-concurrent-ScheduledThreadPoolExecutor" class="headerlink" title="java.util.concurrent.ScheduledThreadPoolExecutor"></a><strong>java.util.concurrent.ScheduledThreadPoolExecutor</strong></h3><p>在创建ScheduledThreadPoolExecutor时，线程池的工作队列使用的是DelayedWorkQueue,它的take()方法，与DelayQueue.take()方法极其相似，也有三个等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jdk中实现定时器一共有两种方式：</p><ol><li>使用Object.wait()</li><li>使用Conditon.await()</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解分布式session</title>
      <link href="/2023/11/25/%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
      <url>/2023/11/25/%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8Fsession/</url>
      
        <content type="html"><![CDATA[<h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><p><strong>cookie和session的区别和联系</strong></p><p>cookie是本地客户端用来存储少量数据信息的，保存在客户端，用户能够很容易的获取，安全性不高，存储的数据量小<br>session是服务器用来存储部分数据信息，保存在服务器，用户不容易获取，安全性高，储存的数据量相对大，存储在服务器，会占用一些服务器资源，但是对于它的优点来说，这个缺点可以忽略了。</p><p><strong>session的应用</strong></p><p>在一次客户端和服务器为之间的会话中，客户端(浏览器)向服务器发送请求，首先cookie会自动携带上次请求存储的数据(JSESSIONID)到服务器，服务器根据请求参数中的JSESSIONID到服务器中的session库中查询是否存在此JSESSIONID的信息，如果存在，那么服务器就知道此用户是谁，如果不存在，就会创建一个JSESSIONID，并在本次请求结束后将JSESSIONID返回给客户端，同时将此JSESSIONID在客户端cookie中进行保存。</p><p>客户端和服务器之间是通过http协议进行通信，但是http协议是无状态的，不同次请求会话是没有任何关联的，但是优点是处理速度快。session是一次浏览器和服务器的交互的会话，当浏览器关闭的时候，会话就结束了，但是会话session还在，默认session是还保留30分钟的。</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>平常做的项目都是在一台应用系统，并且所有的操作都在一台Tomcat服务器上，并不会引发Session共享的问题，所以并不会对我们的系统产生影响，但是当我们部署多个微服务的时候，再搭配Nginx进行负载均衡时，如果不处理分布式Session问题，我们在系统中访问不同功能时就会频繁出现用户登录的操作。</p><span id="more"></span><p><img src="/2023/11/25/%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8Fsession/1.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前提：用户登录功能和图中的商品订单模块、秒杀抢购模块属于单独的微服务模块</span><br></pre></td></tr></table></figure><p>用户登录成功后想要访问图中其他两个模块的功能时，由于Nginx使用默认负载均衡策略（轮询），这时请求会按照时间顺序逐一分发到后端应用上，也就是说用户在Tomcat1上登录成功之后，用户的信息放在Tomcat1的Session里，过了一会，用户想要进行秒杀活动的功能操作，请求又被Nginx分发到了Tomcat2，而这时的Tomcat2上的Session里还没有用户信息，于是就是出现让用户重新登录的情况，在微服务分布式项目中，不同的功能模块必然会被分列成各自的微服务，假设访问一个功能都需要重新登录一次，用户的体验必然会大幅度下降！</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="Session复制"><a href="#Session复制" class="headerlink" title="Session复制"></a>Session复制</h4><p><strong>优点：</strong></p><ul><li>无需修改代码，只需要修改Tomcat配置</li></ul><p><strong>缺点：</strong></p><ul><li>Session同步传输占用内网宽带</li><li>多台Tomcat同步性能指数级下降</li><li>Session占用内存，无法有效水平扩展</li></ul><p>配置：在Tomcat安装目录下的config目录中的server.xml文件中，将注释打开，tomcat必须在同一个网关内，要不然收不到广播，同步不了session。</p><p>在web.xml中开启session复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributable/&gt;</span><br></pre></td></tr></table></figure><h4 id="前端存储"><a href="#前端存储" class="headerlink" title="前端存储"></a>前端存储</h4><p><strong>优点：</strong></p><ul><li>不占用服务器内存</li></ul><p><strong>缺点：</strong></p><ul><li>存在安全风险</li><li>数据大小受cookie限制</li><li>占用外网宽带</li></ul><h4 id="Session粘滞-iphash"><a href="#Session粘滞-iphash" class="headerlink" title="Session粘滞(iphash)"></a>Session粘滞(iphash)</h4><p><strong>优点：</strong></p><ul><li>无需修改代码</li><li>服务端可以水平扩展</li></ul><p><strong>缺点：</strong></p><ul><li>增加新机器，会重新Hash，导致重新登录</li><li>应用重新启动后，需要重新登录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream aaa &#123;</span><br><span class="line">    Ip_hash;</span><br><span class="line">    server 39.105.59.4:8080;</span><br><span class="line">    Server 39.105.59.4:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.wanyingjing.cn;</span><br><span class="line">    #root /usr/local/nginx/html;</span><br><span class="line">    #index index.html index.htm;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:39.105.59.4;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后端集中存储"><a href="#后端集中存储" class="headerlink" title="后端集中存储"></a>后端集中存储</h4><p><strong>优点：</strong></p><ul><li>安全</li><li>容易水平扩展</li></ul><p><strong>缺点：</strong></p><ul><li>增加复杂度，多一次调用（向redis或者单独集中存储服务调用）</li><li>需要修改代码</li></ul><h3 id="Java代码实现解决分布式Session"><a href="#Java代码实现解决分布式Session" class="headerlink" title="Java代码实现解决分布式Session"></a>Java代码实现解决分布式Session</h3><h4 id="SpringSession-Redis解决分布式Session"><a href="#SpringSession-Redis解决分布式Session" class="headerlink" title="SpringSession - Redis解决分布式Session"></a><strong>SpringSession - Redis解决分布式Session</strong></h4><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--commons-pools2 对象池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring session 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加Redis配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Redis配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># 数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 超时时间</span></span><br><span class="line">    <span class="attr">connect-timeout:</span> <span class="string">10000ms</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 最大连接阻塞等待时间 默认 -1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">10000ms</span></span><br><span class="line">        <span class="comment"># 最大空闲时间 默认8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">200</span></span><br><span class="line">        <span class="comment"># 最小空闲连接 默认8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类用配置redis服务器的连接</span></span><br><span class="line"><span class="comment">//maxInactiveIntervalInSeconds为SpringSession的过期时间（单位：秒）</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒号后的值为没有配置文件时，制动装载的默认值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.hostname:localhost&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hostName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.port:6379&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// @Value(&quot;$&#123;redis.password&#125;&quot;)</span></span><br><span class="line">   <span class="comment">// private String password;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JedisConnectionFactory <span class="title function_">connectionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JedisConnectionFactory</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionFactory</span>();</span><br><span class="line">        connection.setPort(port);</span><br><span class="line">        connection.setHostName(hostName);</span><br><span class="line">        <span class="comment">//connection.setPassword(password);</span></span><br><span class="line">        <span class="comment">// connection.setDatabase(0);</span></span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化Session配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Session配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpSessionApplicationInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SessionInitializer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(SessionConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>就是当Web服务器接收到http请求后，当请求进入对应的Filter（利用HttpServletRequestWrapper，实现自己的 getSession()方法，替换掉Servlet容器创建和管理HttpSession的实现。Servlet容器启动时加载）进行过滤，将原本需要由web服务器创建会话的过程转交给Spring-Session进行创建，本来创建的会话保存在Web服务器内存中，通过Spring-Session创建的会话信息可以保存第三方的服务中，如：redis,mysql等。Web服务器之间通过连接第三方服务来共享数据，实现Session共享！</p><h4 id="使用mysql数据库存储session"><a href="#使用mysql数据库存储session" class="headerlink" title="使用mysql数据库存储session"></a>使用mysql数据库存储session</h4><p>既然每个服务器都需要使用同一个session，那么我们可以将session存放在同一个数据库里面，每次访问的时候，我们去数据库check一下是否有这个session或者这个session是否过期，然后就可以进行多台服务器的session同步了；</p><p>优点：使用这种方法简单、方便，很容易上手操作；</p><p>缺点：使用数据库来同步session，会加大数据库的IO，增加数据库的负担；同时，每次访问都需要拦截请求、查询数据库，导致多一层访问的业务层以及浪费读取数据库session时间；</p><h3 id="使用token代替session"><a href="#使用token代替session" class="headerlink" title="使用token代替session"></a>使用token代替session</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般会将web容器所在的服务器和redis所在的服务器放在同一个机房，减少网络开销，走内网进行连接。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何停止一个正在运行的线程</title>
      <link href="/2023/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以用Thread.stop()方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且是已被废弃的方法。</p><span id="more"></span><p>在java中有以下3种方法可以终止正在运行的线程：</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ul><h2 id="停止不了的线程"><a href="#停止不了的线程" class="headerlink" title="停止不了的线程"></a>停止不了的线程</h2><p>interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断线程是否停止状态"><a href="#判断线程是否停止状态" class="headerlink" title="判断线程是否停止状态"></a>判断线程是否停止状态</h2><p>Thread类中提供了两种方法：</p><ul><li><p>this.interrupted(): 测试当前线程是否已经中断；</p><p>判断出当前线程是否是停止状态，线程的中断状态由该方法清除。</p></li><li><p>this.isInterrupted(): 测试线程是否已经中断；</p><p>获取线程终止状态</p></li></ul><h2 id="停止的线程–异常法"><a href="#停止的线程–异常法" class="headerlink" title="停止的线程–异常法"></a>停止的线程–异常法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程已经终止， for循环不再执行&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例虽然停止了线程，但如果for语句下面还有语句，还是会继续运行的。</p><p>如何解决语句继续运行的问题呢？看一下更新后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程已经终止， for循环不再执行&quot;</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;这是for循环外面的语句，也会被执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入MyThread.java类中的catch了。。。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程在sleep()状态下停止线程，会是什么效果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始。。。&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：&quot;</span> + <span class="built_in">this</span>.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程开始。。。</span><br><span class="line">在沉睡中被停止, 进入<span class="keyword">catch</span>， 调用isInterrupted()方法的结果是：<span class="literal">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at thread.MyThread.run(MyThread.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>从打印的结果来看， 如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变为false。</p><h2 id="暴力停止"><a href="#暴力停止" class="headerlink" title="暴力停止"></a>暴力停止</h2><p>使用stop()方法停止线程则是非常暴力的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用stop()方法时会抛出java.lang.ThreadDeath异常，但是通常情况下，此异常不需要显示地捕捉。stop()方法以及作废，因为如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(String name, String password)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SynchronizedObject synchronizedObject;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(SynchronizedObject synchronizedObject)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.synchronizedObject = synchronizedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        synchronizedObject.printString(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedObject</span> <span class="variable">synchronizedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObject</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(synchronizedObject);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        System.out.println(synchronizedObject.getName() + <span class="string">&quot;  &quot;</span> + synchronizedObject.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b  aa</span><br></pre></td></tr></table></figure><p>由于stop()方法以及在JDK中被标明为“过期&#x2F;作废”的方法，显然它在功能上具有缺陷，所以不建议在程序张使用stop()方法。</p><h2 id="使用return停止线程"><a href="#使用return停止线程" class="headerlink" title="使用return停止线程"></a>使用return停止线程</h2><p>将方法interrupt()与return结合使用也能实现停止线程的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程被停止了！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Time: 1467072288503</span><br><span class="line">Time: 1467072288503</span><br><span class="line">Time: 1467072288503</span><br><span class="line">线程被停止了！</span><br></pre></td></tr></table></figure><p>建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread.isInterrupted()与Thread.interrupted()的区别</title>
      <link href="/2023/11/18/thread-isInterrupted-%E4%B8%8EThread-interrupted-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/18/thread-isInterrupted-%E4%B8%8EThread-interrupted-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>因为 thread.interrupted()相当于给线程发送了一个唤醒的信号，所以如果线程此时恰好处于WAITING或者TIMED_WAITING状态，就会抛出一个InterruptedException，并且线程被唤醒。而如果线程此时并没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其他线程发来的中断信号，然后做一些对应的处理。</p><span id="more"></span><p>这两个方法都是线程用来判断自己是否收到过中断信号的，前者是实例方法，后者是静态方法。二<br>者的区别在于，前者只是读取中断状态，不修改状态；后者不仅读取中断状态，还会重置中断标志位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="built_in">this</span>.isInterrupted();</span><br><span class="line">            System.out.println(<span class="string">&quot;中断标记：&quot;</span> + i + <span class="string">&quot;============&quot;</span> + interrupted);</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted() &amp;&amp; i &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;重置中断标记：&quot;</span> + Thread.interrupted());</span><br><span class="line">                System.out.println(<span class="string">&quot;重置后中断标记：&quot;</span> + <span class="built_in">this</span>.isInterrupted());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        myThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main中断状态检查-1：&quot;</span> + myThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;main中断状态检查-2：&quot;</span> + myThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/18/thread-isInterrupted-%E4%B8%8EThread-interrupted-%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="image-20231118170604057"></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select for update加锁</title>
      <link href="/2023/11/16/MySQL/select-for-update%E5%8A%A0%E9%94%81/"/>
      <url>/2023/11/16/MySQL/select-for-update%E5%8A%A0%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在MySQL中，事务A中使用select…for update where id&#x3D;1锁住了，某一条数据，事务还没提交，</p><p>此时，事务B中去用select … where id&#x3D;1查询那条数据，会阻塞等待吗？</p><span id="more"></span><p>select…for update在MySQL中，是一种悲观锁的用法，一般情况下，会锁住一行数据，但如果没有使用正确的话，也会把整张表锁住，导致SQL性能急剧下降。</p><h3 id="为什么要用行锁"><a href="#为什么要用行锁" class="headerlink" title="为什么要用行锁"></a>为什么要用行锁</h3><p>假如现在有这样一种业务场景：用户A给你转账了2000元，此时刚好，用户B也给你转账了3000元，而你的账户初始化金额是1000元。</p><p>用户A的请求，先查询出money，然后给money加上2000，在事务1中会执行下面这条sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update account set money=#&#123;money&#125; where id=123;</span><br></pre></td></tr></table></figure><p>同时，用户B的请求，也是先查询出money，然后给money加上3000，在事务2中执行下面这条sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update account set money=#&#123;money&#125; where id=123;</span><br></pre></td></tr></table></figure><p>这两条sql执行成功之后，你的money可能是：3000、4000、6000，这三种情况中的一种。</p><p>理想结果，用户A和用户B总共给你转账5000，最终你账户的钱应该是6000才对，3000和4000是怎么来的？</p><p>假如事务1在执行update语句的过程中，事务2同时也在执行update语句。</p><p>事务1中查询到money是1000，此外事务2也查询到money是1000。</p><p>如果事务1先执行update语句，事务2后执行update语句，第一次update的3000，会被后面的4000覆盖掉，最终结果为4000。</p><p>如果事务2先执行update语句，事务1后执行update语句，第一次update的4000，会被后面的3000覆盖掉，最终结果为3000。</p><p>这两种情况都产生了严重的数据问题。我们需要有某种机制，保证计算金额后事务1和事务2要顺序执行，不要一起执行。</p><p>这就需要<code>加锁了</code>。</p><p>目前MySQL中使用比较多的有：表锁、行锁和间隙锁。</p><p>我们这个业务场景，非常适合使用<code>行锁</code>。</p><p>在事务1执行update语句的过程中，先要把某一行数据锁住，此时，其他的事务必须等待事务1执行完，提交了事务，才能获取那一行的数据。在MySQL中是通过select…for update语句来实现的行锁的功能。但如果你在实际工作中使用不正确，也容易把整张表锁住，严重影响性能。</p><p>select…where…for update语句的用法是否正确，跟where条件中的参数有很大的关系。</p><ol><li>主键字段：加行锁。</li><li>唯一索引字段：加行锁。</li><li>普通索引字段：加间隙锁。</li><li>主键范围：加多个行锁。</li><li>唯一索引范围，加多个行锁。</li><li>普通字段：加间隙锁，看着像表锁。。</li><li>查询空数据：加间隙锁。</li></ol><p>如果事务1加了行锁，一直没有释放锁，事务2操作相同行的数据时，会一直等待直到超时。</p><p>如果事务1加了表锁，一直没有释放锁，事务2不管操作的是哪一行数据，都会一直等待直到超时。</p><p>注意：for update关键字是加在select语句中的，它从查到那行数据开始，直到事务提交，整个过程中都会加锁。</p><p>而直接执行update语句，是在更新数据的时候加锁，二者有本质的区别。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者和消费者模型</title>
      <link href="/2023/11/15/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/11/15/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在 Java 多线程编程中，还有一个非常重要的设计模式，它就是：生产者和消费者模型。</p><p>这种模型可以充分发挥 cpu 的多线程特性，通过一些平衡手段能有效的提升系统整体处理数据的速度，减轻系统负载，提高程序的效率和稳定性，同时实现模块之间的解耦。</p><span id="more"></span><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>简单的说，生产者和消费者之间不直接进行交互，而是通过一个缓冲区来进行交互，生产者负责生成数据，然后存入缓冲区；消费者则负责处理数据，从缓冲区获取。</p><p><img src="/2023/11/15/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/1.png" alt="图片"></p><p>对于最简单的生产者和消费者模型，总结下来，大概有以下几个特点：</p><ul><li>缓冲区为空的时候，消费者不能消费，会进入休眠状态，直到有新数据进入缓冲区，再次被唤醒</li><li>缓冲区填满的时候，生产者不能生产，也会进入休眠状态，直到缓冲区有空间，再次被唤醒</li></ul><p>生产者和消费者模型作为一个非常重要的设计模型，它的优点在于：</p><ul><li>解耦：生产者和消费者之间不直接进行交互，即使生产者和消费者的代码发生变化，也不会对对方产生影响</li><li>消峰：例如在某项工作中，假如 A 操作生产数据的速度很快，B 操作处理速度很慢，那么 A 操作就必须等待 B 操作完成才能结束，反之亦然。如果将 A 操作和B 操作进行解耦，中间插入一个缓冲区，这样 A 操作将生产的数据存入缓冲区，就接受了；B 操作从缓冲区获取数据并进行处理，平衡好 A 操作和 B 操作之间的缓冲区，可以显著提升系统的数据处理能力。</li></ul><p>生产者和消费者模型的应用场景非常多，例如 Java 的线程池任务执行框架、消息中间件 rabbitMQ 等，因此掌握生产者和消费者模型，对于开发者至关重要。</p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><h4 id="利用-wait-notify-方法实现思路"><a href="#利用-wait-notify-方法实现思路" class="headerlink" title="利用 wait &#x2F; notify 方法实现思路"></a>利用 wait &#x2F; notify 方法实现思路</h4><p>最简单的一种技术实践方案就是基于线程的 wait() &#x2F; notify() 方法，也就是通知和唤醒机制，可以将两个操作实现解耦，具体代码实践如下</p><p>缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区容器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据到缓冲区</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() &gt;= capacity)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区已满,生产者进入waiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，add：&quot;</span> + value);</span><br><span class="line">        list.add(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他所有处于wait()的线程，包括消费者和生产者</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓冲区获取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区为空,消费者进入waiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从头部获取数据，并移除元素</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，value：&quot;</span> + val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他所有处于wait()的线程，包括消费者和生产者</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            container.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            container.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Container</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(container);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(container);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者线程生产一批数据之后，当缓冲区已经满了，会进入等待状态，此时会通知消费者线程；消费者线程处理完数据之后，当缓冲区没有数据时，也会进入等待状态，再次通知生产者线程。</p><h4 id="利用-await-signal-方法实现思路"><a href="#利用-await-signal-方法实现思路" class="headerlink" title="利用 await &#x2F; signal 方法实现思路"></a>利用 await &#x2F; signal 方法实现思路</h4><p>利用<code>ReentrantLock</code>和<code>Condition</code>类中的 await() &#x2F; signal() 方法实现生产者和消费者模型。</p><p>缓冲区:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区容器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据到缓冲区</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(list.size() &gt;= capacity)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区已满,生产者进入waiting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，add：&quot;</span> + value);</span><br><span class="line">            list.add(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//唤醒其他所有处于wait()的线程，包括消费者和生产者</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓冲区获取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区为空,消费者进入waiting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从头部获取数据，并移除元素</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，value：&quot;</span> + val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//唤醒其他所有处于wait()的线程，包括消费者和生产者</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者、消费者、测试类代码，跟上文一致。</p><h4 id="多生产者和消费者的实现思路"><a href="#多生产者和消费者的实现思路" class="headerlink" title="多生产者和消费者的实现思路"></a>多生产者和消费者的实现思路</h4><p>上面介绍的都是一个生产者线程和一个消费者线程，模型比较简单。实际上，在业务开发中，经常会出现多个生产者线程和多个消费者线程，按照以上的实现思路，会出现什么情况呢？</p><p>有可能会出现程序假死现象！下面我们来分析一下案例，假如有两个生产者线程 a1、a2，两个消费者线程 b1、b2，执行过程如下：</p><ul><li>1.生产者线程 a1 执行生产数据的操作，发现缓冲区数据已经填满了，然后进入等待阶段，同时向外发起通知，唤醒其它线程</li><li>2.因为线程唤醒具有随机性，本应该唤醒消费者线程 b1，结果可能生产者线程 a2 被唤醒，检查缓冲区数据已经填满了，又进入等待阶段，紧接向外发起通知，消费者线程得不到被执行的机会</li><li>3.消费者线程 b1、b2，也有可能会出现这个现象，本应该唤醒生产者线程，结果唤醒了消费者线程</li></ul><p>遇到这种情况，应该如何解决呢？</p><p>因为<code>ReentrantLock</code>和<code>Condition</code>的结合，编程具有高度灵活性，我们可以采用这种组合解决多生产者和多消费者中的假死问题。</p><p>多生产者多消费者模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区容器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据到缓冲区</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(list.size() &gt;= capacity)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区已满,生产者进入waiting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 生产者进入等待状态</span></span><br><span class="line">                producerCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，add：&quot;</span> + value);</span><br><span class="line">            list.add(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒所有消费者处于wait()的线程</span></span><br><span class="line">            consumerCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓冲区获取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，缓冲区为空,消费者进入waiting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 消费者进入等待状态</span></span><br><span class="line">                consumerCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从头部获取数据，并移除元素</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者：&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;，value：&quot;</span> + val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒所有生产者处于wait()的线程</span></span><br><span class="line">            producerCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ContainerDemo container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(ContainerDemo container, Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        container.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ContainerDemo container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(ContainerDemo container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        container.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ContainerDemo</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerDemo</span>();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化6个生产者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            threadList.add(<span class="keyword">new</span> <span class="title class_">Producer</span>(container, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化6个消费者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            threadList.add(<span class="keyword">new</span> <span class="title class_">Consumer</span>(container));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ReentrantLock</code>定义两个<code>Condition</code>，一个表示生产者的<code>Condition</code>，一个表示消费者的<code>Condition</code>，唤醒的时候调用对应的<code>signalAll()</code>方法就可以解决假死现象。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者和消费者 </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发下的抽奖优化</title>
      <link href="/2023/11/12/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8A%BD%E5%A5%96%E4%BC%98%E5%8C%96/"/>
      <url>/2023/11/12/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8A%BD%E5%A5%96%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="项目思考"><a href="#项目思考" class="headerlink" title="项目思考"></a>项目思考</h3><p>由于项目发起了一个抽奖活动，发起活动之前给所有用户发短信提示他们购买了我们的产品有抽奖权益。然后用户上来进入抽奖页面点击爆增，过了一会儿页面就打不开了。后面查看了下各种日志，发现了瓶颈在数据库，由于读写冲突严重，导致响应变慢，有不少连接都超时了。后面看到监控和日志留下的数据，发现负责抽奖的微服务集群qps暴涨12倍，db的qps也涨了10倍。这很明显是一个高并发下如何摆脱数据库读写，I&#x2F;O瓶颈的问题。</p><span id="more"></span><p>整点开抢后瞬时巨量的请求同时涌入，即使我们Nginx端做过初步限流，整个业务逻辑校验阶段运作良好，但是系统的瓶颈就转移到其他环节：大量的读写请求，导致后面的请求全部排队等待，等前面一个update完成释放行锁后才能处理下一个请求，大量请求等待，占用了数据库的连接。一旦数据库同一时间片内的连接数被打满，就会导致这个时间片内其他后来的全部请求因拿不到连接而超时，导致访问此数据库的其他环节也出现问题，所以RT就会异常飙高。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>借鉴网上的一些通用思路，能采用的有效措施主要是:降级，限流，缓存，消息队列。主要原则是:尽量不暴露db,把大部分请求在服务的系统上层处理了。</p><h3 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h3><h4 id="抽奖详情页"><a href="#抽奖详情页" class="headerlink" title="抽奖详情页"></a>抽奖详情页</h4><p><strong>a. 线上开启缓存</strong></p><p>线上已写缓存逻辑，但是没有用switch开启。开启后可以减少数据库的并发IO压力，减少锁冲突。</p><p><strong>b. 关于本地缓存淘汰策略的细节处理</strong></p><p>缓存超过或等于限制大小全部清空。建议等于时不清空，而使用缓存淘汰算法:比如LRU,LFU,NRU等,这样不会出现缓存过大清空后，从数据库更新数据到缓存，缓存里数据依旧很大。导致缓存清空频率过高，反而降低系统的吞吐量。例如guava cache中的参数是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置缓存容器的初始容量为10</span><br><span class="line">initialCapacity(10)</span><br><span class="line">//设置缓存最大容量为100，超过100之后就会按照LRU最近虽少使用算法来移除缓存项</span><br><span class="line">maximumSize(100)</span><br></pre></td></tr></table></figure><h4 id="抽奖逻辑"><a href="#抽奖逻辑" class="headerlink" title="抽奖逻辑"></a>抽奖逻辑</h4><p><strong>a.队列削峰</strong></p><p>用额外的单进程处理一个队列，下单请求放到队列里，一个个处理，就不会有qps的高并发问题了。场景中抽奖用户会在到点的时间涌入，DB瞬间就接受暴击压力，hold不住就会宕机，然后影响整个业务。队列的长度保持固定，对于如果请求排队在队伍中靠后，比如奖品100个的情况下，中奖率10%，队列里请求任务超过1000时，就直接将后续的抽奖请求返回不中奖。用tair记录排队数，如果奖品没发完，再请空tair,允许请求继续入队列。这样队列起到了降级和削峰的作用。</p><p><strong>b.将事务和行级悲观锁改成乐观锁</strong></p><p>原来的代码是通过悲观锁来控制超发的情况。（比如一共有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。）</p><p>在原来的代码中用的是for update行锁，在高并发的情况下会很多这样的修改请求，每个请求都需要等待锁，某些线程可能永远都没有机会抢到这个锁，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。</p><p>可以采用乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。</p><p><strong>c.对于与抽奖无直接关系的流程采用异步</strong></p><p>比如抽奖成功之后的发短信功能另起一个线程池专门处理。这样可以提高请求的处理速率，提高qps上升后的乘载能力。</p><p><strong>d.数据库的读写分离</strong></p><p>现在的数据库查询都是读的主库。将数据库的大量查询改为从库，减轻主库的读写压力。主服务器进行写操作时，不影响查询应用服务器的查询性能，降低阻塞，提高并发。</p><p><strong>e.同一时间片内，采用信号量机制</strong></p><p>确保进来的人数不会过多导致系统响应超时： 信号量的采用，能够使得抽奖高峰期内，同一时间片内不会进入过多的用户，从底层实现上规避了系统处理大数据量的风险。这个可以配合队列进行限流处理。</p><p><strong>f. 消息存储机制</strong></p><p>将数据请求先添加到信息队列中（比如Tair存储的数据结构中），然后再写工具启动定时任务从Tair中取出数据去入库，这样对于db的并发度大大降低到了定时任务的频率。但是问题可能会出在保持数据的一致性和完整性上。</p><p><strong>g.必要时候采用限流降级的测流</strong></p><p>当并发过多时为了保证系统整体可用性，抛弃一些请求。对于被限流的请求视为抽不到奖。</p><h4 id="额外考虑"><a href="#额外考虑" class="headerlink" title="额外考虑"></a>额外考虑</h4><p><strong>a.防止黑客刷奖</strong></p><p>防止黑客恶意攻击（比如cc攻击）导致qps过高，可以考虑策略在服务入口为相同uid的账户请求限制每秒钟的最高访问数。</p><p><strong>b. 中奖数据预热</strong></p><p>中奖只是少数，大部分人并不会中奖，所以可以在第一步便限制只有少数用户的请求能够打到真正抽奖逻辑上。是否可以考虑在抽奖之前先用随机算法生成一批中奖候选人。然后当用户请求过来时如果其中绝大多数请求都非中奖候选人，则直接返回抽奖失败，不走抽奖拿奖品的流程。少部分用户请求是中奖候选人，则进入队列，排在队列前面的获得奖品，发完为止，先到先得。</p><p>举个例子：10万个用户抽奖，奖品100个，先随机选出中奖候选人500个。用户请求过来时，不走抽奖查库逻辑的用户过滤掉99500个，剩余的候选人的请求用队列处理,先到先得。这样可以把绝大多数的请求拦截在服务上游不用查库，但是缺点是不能保证奖品一定会被抽完（可能抽奖候选人只有不到100人参与抽奖）。</p><p><strong>四.设计架构图</strong></p><p><img src="/2023/11/12/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8A%BD%E5%A5%96%E4%BC%98%E5%8C%96/1.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合对象排序</title>
      <link href="/2023/11/12/java%E5%9F%BA%E7%A1%80/java%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/12/java%E5%9F%BA%E7%A1%80/java%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>总结下JDK中常用排序的方法，包括JDK8中强大的lambda表达式及函数式接口运用。</p><span id="more"></span><p>初始化集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisa&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">11</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;john&quot;</span>, <span class="number">16</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jennis&quot;</span>, <span class="number">26</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tin&quot;</span>, <span class="number">26</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;army&quot;</span>, <span class="number">26</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;mack&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jobs&quot;</span>, <span class="number">65</span>));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collections.sort</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>lambda排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.sort((User u1, User u2) -&gt; u1.getAge().compareTo(u2.getAge()));</span><br><span class="line"></span><br><span class="line">list.sort((u1, u2) -&gt; u1.getAge().compareTo(u2.getAge()));</span><br></pre></td></tr></table></figure><p>jdk8 排序，User类静态方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(User::compareAge);</span><br></pre></td></tr></table></figure><p>jdk8 升序排序，Comparator提供的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparing(User::getAge));</span><br></pre></td></tr></table></figure><p> jdk8 降序排序，Comparator提供的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparing(User::getAge).reversed());</span><br></pre></td></tr></table></figure><p> jdk8 组合排序，Comparator提供的静态方法，先按年纪排序，年纪相同的按名称排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparing(User::getAge).thenComparing(User::getName));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optional应用</title>
      <link href="/2023/11/12/java%E5%9F%BA%E7%A1%80/Optional%E5%BA%94%E7%94%A8/"/>
      <url>/2023/11/12/java%E5%9F%BA%E7%A1%80/Optional%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Optional 有两个含义: 存在 or 缺省。</p><span id="more"></span><p>定义接口返回值，避免空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title function_">getOptional</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(userRepository.selectByPrimaryKey(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象转化，当被转化bean可能为空时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">shouldConvertDTO</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">PersonDTO</span> <span class="variable">personDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonDTO</span>();</span><br><span class="line">Optional.ofNullable(getPerson()).ifPresent(person -&gt; &#123;</span><br><span class="line">      personDTO.setDtoAge(person.getAge());</span><br><span class="line">      personDTO.setDtoName(person.getName());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Person <span class="title function_">getPerson</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只对控制的存在判断，我建议使用 Optional.</p><p>getter中的使用</p><p>对于一个 java bean, 所有的属性都有可能返回 null, 那是否需要改写所有的 getter 成为 Optional 类型呢？</p><p>不要这样滥用 Optional.</p><p>即便 java bean 中的 getter 是符合 Optional 的，但是因为 java bean 太多了，这样会导致你的代码有 50% 以上进行 Optinal 的判断，这样便污染了代码。我们应该更关注于业务，而不只是空值的判断。</p><p>可以这样总结 Optional 的使用：</p><ol><li>当使用值为空的情况，并非源于错误时，可以使用 Optional!</li><li>Optional 不要用于集合操作!</li><li>不要滥用 Optional, 比如在 java bean 的 getter 中!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>计数排序（Counting Sort）是一种针对于特定范围之间的整数进行排序的算法。它通过统计给定数组中不同元素的数量（类似于哈希映射），然后对映射后的数组进行排序输出即可。</p><span id="more"></span><p>我们以数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 为例进行说明。</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/1.png" alt="图片"></p><p>第一步：建立一个初始化为 <strong>0</strong> ，长度为 <strong>9</strong> (原始数组中的最大值 <strong>8</strong> 加 <strong>1</strong>) 的数组 <strong><code>count[]</code></strong> :</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/2.png" alt="图片"></p><p>第二步：遍历数组  <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> ，访问第一个元素 <strong>1</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>1</strong> 的元素加 1，表示当前 <strong>1</strong> 出现了一次，即 <strong><code>count[1] = 1</code></strong> ;</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/3.png" alt="图片"></p><p>第三步：访问数组  <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第二个元素 <strong>4</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>4</strong> 的元素加 <strong>1</strong> ，表示当前访问的元素 <strong>4</strong> 当前出现了 <strong>1</strong> 次，即  <strong><code>count[4] = 1</code></strong> ;</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/4.png" alt="图片"></p><p>第四步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第三个元素 <strong>1</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>1</strong> 的元素加 1，即 <strong><code>count[1] = 2</code></strong> ，表示当前 <strong>1</strong> 出现了 <strong>2</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/5.png" alt="图片"></p><p>第五步：访问数组  <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第四个元素 <strong>2</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>2</strong> 的元素加 1，即 <strong><code>count[2] = 1</code></strong> ，表示当前 <strong>2</strong> 出现了 <strong>1</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/6.png" alt="图片"></p><p>第六步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第五个元素 <strong>5</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>5</strong> 的元素加 1，即 <strong><code>count[5] = 1</code></strong> ，表示当前 <strong>5</strong> 出现了 <strong>1</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/7.png" alt="图片"></p><p>第七步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第六个元素 <strong>2</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>2</strong> 的元素加 1，即 <strong><code>count[2] = 2</code></strong> ，表示当前 <strong>2</strong> 出现了 <strong>2</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8.png" alt="图片"></p><p>第八步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第七个元素 <strong>4</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>4</strong> 的元素加 1，即 <strong><code>count[4] = 2</code></strong> ，表示当前 <strong>4</strong> 出现了 <strong>2</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/9.png" alt="图片"></p><p>第九步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第八个元素 <strong>1</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>1</strong> 的元素加 1，即 <strong><code>count[1] = 3</code></strong> ，表示当前 <strong>1</strong> 出现了 <strong>3</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/10.png" alt="图片"></p><p>第十步：访问数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 的第九个元素 <strong>8</strong> ，然后将数组 <strong><code>count[]</code></strong> 中下标为 <strong>8</strong> 的元素加 1，即 <strong><code>count[8] = 1</code></strong> ，表示当前 <strong>8</strong> 出现了 <strong>1</strong> 次：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/11.png" alt="图片"></p><p>此时遍历数组 <strong><code>[1,4,1,2,5,2,4,1,8]</code></strong> 结束，我们得到了一个 <strong><code>count[]</code></strong> 数组，而只要得到了这个**<code>count[] </code>**数组，我们的排序算法就相当于结束了，接下来的就只是输出了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果不考虑计数排序的稳定性，我们按照数组 <strong><code>count[]</code></strong> 中对应下标的出现次数直接输出即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (count[i] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++)&#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后（考虑稳定性）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>  </span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] arr)</span>  </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Arrays.stream(arr).min().getAsInt(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> count[] = <span class="keyword">new</span> <span class="title class_">int</span>[range]; </span><br><span class="line">        <span class="type">int</span> output[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)  </span><br><span class="line">        &#123; </span><br><span class="line">            count[arr[i] - min]++; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count.length; i++)  </span><br><span class="line">        &#123; </span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </span><br><span class="line">        &#123; </span><br><span class="line">            output[count[arr[i] - min] - <span class="number">1</span>] = arr[i]; </span><br><span class="line">            count[arr[i] - min]--; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            arr[i] = output[i]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span>  </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)  </span><br><span class="line">        &#123; </span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">5</span>,-<span class="number">2</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">8</span>&#125;; </span><br><span class="line">        countSort(arr); </span><br><span class="line">        printArray(arr); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong></p><p>在整个代码实现过程中，我们仅仅出现了一层的 for 循环，没有出现任何 for 循环的嵌套，所以计数排序的时间复杂度为 量级。</p><p><strong>空间复杂度</strong></p><p>由于计数排序过程中，我们使用到了一个 <strong><code>max - min + 1</code></strong> 大小的 <strong>count[]</strong> 数组，所以计数排序的空间复杂度为 量级。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>如果输入数据的范围  <strong><code>range = max - min + 1</code></strong> 不明显大于要待排序数组的长度 **<code>n = arr.length</code>**，则计数排序是相当高效的，比时间复杂度为 的快速和归并排序都优秀。</li><li>计数排序不是基于比较的排序算法，时间复杂度为   ，空间复杂度与数据范围成正比。</li><li>计数排序通常用作另一个排序算法（例如基数排序）的子过程。</li><li>计数排序可以使用部分哈希（partial Hashing）在 的时间内统计数据的频率。</li><li>计数排序适用于负输入。</li><li>计数排序不适用于小数的情况。</li></ol><p><a href="https://mp.weixin.qq.com/s/eIegGzddx4DuqjvKELlAZA">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>基数排序的总体思想就是从待排序数组当中，元素的最低有效位到最高有效位 <strong>逐位</strong> 进行比较排序；此外，基数排序使用计数排序作为一个排序的子过程。</p><span id="more"></span><p>下面我们就以数组  <strong><code>[170, 45, 75, 90, 802, 24, 2, 66]</code></strong>, 数组当中的最大值 <strong>802</strong> 为三位数，所以我们在不足三位的数字前面补 <strong>0</strong> ，即 <strong><code>[170, 045, 075, 090, 802, 024, 002, 066]</code></strong> 方便后续说明基数排序。</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/1.png" alt="图片"></p><p>第一步：按数组当中元素的最低有效位，个位  <strong>[170 ,045 ,075 , 090 ,802 , 024 , 002 , 066 ]</strong> ，进行计数排序：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/2.gif" alt="图片"></p><p>第二步：按数组当中元素的次最低有效位，十位数  <strong>[170, 090, 802, 002, 024, 045, 075, 066]</strong>  ，进行计数排序：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/3.gif" alt="图片"></p><p>第三步：按数组当中元素的最高有效位，百位  <strong>[802,002, 024,045, 066, 170,075,090]</strong> ，进行计数排序：</p><p><img src="/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/4.gif" alt="图片"></p><p>这样我们就完成了基数排序，得到了一个有序数组 <strong>[2, 24, 45, 66, 75, 90, 170, 802]</strong> .</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Radix</span> &#123; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取数组中的最大值 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; mx) </span><br><span class="line">                max = arr[i]; </span><br><span class="line">        <span class="keyword">return</span> max; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计数排序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> exp)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> output[] = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">//输出数组 </span></span><br><span class="line">        <span class="type">int</span> i; </span><br><span class="line">        <span class="type">int</span> count[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; </span><br><span class="line">        Arrays.fill(count,<span class="number">0</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 统计数组中元素第 exp 位的数目</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            count[(arr[i]/exp)%<span class="number">10</span>]++; </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对 count[] 数组进行转</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 进行计数排序 </span></span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        &#123; </span><br><span class="line">            output[count[ (arr[i]/exp)%<span class="number">10</span> ] - <span class="number">1</span>] = arr[i]; </span><br><span class="line">            count[ (arr[i]/exp)%<span class="number">10</span> ]--; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 输出到数组arr[]中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            arr[i] = output[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 基数排序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixsort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Find the maximum number to know number of digits </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getMax(arr, n); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对数组当中的数字按照每一个有效位进行一趟计数排序。 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; m/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)&#123;</span><br><span class="line">            countSort(arr, n, exp);         </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 进行输出</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*Driver function to check for above function*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;; </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length; </span><br><span class="line">        radixsort(arr, n); </span><br><span class="line">        print(arr, n); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>有一个细节需要解释一下，那就是如何从最低位到最高位取每一个数字的该位的值。答案很简单了，就是除 <strong>10</strong> 取余。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong></p><p>设 d表示输入的数组当中最大值的位数（比如 802，3位， ），那么基数排序的时间复杂度就是O(d X (n + b)) ，其中n表示数组的长度，而b则是表示一个数的基础，对十进制而言，b&#x3D;10；</p><p>对于元素的跨度（范围）比较大的数组而言，基数排序的运行时间可能比快速排序要好。但是对于基数排序而言，其渐近时间复杂度中隐含了更高的常量因子，并非完全的线性；而快速排序更有效地利用硬件缓存，提高其效率。此外，基数排序使用计数排序作为子过程，计数排序占用额外的空间来对数组进行排序。</p><p>但是基数排序解决我们最开始所提出的问题，当数据范围在 1 到n^2  时，计数排序的复杂度将变为O(n^2)  量级，而基数排序依旧可以在线性时间进行排序！</p><p><strong>空间复杂度</strong></p><p>计数排序使用了额外的空间进行排序，空间复杂度为 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8流式操作</title>
      <link href="/2023/11/08/java%E5%9F%BA%E7%A1%80/java8%E6%B5%81%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/11/08/java%E5%9F%BA%E7%A1%80/java8%E6%B5%81%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>利用java8新特性，可以用简洁高效的代码来实现一些数据处理。</p><span id="more"></span><p>定义1个Apple对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(Integer id, String name, BigDecimal money, Integer num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向集合添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放apple对象集合</span></span><br><span class="line"> </span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">1</span>,<span class="string">&quot;苹果1&quot;</span>,<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.25&quot;</span>),<span class="number">10</span>);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple12</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">1</span>,<span class="string">&quot;苹果2&quot;</span>,<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.35&quot;</span>),<span class="number">20</span>);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">2</span>,<span class="string">&quot;香蕉&quot;</span>,<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;2.89&quot;</span>),<span class="number">30</span>);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple3</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">3</span>,<span class="string">&quot;荔枝&quot;</span>,<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9.99&quot;</span>),<span class="number">40</span>);</span><br><span class="line"> </span><br><span class="line">appleList.add(apple1);</span><br><span class="line">appleList.add(apple12);</span><br><span class="line">appleList.add(apple2);</span><br><span class="line">appleList.add(apple3);</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>以id分组，将id相同的放在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;</span></span><br><span class="line">Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));</span><br><span class="line"> </span><br><span class="line">&#123;<span class="number">1</span>=[Apple&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;苹果1&#x27;</span>, money=<span class="number">3.25</span>, num=<span class="number">10</span>&#125;, Apple&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;苹果2&#x27;</span>, money=<span class="number">1.35</span>, num=<span class="number">20</span>&#125;], </span><br><span class="line"> <span class="number">2</span>=[Apple&#123;id=<span class="number">2</span>, name=<span class="string">&#x27;香蕉&#x27;</span>, money=<span class="number">2.89</span>, num=<span class="number">30</span>&#125;], <span class="number">3</span>=[Apple&#123;id=<span class="number">3</span>, name=<span class="string">&#x27;荔枝&#x27;</span>, money=<span class="number">9.99</span>, num=<span class="number">40</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h3><p>id为key，apple对象为value:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List -&gt; Map</span></span><br><span class="line"><span class="comment"> * 需要注意的是：</span></span><br><span class="line"><span class="comment"> * toMap 如果集合对象有重复的key，会报错Duplicate key ....</span></span><br><span class="line"><span class="comment"> *  apple1,apple12的id都为1。</span></span><br><span class="line"><span class="comment"> *  可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;Integer, Apple&gt; appleMap = appleList.stream()</span><br><span class="line">    .collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1));</span><br></pre></td></tr></table></figure><h3 id="过滤Filter"><a href="#过滤Filter" class="headerlink" title="过滤Filter"></a>过滤Filter</h3><p>从集合中过滤出来符合条件的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; filterList = appleList.stream()</span><br><span class="line">   .filter(a -&gt; a.getName().equals(<span class="string">&quot;香蕉&quot;</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>将集合中的数据按照某个属性求和:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算 总金额</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">totalMoney</span> <span class="operator">=</span> appleList.stream().map(Apple::getMoney)</span><br><span class="line">.reduce(BigDecimal.ZERO, BigDecimal::add);</span><br><span class="line">System.err.println(<span class="string">&quot;totalMoney:&quot;</span>+totalMoney);  <span class="comment">//totalMoney:17.48</span></span><br></pre></td></tr></table></figure><h3 id="查找流中最大-最小值"><a href="#查找流中最大-最小值" class="headerlink" title="查找流中最大 最小值"></a>查找流中最大 最小值</h3><p>Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; maxDish = Dish.menu.stream().</span><br><span class="line">      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));</span><br><span class="line">maxDish.ifPresent(System.out::println);</span><br><span class="line"> </span><br><span class="line">Optional&lt;Dish&gt; minDish = Dish.menu.stream().</span><br><span class="line">      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));</span><br><span class="line">minDish.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据id去重</span></span><br><span class="line">List&lt;Person&gt; unique = appleList.stream().collect(</span><br><span class="line">                collectingAndThen(</span><br><span class="line">                        toCollection(() -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparingLong(Apple::getId))), ArrayList::<span class="keyword">new</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>下表展示 Collectors 类的静态工厂方法。</p><table><thead><tr><th align="left">工厂方法</th><th align="left">返回类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">toList</td><td align="left"><code>List</code></td><td align="left">把流中所有项目收集到一个 List</td></tr><tr><td align="left">toSet</td><td align="left"><code>Set</code></td><td align="left">把流中所有项目收集到一个 Set，删除重复项</td></tr><tr><td align="left">toCollection</td><td align="left"><code>Collection</code></td><td align="left">把流中所有项目收集到给定的供应源创建的集合<code>menuStream.collect(toCollection(), ArrayList::new)</code></td></tr><tr><td align="left">counting</td><td align="left">Long</td><td align="left">计算流中元素的个数</td></tr><tr><td align="left">sumInt</td><td align="left">Integer</td><td align="left">对流中项目的一个整数属性求和</td></tr><tr><td align="left">averagingInt</td><td align="left">Double</td><td align="left">计算流中项目 Integer 属性的平均值</td></tr><tr><td align="left">summarizingInt</td><td align="left">IntSummaryStatistics</td><td align="left">收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td></tr><tr><td align="left">joining</td><td align="left">String</td><td align="left">连接对流中每个项目调用 toString 方法所生成的字符串<code>collect(joining(&quot;, &quot;))</code></td></tr><tr><td align="left">maxBy</td><td align="left"><code>Optional</code></td><td align="left">一个包裹了流中按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td></tr><tr><td align="left">minBy</td><td align="left"><code>Optional</code></td><td align="left">一个包裹了流中按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td></tr><tr><td align="left">reducing</td><td align="left">归约操作产生的类型</td><td align="left">从一个作为累加器的初始值开始，利用 BinaryOperator 与流 中的元素逐个结合，从而将流归约为单个值<code>累加int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</code></td></tr><tr><td align="left">collectingAndThen</td><td align="left">转换函数返回的类型</td><td align="left">包裹另一个收集器，对其结果应用转换函数<code>int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size))</code></td></tr><tr><td align="left">groupingBy</td><td align="left"><code>Map&gt;</code></td><td align="left">根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td></tr><tr><td align="left">partitioningBy</td><td align="left"><code>Map&gt;</code></td><td align="left">根据对流中每个项目应用谓词的结果来对项目进行分区</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 代码技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot多数据源事务管理</title>
      <link href="/2023/11/07/SpringBoot/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2023/11/07/SpringBoot/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当我们采用多数据源的时候，同时也会出现一个这样的特殊场景：我们希望对 A 数据源的更新和 B 数据源的更新具备事务性。这样的例子很常见，比如：在订单库中创建一条订单记录，同时还需要在商品库中扣减商品库存。如果库存扣减失败，那么我们希望订单创建也能够回滚。如果这两条数据在一个数据库中，那么通过之前介绍的事务管理就能轻松解决了。但是，当这两个操作位于不同的数据库中，那么就无法实现了。</p><span id="more"></span><h2 id="什么是-JTA"><a href="#什么是-JTA" class="headerlink" title="什么是 JTA"></a>什么是 JTA</h2><p>JTA，全称：Java Transaction API。JTA 事务比 JDBC 事务更强大。一个 JTA 事务可以有多个参与者，而一个 JDBC 事务则被限定在一个单一的数据库连接。所以，当我们在同时操作多个数据库的时候，使用 JTA 事务就可以弥补 JDBC 事务的不足。</p><p>在 Spring Boot 2.x 中，整合了这两个 JTA 的实现：</p><ul><li>Atomikos：可以通过引入<code>spring-boot-starter-jta-atomikos</code>依赖来使用</li><li>Bitronix：可以通过引入<code>spring-boot-starter-jta-bitronix</code>依赖来使用</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>这里我们将使用最基础的 JdbcTemplate 来实现数据访问。</p></li><li><p>场景设定：</p></li><li><ul><li>假设我们有两个库，分别为：test1 和 test2</li><li>这两个库中都有一张 User 表，我们希望这两张表中的数据是一致的</li><li>假设这两张表中都已经有一条数据：name&#x3D;aaa，age&#x3D;30；因为这两张表中数据是一致的，所以要 update 的时候，就必须两个库中的 User 表更新时候，要么都成功，要么都失败。</li></ul></li></ol><p>引入pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jta-atomikos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties配置数据源</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.jta.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.xa-properties.url</span>=<span class="string">jdbc:mysql://localhost:3306/test1</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.xa-properties.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.xa-properties.password</span>=<span class="string">12345678</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.xa-data-source-class-name</span>=<span class="string">com.mysql.cj.jdbc.MysqlXADataSource</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.unique-resource-name</span>=<span class="string">test1</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.max-pool-size</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.min-pool-size</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.max-lifetime</span>=<span class="string">20000</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.primary.borrow-connection-timeout</span>=<span class="string">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.xa-properties.url</span>=<span class="string">jdbc:mysql://localhost:3306/test2</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.xa-properties.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.xa-properties.password</span>=<span class="string">12345678</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.xa-data-source-class-name</span>=<span class="string">com.mysql.cj.jdbc.MysqlXADataSource</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.unique-resource-name</span>=<span class="string">test2</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.max-pool-size</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.min-pool-size</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.max-lifetime</span>=<span class="string">20000</span></span><br><span class="line"><span class="attr">spring.jta.atomikos.datasource.secondary.borrow-connection-timeout</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure><p>数据源配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.jta.atomikos.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomikosDataSourceBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.jta.atomikos.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">secondaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomikosDataSourceBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">primaryJdbcTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource primaryDataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(primaryDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">secondaryJdbcTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span> DataSource secondaryDataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(secondaryDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><ol><li><p>创建一个 Service 实现，模拟两种不同的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate primaryJdbcTemplate;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate secondaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestService</span><span class="params">(JdbcTemplate primaryJdbcTemplate, JdbcTemplate secondaryJdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.primaryJdbcTemplate = primaryJdbcTemplate;</span><br><span class="line">        <span class="built_in">this</span>.secondaryJdbcTemplate = secondaryJdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tx</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 修改test1库中的数据</span></span><br><span class="line">        primaryJdbcTemplate.update(<span class="string">&quot;update user set age = ? where name = ?&quot;</span>, <span class="number">30</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改test2库中的数据</span></span><br><span class="line">        secondaryJdbcTemplate.update(<span class="string">&quot;update user set age = ? where name = ?&quot;</span>, <span class="number">30</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tx2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 修改test1库中的数据</span></span><br><span class="line">        primaryJdbcTemplate.update(<span class="string">&quot;update user set age = ? where name = ?&quot;</span>, <span class="number">40</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟：修改test2库之前抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 tx 函数，是两句 update 操作，一般都会成功；而 tx2 函数中，我们人为的制造了一个异常，这个异常是在 test1 库中的数据更新后才产生的，这样就可以测试一下 test1 更新成功，之后是否还能在 JTA 的帮助下实现回滚。</p></li></ol><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Chapter312Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter312ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> JdbcTemplate primaryJdbcTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> JdbcTemplate secondaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 正确更新的情况</span></span><br><span class="line">        testService.tx();</span><br><span class="line">        Assertions.assertEquals(<span class="number">30</span>, primaryJdbcTemplate.queryForObject(<span class="string">&quot;select age from user where name=?&quot;</span>, Integer.class, <span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">        Assertions.assertEquals(<span class="number">30</span>, secondaryJdbcTemplate.queryForObject(<span class="string">&quot;select age from user where name=?&quot;</span>, Integer.class, <span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 更新失败的情况</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testService.tx2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 部分更新失败，test1中的更新应该回滚</span></span><br><span class="line">            Assertions.assertEquals(<span class="number">30</span>, primaryJdbcTemplate.queryForObject(<span class="string">&quot;select age from user where name=?&quot;</span>, Integer.class, <span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">            Assertions.assertEquals(<span class="number">30</span>, secondaryJdbcTemplate.queryForObject(<span class="string">&quot;select age from user where name=?&quot;</span>, Integer.class, <span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个测试用例：</p><ul><li><p>test1：因为没有故意制造的异常，不出意外两个库的 update 都会成功，所以根据 name&#x3D;aaa 去把两个数据查出来，看 age 是否都被更新到了 30。</p></li><li><p>test2：tx2 函数会把 test1 中 name&#x3D;aaa 的用户 age 更新为 40，然后抛出异常，JTA 事务生效的话，会把 age 回滚回 30，所以这里的检查也是两个库的 aaa 用户的 age 应该都为 30，这样就意味着 JTA 事务生效，保证了 test1 和 test2 两个库中的 User 表数据更新一致，没有制造出脏数据。</p></li></ul><p><a href="https://mp.weixin.qq.com/s/-98KaQD4EeCVVDMvXzYFUQ">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
            <tag> JTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆</title>
      <link href="/2023/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>/2023/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>堆，又称为优先队列。虽然名为优先队列，但堆并不是队列。堆和队列是两种不同的数据结构，堆是树态的，队列是线性的。在队列中，我们可以向队列添加元素，取出的时候是按照进入队列的先后顺序取出元素的，先进先出；而在堆中，却不是按照元素添加的先后顺序，而是按照元素的优先级取出元素。</p> <span id="more"></span><p>所以二叉堆是为了找出最大或最小而生的，“大”和“小”并不是传统意义上的小大，而是优先级的高低。二叉堆分为最大堆和最小堆，最大堆的顶点可以看作是优先级最高的也可以看作是优先级最低的，最小堆也是如此。二叉堆是一种完全二叉树，因为完全二叉树的特性普遍使用数组结构是非常好用的，所以性注定了二叉堆的存储形式只能是数组或者动态数组（长度可变）。</p><p>二叉堆最主要的操作是两个，siftUp上浮和siftDown下沉，来保证二叉堆的性质：</p><p> 1.父节点的键值总是优先于任何一个子节点的键值；</p><p> 2.左右子树都是一个二叉堆。</p><p><strong>展示最大堆</strong></p><p><img src="/2023/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/1.jpg" alt="图片"></p><p>用数组存储二叉堆，堆的顶点下标可以从0开始也可以从1开始。看上面图中，以self为参照物，self下标的变量为i：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent(i) = (i - 1) / 2;</span><br><span class="line">leftChild(i) = 2*i+1；</span><br><span class="line">rightChild(i) = leftChild(i) + 1 = 2 * i + 2;</span><br></pre></td></tr></table></figure><p>如果是堆顶下标从1开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent(i) = i/2;</span><br><span class="line">leftChild = 2 *i;</span><br><span class="line">rightChild = 2 *i+1;</span><br></pre></td></tr></table></figure><p><strong>向堆中添加元素siftUp</strong></p><p> 二叉堆的节点添加，是在数组的最末尾插入新节点的，然后进行自下而上调整子节点和父节点，不满足二叉堆性质则交换，直到当前子树满足二叉堆的性质。如果可以为了减少交换次数的话，可以单向复制，使得添加的节点插入到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">25</span>, <span class="number">23</span>, <span class="number">17</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态&quot;</span> + Arrays.toString(array));</span><br><span class="line">    <span class="comment">// siftUp(array);</span></span><br><span class="line">    siftUp2(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆，交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; array[i] &gt; array[parent(i)]; i = parent(i))</span><br><span class="line">        swap(array, i, parent(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向复制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftUp2</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempVal</span> <span class="operator">=</span> array[i];</span><br><span class="line">    <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; tempVal &gt; array[parent(i)]; i = parent(i)) &#123;</span><br><span class="line">        array[i] = array[parent(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = tempVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    array[i] = array[i] ^ array[j];</span><br><span class="line">    array[j] = array[i] ^ array[j];</span><br><span class="line">    array[i] = array[i] ^ array[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取出堆中最大的元素siftDown</strong></p><p> 取出堆中最大的元素其实是取出根节点，这个下沉的操作很有意思了。它有两方面的下沉：一方面是将根节点下沉到数组末尾，然后数组长度假象性减一下；另一方面是将交换后的根节点和左右子树的根节点作比较，不满足堆性质的则交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">25</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态&quot;</span> + Arrays.toString(array));</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">         swap(array, <span class="number">0</span>, array.length - <span class="number">1</span> - i);</span><br><span class="line">         siftDown(array,<span class="number">0</span>, array.length - i - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; array.length - 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//            // 最大堆 移除最大的数</span></span><br><span class="line"><span class="comment">//            swap(array, 0, array.length - 1 - i);</span></span><br><span class="line"><span class="comment">//            siftDown2(array, 0, array.length - i - 1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向复制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown2</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//当前节点最少保证有左孩子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tempVal</span> <span class="operator">=</span> array[index];</span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> leftChild(index);</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> &lt; length &amp;&amp; array[l] &lt; array[l + <span class="number">1</span>])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (tempVal &gt;= array[l]) <span class="keyword">break</span>;</span><br><span class="line">        array[index] = array[l];</span><br><span class="line">        index = l;</span><br><span class="line">    &#125;</span><br><span class="line">    array[index] = tempVal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">//当前节点最少保证有左孩子</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(index) &lt; length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> leftChild(index);</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> &lt; length &amp;&amp; array[l] &lt; array[l + <span class="number">1</span>])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (array[index] &gt;= array[l]) <span class="keyword">break</span>;</span><br><span class="line">        swap(array, index, l);</span><br><span class="line">        index = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    array[i] = array[i] ^ array[j];</span><br><span class="line">    array[j] = array[i] ^ array[j];</span><br><span class="line">    array[i] = array[i] ^ array[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构建二叉堆</strong></p><p> 构建二叉堆其实是一个一个子树的下沉操作，将无序的完全二叉树调整为二叉堆。所以它必须从满足高度为2的子树根节点开始，即非叶子节点，然后自底向上对每一个子树执行siftDown操作，直到完成二叉堆化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">13</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态&quot;</span> + Arrays.toString(array));</span><br><span class="line">    buildHeap(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parent(array.length - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子节点开始</span></span><br><span class="line">        siftDown2(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><p>力扣：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p><strong>题目描述：</strong></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><p><strong>示例1：</strong></p><p><img src="/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4/1.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#暴力解决</span><br><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找右边最高的柱子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++)</span><br><span class="line">            r_max = Math.max(r_max, height[j]);</span><br><span class="line">        <span class="comment">// 找左边最高的柱子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            l_max = Math.max(l_max, height[j]);</span><br><span class="line">        <span class="comment">// 如果自己就是最高的话，</span></span><br><span class="line">        <span class="comment">// l_max == r_max == height[i]</span></span><br><span class="line">        res += Math.min(l_max, r_max) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#备忘录优化</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组充当备忘录</span></span><br><span class="line">        <span class="type">int</span>[] l_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化 base case</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左向右计算 l_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            l_max[i] = Math.max(height[i], l_max[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从右向左计算 r_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            r_max[i] = Math.max(height[i], r_max[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 计算答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            res += Math.min(l_max[i], r_max[i]) - height[i];<span class="comment">/**&lt;extend up -300&gt;&lt;div class=&quot;img-content&quot;&gt;&lt;img src=&quot;/algo/images/接雨水/1.jpg&quot; class=&quot;myimage&quot;/&gt;&lt;/div&gt; */</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#双指针</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            l_max = Math.max(l_max, height[left]);</span><br><span class="line">            r_max = Math.max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// res += min(l_max, r_max) - height[i]</span></span><br><span class="line">            <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">                res += l_max - height[left];<span class="comment">/**&lt;extend up -250&gt;&lt;div class=&quot;img-content&quot;&gt;&lt;img src=&quot;/algo/images/接雨水/5.jpg&quot; class=&quot;myimage&quot;/&gt;&lt;/div&gt; */</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += r_max - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-gao--0d5eb/">如何高效解决接雨水问题 | labuladong 的算法笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈应用</title>
      <link href="/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88%E5%BA%94%E7%94%A8/"/>
      <url>/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="商品折扣后的最终价格"><a href="#商品折扣后的最终价格" class="headerlink" title="商品折扣后的最终价格"></a>商品折扣后的最终价格</h1><p>力扣：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/</a></p><p><strong>题目描述：</strong></p><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><span id="more"></span><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [10,1,1,6]</span><br><span class="line">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 500</code></li><li><code>1 &lt;= prices[i] &lt;= 10^3</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] finalPrices(<span class="type">int</span>[] prices) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 最后一位不打折</span></span><br><span class="line">            <span class="keyword">if</span> (i == prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i] = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历找出第一个小于prices[i]的数则为折扣值</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prices[i] &gt;= prices[j]) &#123;</span><br><span class="line">                        result[i] = prices[i] - prices[j];</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 没找到，不打折</span></span><br><span class="line">                    result[i] = prices[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] finalPrices(<span class="type">int</span>[] prices) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;(prices.length);</span><br><span class="line">        <span class="comment">// 逆序处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prices.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 维持倒序单调栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; prices[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = stack.isEmpty()? prices[i] : prices[i] - stack.peek();</span><br><span class="line">            stack.push(prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h1><p>力扣：<a href="https://leescode.cn/problems/daily-temperatures/">https://leescode.cn/problems/daily-temperatures/</a></p><p><strong>题目描述：</strong></p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p> <strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">// 利用优先队列创建栈，保存下表</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;(temperatures.length);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保持栈从头到尾是升序的</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;</span><br><span class="line">                result[stack.peek()] = i - stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="好朋友位置"><a href="#好朋友位置" class="headerlink" title="好朋友位置"></a>好朋友位置</h1><p><strong>题目描述：</strong></p><p>在学校中，<code>N</code>个小朋友站成一队， 第<code>i</code>个小朋友的身高为<code>height[i]</code>，第<code>i</code>个小朋友可以看到的右边的第一个比自己身高更高的小朋友<code>j</code>，那么<code>j</code>是<code>i</code>的好朋友（<code>j</code> &gt; <code>i</code>）。请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用<code>0</code>代替。小朋友人数范围是 <code>[0, 40000]</code>。</p><p><strong>输入描述：</strong></p><p>第一行输入<code>N</code>，表示有<code>N</code>个小朋友</p><p>第二行输入<code>N</code>个小朋友的身高<code>height[i]</code>，都是整数</p><p><strong>输出描述：</strong></p><p>输出<code>N</code>个小朋友的好朋友的位置</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">100 95</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p><strong>示例二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8</span><br><span class="line">123 124 125 121 119 122 126 123</span><br><span class="line">输出：</span><br><span class="line">1 2 6 5 5 6 0 0</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">方法一：正序遍历</span><br><span class="line"># 输入小朋友个数n</span><br><span class="line">n = int(input())</span><br><span class="line"># 输入N个小朋友的高度数组</span><br><span class="line">height = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line"># 构建一个单调栈，用来存放不同小朋友的身高的索引</span><br><span class="line"># 栈中储存的索引所对应在height中的元素大小，从栈底至栈顶单调递减</span><br><span class="line"># 即更大的数（的下标）位于栈底</span><br><span class="line">stack = list()</span><br><span class="line"></span><br><span class="line"># 构建列表ans，用来保存输出结果</span><br><span class="line"># 初始化其中所有的元素均为0</span><br><span class="line">ans = [0] * n</span><br><span class="line"></span><br><span class="line"># 从头开始遍历每一个小朋友的身高</span><br><span class="line">for i, h in enumerate(height):</span><br><span class="line">    # 第i个小朋友的身高h，需要不断地与栈顶元素比较</span><br><span class="line">    # 如果栈顶元素存在并且h【大于】栈顶元素stack[-1]</span><br><span class="line">    # 意味着栈顶元素找到了右边最近的比他更高的身高h</span><br><span class="line">    while len(stack) &gt; 0 and h &gt; height[stack[-1]]:</span><br><span class="line">        # 首先获取栈顶元素的值，也就是上一个比h小的身高的索引值</span><br><span class="line">        preIndex = stack.pop()</span><br><span class="line"></span><br><span class="line">        # i即为preIndex这个索引所对应的，下一个最近身高</span><br><span class="line">        ans[preIndex] = i</span><br><span class="line"></span><br><span class="line">    # 再把当前小朋友身高的下标i存放到栈中</span><br><span class="line">    # 注意：所储存的是下标i，而不是身高h</span><br><span class="line">    stack.append(i)</span><br><span class="line"></span><br><span class="line"># ans中的int元素转成str后才能合并成字符串</span><br><span class="line">print(&quot; &quot;.join(map(str, ans)))</span><br><span class="line"></span><br><span class="line">方法二：逆序遍历</span><br><span class="line"># 输入小朋友个数n</span><br><span class="line">n = int(input())</span><br><span class="line"># 输入N个小朋友的高度数组</span><br><span class="line">height = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line"># 构建一个单调栈，用来存放不同小朋友的身高的索引</span><br><span class="line"># 栈中储存的索引所对应在height中的元素大小，从栈底至栈顶单调递增</span><br><span class="line"># 即更大的数（的下标）位于栈底</span><br><span class="line">stack = list()</span><br><span class="line"></span><br><span class="line"># 构建列表ans，用来保存输出结果</span><br><span class="line"># 初始化其中所有的元素均为0</span><br><span class="line">ans = [0] * n</span><br><span class="line"></span><br><span class="line"># 逆序遍历每一个小朋友的身高</span><br><span class="line">for i in range(n-1, -1, -1):</span><br><span class="line">    h = height[i]</span><br><span class="line">    # 第i个小朋友的身高h，需要不断地与栈顶元素比较</span><br><span class="line">    # 如果栈顶元素存在并且h【大于等于】栈顶元素stack[-1]</span><br><span class="line">    # 说明栈顶元素stack[-1]并不是身高h右边最近的比h更大的元素</span><br><span class="line">    # 需要将栈顶元素弹出，继续寻找比h大的栈顶元素</span><br><span class="line">    while len(stack) &gt; 0 and h &gt;= height[stack[-1]]:</span><br><span class="line">        # 栈顶元素下标对应的身高不大于当前身高h，不是符合要求的更大身高，弹出</span><br><span class="line">        stack.pop()</span><br><span class="line">    # 完成弹出后，如果栈顶仍存在元素，说明stack[-1]所对应的身高，是严格比h大的下一个身高</span><br><span class="line">    if len(stack) &gt; 0:</span><br><span class="line">        # ans[i]修改为stack[-1]</span><br><span class="line">        ans[i] = stack[-1]</span><br><span class="line"></span><br><span class="line">    # 再把当前小朋友身高的下标i存放到栈中</span><br><span class="line">    # 注意：所储存的是下标i，而不是身高h</span><br><span class="line">    stack.append(i)</span><br><span class="line"></span><br><span class="line"># ans中的int元素转成str后才能合并成字符串</span><br><span class="line">print(&quot; &quot;.join(map(str, ans)))</span><br></pre></td></tr></table></figure><p>对于单调栈的题目，既可以<strong>正序遍历</strong>也可以<strong>逆序遍历</strong>数组来完成，重点在于理解单调栈的原理，只需要选择适合自己理解的方法来完成即可。以下表格总结了两种不同遍历顺序的异同点。</p><table><thead><tr><th align="center"></th><th align="center">正序遍历</th><th align="center">逆序遍历</th></tr></thead><tbody><tr><td align="center">单调栈顺序</td><td align="center">栈中储存的索引所对应在原数组中的元素大小，从栈底至栈顶单调递减，即<strong>更大的数（的下标）位于栈底</strong></td><td align="center"></td></tr><tr><td align="center">入栈时机</td><td align="center">栈顶元素反复出栈并修改<code>ans</code>之后，进行入栈。且入栈元素为当前下标<code>i</code>，而非身高<code>h</code></td><td align="center"></td></tr><tr><td align="center">修改<code>ans</code>时机</td><td align="center"><code>i</code>为<code>preIndex</code>的下一个更大元素的下标，在出栈过程中，即在<code>while</code>内修改<code>ans[preIndex]</code></td><td align="center"><code>stack[-1]</code>为<code>i</code>的下一个更大元素的下标，在出栈结束后，即在<code>while</code>外修改<code>ans[i]</code></td></tr><tr><td align="center">出栈条件</td><td align="center"><code>h &gt; height[stack[-1]]</code></td><td align="center"><code>h &gt;= height[stack[-1]]</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能网络I/O</title>
      <link href="/2023/11/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CI-O/"/>
      <url>/2023/11/04/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CI-O/</url>
      
        <content type="html"><![CDATA[<p>所谓高性能、高并发，其实都是在指高并发的I&#x2F;O。经典的C10K问题，其实最终也是在谈I&#x2F;O。如果你是一个服务端开发人员，没研究过经典的C10K问题，<a href="http://www.kegel.com/c10k.html">这里进</a>，值得你好好研究一番。当然，现在大家已经在谈C100K、C1000K的问题了，不用着急，等你熟悉了C10K的问题，C100K也不是大问题。</p><p>但是，能真正理解C10K里的讨论的基础，你需要至少懂一点I&#x2F;O的基本概念。</p><span id="more"></span><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>很多介绍I&#x2F;O的帖子，都喜欢把 blocking、nonblocking，同步、异步放在一起来对比，然后组合出各种不同的I&#x2F;O模型，再加上分类之间又有重叠，看完之后很多人还是觉得很模糊。</p><p>我一直将blocking&#x2F;nonblocking理解为I&#x2F;O模型（对I&#x2F;O的读取和写入会不会阻塞），而同步和异步，理解成编程模型的范畴。本身，不管是blocking还是nonblocking，都是同步的；而nonblocking之上的I&#x2F;O多路复用，也是同步调用。而不管是blocking还是nonblocking都可以施加于各种编程模型使之变为异步，例如nonblocking+epoll+多线程，让数据复制的部分异步化。</p><p>这里之外，还有一个重要的AIO (asynchronous I&#x2F;O)的概念。很多人把AIO也算为一种I&#x2F;O模型，包括《UNIX 网络编程》中也这么来定义。但是，从I&#x2F;O的本质来看，AIO更像是基于I&#x2F;O的编程模型。同时，Linux对AIO支持的很差，并且<a href="http://lse.sourceforge.net/io/aio.html">原生的AIO并不支持socket</a>，很多lib都是用户空间里的多线程的模拟。所以，我把AIO理解为异步化编程的阻塞或非阻塞I&#x2F;O调用。</p><h4 id="阻塞IO-blocking-I-O"><a href="#阻塞IO-blocking-I-O" class="headerlink" title="阻塞IO(blocking I&#x2F;O)"></a>阻塞IO(blocking I&#x2F;O)</h4><p>这个是大家最熟悉，并且也是最简单的I&#x2F;O模型。任何时候用户空间的进程发起阻塞的read&#x2F;write调用，用户进程都会进入阻塞状态(TASK_INTERRUPTIBLE) ，直到内核将进程需要读的数据准备好并复制到用户空间，进程被再次唤醒。在这个过程中，进程因为read&#x2F;write调用处于阻塞状态。</p><p>从用户空间进入内核空间，是通过系统调用来实现，最终通过异常进入内核(SYS ENTER)，这个时候，如果要读取的数据内核没有准备好（例如，如果需要从磁盘加载数据到内存缓存区、等待socket数据等等），内核通知其他硬件驱动去准备数据，然后发生进程切换(context switch)，当前进程因为要读取的数据没有准备好而进入休眠（task&#x2F;process的状态变为 TASK_INTERRUPTIBLE）而阻塞。当磁盘或者网络驱动程序准备好数据后，通过中断通知内核，内核将数据从内核缓冲区复制到用户空间(copy_to_userspace&#x2F;copy_from_usersapce函数)，然后唤醒等待的进程。</p><p>在这个过程中，可能发生多次context switch，但是从用户空间的进程的视角来看，是因为read&#x2F;write调用而阻塞了自己的执行。</p><h4 id="非阻塞IO-noblocking-I-O"><a href="#非阻塞IO-noblocking-I-O" class="headerlink" title="非阻塞IO(noblocking I&#x2F;O)"></a>非阻塞IO(noblocking I&#x2F;O)</h4><p>如果理解了阻塞I&#x2F;O，那么非阻塞I&#x2F;O就比较好理解了：</p><p>每次用户空间的进程调用read&#x2F;write系统调用，如果内核发现用户空间进程请求的数据没有准备好、会造成进程阻塞，系统调用直接返回 EAGAIN，告诉用户空间进程：hi，数据还没好，你下次再试！</p><p>所以，在这种模型下，用户空间进程需要频繁的、定时的去以非阻塞的模式调用read&#x2F;write操作，直到成功！而用户空间进程，可以在发现阻塞的时候，去执行其他事情。</p><p>在这个过程中，会发生进程切换(context switch)吗？不一定，可能会也可能不会。如果发生，也是在时钟中断或者从内核态返回用户态的时候，但是，这个切换和read&#x2F;write没有多少关系，切换的原因要么是时间片到期要么是内核抢占。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">阻塞和非阻塞的本质，是用户空间进程是否需要等待I/O</span><br><span class="line">这里我用了“等待”两个字。“我 - 用户进程”需要数据，内核可以立即给我，我就不用等；如果我要的数据内核没有，我首先需要等，等就必然造成阻塞。但是，数据从内核空间复制到用户空间，也需要时间，“我 - 用户进程” 也需要等待数据复制完成，这里的等待和I/O没有关系.</span><br><span class="line"></span><br><span class="line">至于epoll/poll，我们放到后面谈。epoll本质上只是一种高效处理nonblocking I/O的内核I/O多路复用，nonblocking != epoll，nonblocking != epoll，nonblocking != epoll! 从概念上大家一定不能混！</span><br></pre></td></tr></table></figure><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>在谈“同步”和“异步”编程模型之前，我觉得还是有必要简单聊一下“并行”和“并发”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发是并行的基础和前提。如果 action A 和 action B 可以互不干扰、互不等待的运行，我们可以说 A 和 B是可以并发的执行。如果只有一个CPU，那么A和B可以交替的执行，A和B是并发的；如果有多个CPU，A和B可以同时分别在两个CPU上同时的运行，此时A和B是并行的！</span><br></pre></td></tr></table></figure><p><strong>同步编程模型</strong></p><p>这也是大家熟悉同时也最容易被程序猿们接受和上手的编程模型。所谓同步，就是你在发出一个调用的时候，在没有获取到结果之前，调用不会返回，而一旦调用返回了，调用者也就“同步”地获取到返回值了。</p><p>换一种说法，就是，调用是顺序发生的，A 调用 B；获取到B的结果；A 再调用C。</p><p><strong>异步编程模型</strong></p><p>而异步则不同，调用在发出之后，你不用等待调用的结果，调用直接返回。而你需要注册一个回调函数，当有结果的时候，系统调用你注册的回调函数把结果传回给你。在这个过程中，进程可以去做其他事情。</p><p>同步是否比异步高效？</p><p>不一定！不一定！不一定！我觉得这是很多人存在的误区：既然获取结果的任务交给了某一个异步去做，那异步一定比同步效率高啊！</p><p>如果计算资源是无限的，异步一定比同步效率高。但是，在相同的计算资源下，就不一定，任何事情，总是需要“有人”去做，你不做，就是其他人去做。而这个其他人，可能是其他用户空间的进程，例如用户态模拟的AIO，无非是多进程多线程或者线程池；也可能是内核线程（Linux内核有好多功能就是基于内核线程，例如pdflush、工作队列）。但是不管是“谁”，操作系统都需要调度和协调（进程切换，也就是context switch；协调包括进程同步、以及调度算法）。这个调度和协调的代价，很可能远远高于你的一次异步操作。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot缓存应用实践</title>
      <link href="/2023/11/01/SpringBoot/SpringBoot%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/11/01/SpringBoot/SpringBoot%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>缓存是最直接有效提升系统性能的手段之一。</p><span id="more"></span><h2 id="通用缓存接口"><a href="#通用缓存接口" class="headerlink" title="通用缓存接口"></a>通用缓存接口</h2><h3 id="缓存基础算法"><a href="#缓存基础算法" class="headerlink" title="缓存基础算法"></a>缓存基础算法</h3><ul><li><strong>FIFO（First In First Out）</strong>，先进先出，和OS里的FIFO思路相同，如果一个数据最先进入缓存中，当缓存满的时候，应当把最先进入缓存的数据给移除掉。</li><li><strong>LFU（Least Frequently Used）</strong>，最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</li><li><strong>LRU（Least Recently Used）</strong>，最近最少使用，如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据移除。</li></ul><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>简单定义缓存接口，大致可以抽象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存提供者接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheProviderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm function函数的调用参数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function, Long expireTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm   function函数的调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 缓存值 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj        缓存值 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj, Long expireTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get相关方法，注意多个参数的情况，缓存接口里面传人的Function，这是Java8提供的函数式接口。</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>本地缓存，也就是JVM级别的缓存(本地缓存可以认为是直接在进程内通信调用，而分布式缓存则需要通过网络进行跨进程通信调用)，一般有很多种实现方式，比如直接使用Hashtable、ConcurrentHashMap等天生线程安全的集合作为缓存容器，或者使用一些成熟的开源组件，如EhCache、Guava Cache等。</p><h3 id="什么是Guava"><a href="#什么是Guava" class="headerlink" title="什么是Guava"></a>什么是Guava</h3><p>Guava，简单来说就是一个开发类库，且是一个非常丰富强大的开发工具包，号称可以让使用Java语言更令人愉悦，主要包括基本工具类库和接口、缓存、发布订阅风格的事件总线等。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"> * 本地缓存提供者服务 (Guava Cache)</span><br><span class="line"> * */</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;localCacheService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalCacheProviderImpl</span> <span class="keyword">implements</span> <span class="title class_">CacheProviderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Cache&lt;String, Object&gt;&gt; _cacheMap = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        Cache&lt;String, Object&gt; cacheContainer = CacheBuilder.newBuilder()</span><br><span class="line">                .maximumSize(AppConst.CACHE_MAXIMUM_SIZE)</span><br><span class="line">                .expireAfterWrite(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS)<span class="comment">//最后一次写入后的一段时间移出</span></span><br><span class="line">                <span class="comment">//.expireAfterAccess(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS) //最后一次访问后的一段时间移出</span></span><br><span class="line">                .recordStats()<span class="comment">//开启统计功能</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        _cacheMap.put(String.valueOf(AppConst.CACHE_MINUTE), cacheContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, <span class="literal">null</span>, <span class="literal">null</span>, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, key, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm function函数的调用参数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, funcParm, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, key, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm   function函数的调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expireTime = getExpireTime(expireTime);</span><br><span class="line"></span><br><span class="line">        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (function == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = (T) cacheContainer.getIfPresent(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">cachedTime</span> <span class="operator">=</span> expireTime;</span><br><span class="line">                obj = (T) cacheContainer.get(key, () -&gt; &#123;</span><br><span class="line">                    <span class="type">T</span> <span class="variable">retObj</span> <span class="operator">=</span> function.apply(funcParm);</span><br><span class="line">                    <span class="keyword">return</span> retObj;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 缓存值 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">        set(key, obj, AppConst.CACHE_MINUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj        缓存值 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expireTime = getExpireTime(expireTime);</span><br><span class="line"></span><br><span class="line">        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);</span><br><span class="line"></span><br><span class="line">        cacheContainer.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span> getExpireTime(AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);</span><br><span class="line"></span><br><span class="line">        cacheContainer.invalidate(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> exists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            exists = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, Object&gt; <span class="title function_">getCacheContainer</span><span class="params">(Long expireTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Cache&lt;String, Object&gt; cacheContainer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (expireTime == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> String.valueOf(expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_cacheMap.containsKey(mapKey) == <span class="literal">true</span>) &#123;</span><br><span class="line">            cacheContainer = _cacheMap.get(mapKey);</span><br><span class="line">            <span class="keyword">return</span> cacheContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            cacheContainer = CacheBuilder.newBuilder()</span><br><span class="line">                    .maximumSize(AppConst.CACHE_MAXIMUM_SIZE)</span><br><span class="line">                    .expireAfterWrite(expireTime, TimeUnit.MILLISECONDS)<span class="comment">//最后一次写入后的一段时间移出</span></span><br><span class="line">                    <span class="comment">//.expireAfterAccess(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS) //最后一次访问后的一段时间移出</span></span><br><span class="line">                    .recordStats()<span class="comment">//开启统计功能</span></span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            _cacheMap.put(mapKey, cacheContainer);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取过期时间 单位：毫秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 传人的过期时间 单位毫秒 如小于1分钟，默认为10分钟</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> Long <span class="title function_">getExpireTime</span><span class="params">(Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> expireTime;</span><br><span class="line">        <span class="keyword">if</span> (expireTime == <span class="literal">null</span> || expireTime &lt; AppConst.CACHE_MINUTE / <span class="number">10</span>) &#123;</span><br><span class="line">            result = AppConst.CACHE_MINUTE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Guava Cache初始化容器时，支持缓存过期策略，类似FIFO、LRU和LFU等算法。</p><ul><li>expireAfterWrite：最后一次写入后的一段时间移出。</li><li>expireAfterAccess：最后一次访问后的一段时间移出。</li></ul><p>Guava Cache对缓存过期时间的设置实在不够友好。常见的应用场景，比如，有些几乎不变的基础数据缓存1天，有些热点数据缓存2小时，有些会话数据缓存5分钟等等。</p><p>通常我们认为设置缓存的时候带上缓存的过期时间是非常容易的，而且只要一个缓存容器实例即可，但是Guava Cache不是这个实现思路，如果缓存的过期时间不同，Guava的CacheBuilder要初始化多份Cache实例。</p><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>分布式缓存产品非常多，本文使用应用普遍的Redis，在Spring Boot应用中使用Redis非常简单。</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h3><p>在application.properties配置文件中，配置Redis常用参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Redis缓存相关配置</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#Redis服务器端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379  </span></span><br><span class="line"><span class="comment">#Redis服务器密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">123321</span></span><br><span class="line"><span class="comment">#Redis连接超时时间 默认：5分钟（单位：毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">300000ms</span></span><br><span class="line"><span class="comment">#Redis连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-active</span>=<span class="string">512</span></span><br><span class="line"><span class="comment">#Redis连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#Redis连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">#Redis连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms</span></span><br></pre></td></tr></table></figure><p>常见的需要注意的是最大连接数（spring.redis.jedis.pool.max-active ）和超时时间（spring.redis.jedis.pool.max-wait）。Redis在生产环境中出现故障的频率经常和这两个参数息息相关。</p><p>接着定义一个继承自CachingConfigurerSupport（请注意cacheManager和keyGenerator这两个方法在子类的实现）的RedisConfig类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis缓存配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.create(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Jedis的Key和Value的序列化器默认值是JdkSerializationRedisSerializer</span></span><br><span class="line">        <span class="comment">//经实验，JdkSerializationRedisSerializer通过RedisDesktopManager看到的键值对不能正常解析</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置key的序列化器</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">////设置value的序列化器  默认值是JdkSerializationRedisSerializer</span></span><br><span class="line">        <span class="comment">//使用Jackson序列化器的问题是，复杂对象可能序列化失败，比如JodaTime的DateTime类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //使用Jackson2，将对象序列化为JSON</span></span><br><span class="line">        <span class="comment">//        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span></span><br><span class="line">        <span class="comment">//        //json转对象类，不设置默认的会将json转成hashmap</span></span><br><span class="line">        <span class="comment">//        ObjectMapper om = new ObjectMapper();</span></span><br><span class="line">        <span class="comment">//        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span></span><br><span class="line">        <span class="comment">//        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line">        <span class="comment">//        jackson2JsonRedisSerializer.setObjectMapper(om);</span></span><br><span class="line">        <span class="comment">//        template.setValueSerializer(jackson2JsonRedisSerializer);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将redis连接工厂设置到模板类中</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //自定义缓存key生成策略</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public KeyGenerator keyGenerator() &#123;</span></span><br><span class="line"><span class="comment">//        return new KeyGenerator() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123;</span></span><br><span class="line"><span class="comment">//                StringBuffer sb = new StringBuffer();</span></span><br><span class="line"><span class="comment">//                sb.append(target.getClass().getName());</span></span><br><span class="line"><span class="comment">//                sb.append(method.getName());</span></span><br><span class="line"><span class="comment">//                for (Object obj : params) &#123;</span></span><br><span class="line"><span class="comment">//                    if (obj == null) &#123;</span></span><br><span class="line"><span class="comment">//                        continue;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    sb.append(obj.toString());</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                return sb.toString();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RedisConfig这个类上加上@EnableCaching这个注解，这个注解会被Spring发现，并且会创建一个切面（aspect） 并触发Spring缓存注解的切点（pointcut）。据所使用的注解以及缓存的状态，这个切面会从缓存中获取数据，将数据添加到缓存之中或者从缓存中移除某个值。</p><p>cacheManager方法，申明一个缓存管理器（CacheManager）的bean，作用就是@EnableCaching这个切面在新增缓存或者删除缓存的时候会调用这个缓存管理器的方法。keyGenerator方法，可以根据需求自定义缓存key生成策略。</p><p>而redisTemplate方法，则主要是设置Redis模板类，比如键和值的序列化器（从这里可以看出，Redis的键值对必须可序列化）、redis连接工厂等。</p><p>RedisTemplate支持的序列化器主要有如下几种：</p><ul><li><strong>JdkSerializationRedisSerializer：</strong>使用Java序列化；</li><li><strong>StringRedisSerializer：</strong>序列化String类型的key和value；</li><li><strong>GenericToStringSerializer：</strong>使用Spring转换服务进行序列化；</li><li><strong>JacksonJsonRedisSerializer：</strong>使用Jackson 1，将对象序列化为JSON；</li><li><strong>Jackson2JsonRedisSerializer：</strong>使用Jackson 2，将对象序列化为JSON；</li><li><strong>OxmSerializer：</strong>使用Spring O&#x2F;X映射的编排器和解排器（marshaler和unmarshaler）实现序列化，用于XML序列化；</li></ul><p><em>注意：**RedisTemplate的键和值序列化器，默认情况下都是JdkSerializationRedisSerializer，它们都可以自定义设置序列化器。</em></p><p>推荐将字符串键使用StringRedisSerializer序列化器，因为运维的时候好排查问题，JDK序列化器的也能识别，但是可读性稍差，而值序列化器则要复杂的多，很多人推荐使用Jackson2JsonRedisSerializer序列化器，但是实际开发过程中，经常有人碰到反序列化错误，经过排查多数都和Jackson2JsonRedisSerializer这个序列化器有关。</p><h3 id="实现接口-1"><a href="#实现接口-1" class="headerlink" title="实现接口"></a>实现接口</h3><p>使用RedisTemplate，在Spring Boot中调用Redis接口比直接调用Jedis简单多了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;redisCacheService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheProviderImpl</span> <span class="keyword">implements</span> <span class="title class_">CacheProviderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Serializable, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, <span class="literal">null</span>, <span class="literal">null</span>, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, key, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm function函数的调用参数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, funcParm, AppConst.CACHE_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> get(key, function, key, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm   function函数的调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expireTime = getExpireTime(expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            obj = (T) operations.get(key);</span><br><span class="line">            <span class="keyword">if</span> (function != <span class="literal">null</span> &amp;&amp; obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = function.apply(funcParm);</span><br><span class="line">                <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                    set(key, obj, expireTime);<span class="comment">//设置缓存信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 缓存值 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">        set(key, obj, AppConst.CACHE_MINUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj        缓存值 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj, Long expireTime)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expireTime = getExpireTime(expireTime);</span><br><span class="line"></span><br><span class="line">        ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">        operations.set(key, obj);</span><br><span class="line"></span><br><span class="line">        redisTemplate.expire(key, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> exists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            exists = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取过期时间 单位：毫秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 传人的过期时间 单位毫秒 如小于1分钟，默认为10分钟</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> Long <span class="title function_">getExpireTime</span><span class="params">(Long expireTime)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> expireTime;</span><br><span class="line">        <span class="keyword">if</span> (expireTime == <span class="literal">null</span> || expireTime &lt; AppConst.CACHE_MINUTE / <span class="number">10</span>) &#123;</span><br><span class="line">            result = AppConst.CACHE_MINUTE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在配置文件中，加上缓存提供者开关：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##是否启用本地缓存</span></span><br><span class="line"><span class="attr">spring.power.isuselocalcache</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">##是否启用Redis缓存</span></span><br><span class="line"><span class="attr">spring.power.isuserediscache</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>缓存提供者程序都实现好了，我们会再包装一个调用外观类PowerCacheBuilder，加上缓存版本控制，可以轻松自如地控制和切换缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 支持多缓存提供程序多级缓存的缓存帮助类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerCacheBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;localCacheService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CacheProviderService localCacheService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;redisCacheService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CacheProviderService redisCacheService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;CacheProviderService&gt; _listCacheProvider = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">providerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化缓存提供者 默认优先级：先本地缓存，后分布式缓存</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CacheProviderService&gt; <span class="title function_">getCacheProviders</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_listCacheProvider.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _listCacheProvider;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程安全</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            providerLock.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_listCacheProvider.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> _listCacheProvider;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">isUseCache</span> <span class="operator">=</span> ConfigUtil.getConfigVal(AppField.IS_USE_LOCAL_CACHE);</span><br><span class="line"></span><br><span class="line">            <span class="type">CacheProviderService</span> <span class="variable">cacheProviderService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启用本地缓存</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equalsIgnoreCase(isUseCache)) &#123;</span><br><span class="line">                _listCacheProvider.add(localCacheService);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isUseCache = ConfigUtil.getConfigVal(AppField.IS_USE_REDIS_CACHE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启用Redis缓存</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equalsIgnoreCase(isUseCache)) &#123;</span><br><span class="line">                _listCacheProvider.add(redisCacheService);</span><br><span class="line"></span><br><span class="line">                resetCacheVersion();<span class="comment">//设置分布式缓存版本号</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PowerLogger.info(<span class="string">&quot;初始化缓存提供者成功，共有&quot;</span> + _listCacheProvider.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            _listCacheProvider = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            PowerLogger.error(<span class="string">&quot;初始化缓存提供者发生异常：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providerLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _listCacheProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key = generateVerKey(key);//构造带版本的缓存键</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            obj = provider.get(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = provider.get(key, function);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (function != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;<span class="comment">//查询并设置其他缓存提供者程序缓存</span></span><br><span class="line">                provider.get(key, function);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果callable函数为空 而缓存对象不为空 及时跳出循环并返回</span></span><br><span class="line">            <span class="keyword">if</span> (function == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm function函数的调用参数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = provider.get(key, function, funcParm);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (function != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;<span class="comment">//查询并设置其他缓存提供者程序缓存</span></span><br><span class="line">                provider.get(key, function, funcParm);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果callable函数为空 而缓存对象不为空 及时跳出循环并返回</span></span><br><span class="line">            <span class="keyword">if</span> (function == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;String, T&gt; function, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = provider.get(key, function, expireTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (function != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;<span class="comment">//查询并设置其他缓存提供者程序缓存</span></span><br><span class="line">                provider.get(key, function, expireTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果callable函数为空 而缓存对象不为空 及时跳出循环并返回</span></span><br><span class="line">            <span class="keyword">if</span> (function == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function   如没有缓存，调用该callable函数返回对象 可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> funcParm   function函数的调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, M <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; T <span class="title function_">get</span><span class="params">(String key, Function&lt;M, T&gt; function, M funcParm, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = provider.get(key, function, funcParm, expireTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (function != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;<span class="comment">//查询并设置其他缓存提供者程序缓存</span></span><br><span class="line">                provider.get(key, function, funcParm, expireTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果callable函数为空 而缓存对象不为空 及时跳出循环并返回</span></span><br><span class="line">            <span class="keyword">if</span> (function == <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入或覆盖值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 缓存值 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key = generateVerKey(key);//构造带版本的缓存键</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            provider.set(key, obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置缓存键值  直接向缓存中插入或覆盖值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        缓存键 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj        缓存值 不可为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间（单位：毫秒） 可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T obj, Long expireTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key = generateVerKey(key);//构造带版本的缓存键</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            provider.set(key, obj, expireTime);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key = generateVerKey(key);//构造带版本的缓存键</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheProviderService provider : getCacheProviders()) &#123;</span><br><span class="line"></span><br><span class="line">            provider.remove(key);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键 不可为空</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key = generateVerKey(key);//构造带版本的缓存键</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> exists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            exists = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式缓存版本号</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCacheVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUseCache</span> <span class="operator">=</span> checkUseRedisCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未启用Redis缓存</span></span><br><span class="line">        <span class="keyword">if</span> (isUseCache == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> version;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        version = redisCacheService.get(AppConst.CACHE_VERSION_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置分布式缓存版本  如果启用分布式缓存，设置缓存版本</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">resetCacheVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUseCache</span> <span class="operator">=</span> checkUseRedisCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未启用Redis缓存</span></span><br><span class="line">        <span class="keyword">if</span> (isUseCache == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> version;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置缓存版本</span></span><br><span class="line">        version = String.valueOf(Math.abs(UUID.randomUUID().hashCode()));</span><br><span class="line">        redisCacheService.set(AppConst.CACHE_VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果启用分布式缓存，获取缓存版本，重置查询的缓存key，可以实现相对实时的缓存过期控制</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如没有启用分布式缓存，缓存key不做修改，直接返回</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateVerKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> key;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUseCache</span> <span class="operator">=</span> checkUseRedisCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有启用分布式缓存，缓存key不做修改，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (isUseCache == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> redisCacheService.get(AppConst.CACHE_VERSION_KEY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(version) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = String.format(<span class="string">&quot;%s_%s&quot;</span>, result, version);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证是否启用分布式缓存</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkUseRedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUseCache</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strIsUseCache</span> <span class="operator">=</span> ConfigUtil.getConfigVal(AppField.IS_USE_REDIS_CACHE);</span><br><span class="line"></span><br><span class="line">        isUseCache = <span class="string">&quot;1&quot;</span>.equalsIgnoreCase(strIsUseCache);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isUseCache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheVerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> cacheBuilder.getCacheVersion();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;当前缓存版本：%s&quot;</span>, version));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> cacheBuilder.generateVerKey(<span class="string">&quot;goods778899&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">GoodsVO</span> <span class="variable">goodsVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodsVO</span>();</span><br><span class="line">        goodsVO.setGoodsId(UUID.randomUUID().toString());</span><br><span class="line">        goodsVO.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        goodsVO.setCreateDate(<span class="keyword">new</span> <span class="title class_">DateTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        goodsVO.setGoodsType(<span class="number">1024</span>);</span><br><span class="line">        goodsVO.setGoodsCode(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">        goodsVO.setGoodsName(<span class="string">&quot;我的测试商品&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cacheBuilder.set(cacheKey, goodsVO);</span><br><span class="line"></span><br><span class="line">        <span class="type">GoodsVO</span> <span class="variable">goodsVO1</span> <span class="operator">=</span> cacheBuilder.get(cacheKey);</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(goodsVO1);</span><br><span class="line"></span><br><span class="line">        version = cacheBuilder.resetCacheVersion();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;重置后的缓存版本：%s&quot;</span>, version));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cacheKey = cacheBuilder.generateVerKey(<span class="string">&quot;goods112233&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cacheBuilder.set(cacheKey, goodsVO);</span><br><span class="line"></span><br><span class="line">        <span class="type">GoodsVO</span> <span class="variable">goodsVO2</span> <span class="operator">=</span> cacheBuilder.get(cacheKey);</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(goodsVO2);</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(<span class="string">&quot;两个缓存对象的主键相同&quot;</span>, goodsVO1.getGoodsId().equals(goodsVO2.getGoodsId()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现滑动时间窗口算法</title>
      <link href="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>滑动时间窗限流算法解决了固定时间窗限流算法的问题。其没有划分固定的时间窗起点与终点，而是将每一次请求的到来时间点作为统计时间窗的终点，起点则是终点向前推时间窗长度的时间点。这种时间窗称为“滑动时间窗”。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动时间窗口限流工具</span></span><br><span class="line"><span class="comment"> * 本限流工具只适用于单机版，如果想要做全局限流，可以按本程序的思想，用redis的List结构去实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlideWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列id和队列的映射关系，队列里面存储的是每一次通过时候的时间戳，这样可以使得程序里有多个限流队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Map&lt;String, List&lt;Long&gt;&gt; MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SlideWindow</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 任意10秒内，只允许2次通过</span></span><br><span class="line">            System.out.println(LocalTime.now().toString() + SlideWindow.isGo(<span class="string">&quot;ListId&quot;</span>, <span class="number">2</span>, <span class="number">10000L</span>));</span><br><span class="line">            <span class="comment">// 睡眠0-10秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动时间窗口限流算法</span></span><br><span class="line"><span class="comment">     * 在指定时间窗口，指定限制次数内，是否允许通过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listId     队列id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count      限制次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeWindow 时间窗口大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否允许通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isGo</span><span class="params">(String listId, <span class="type">int</span> count, <span class="type">long</span> timeWindow)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 根据队列id，取出对应的限流队列，若没有则创建</span></span><br><span class="line">        List&lt;Long&gt; list = MAP.computeIfAbsent(listId, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 如果队列还没满，则允许通过，并添加当前时间戳到队列开始位置</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; count) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>, nowTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满（达到限制次数），则获取队列中最早添加的时间戳</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">farTime</span> <span class="operator">=</span> list.get(count - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 用当前时间戳 减去 最早添加的时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (nowTime - farTime &lt;= timeWindow) &#123;</span><br><span class="line">            <span class="comment">// 若结果小于等于timeWindow，则说明在timeWindow内，通过的次数大于count</span></span><br><span class="line">            <span class="comment">// 不允许通过</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若结果大于timeWindow，则说明在timeWindow内，通过的次数小于等于count</span></span><br><span class="line">            <span class="comment">// 允许通过，并删除最早添加的时间戳，将当前时间添加到队列开始位置</span></span><br><span class="line">            list.remove(count - <span class="number">1</span>);</span><br><span class="line">            list.add(<span class="number">0</span>, nowTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：任意10秒内，通过的次数不超过2次。或者按照实现原理来说，任意通过2次内的时间差，都不超过10秒。</p><p>实现原理：</p><p>1.这条线就是队列list，当第一个事件进来，队列大小是0，时间是第1秒：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/1.png" alt="图片"></p><p>2.因为size&#x3D;0，小于5，都没有到限制的次数，完全不用考虑时间窗口，直接把这次事件的时间戳放到0的位置：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/2.png" alt="图片"></p><p>3.第2.8秒的时候，第二个事件来了。因为此时size&#x3D;1，还是小于5，把这次事件的时间戳放到0的位置，原来第1秒来的事件时间戳会往后移动一格：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/3.png" alt="图片"></p><p>4.陆续的又来了3个事件，队列大小变成了5，先来的时间戳依次向后移动。此时，第6个事件来了，时间是第8秒：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/4.png" alt="图片"></p><p>5.因为size&#x3D;5，不小于5，此时已经达到限制次数，以后都需要考虑时间窗口了。所以取出位置4的时间（离现在最远的时间），和第6个事件的时间戳做比较：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/5.png" alt="图片"></p><p>6.得到的差是7秒，小于时间窗口10秒，说明在10秒内，来的事件个数大于5了，所以本次不允许通过：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/6.png" alt="图片"></p><p>7.接下来即便来上100个事件，只要时间差小于等于10秒，都同上，拒绝通过：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/7.png" alt="图片"></p><p>8.第11.1秒，第101次事件过来了。因为size&#x3D;5，不小于5，所以取出位置4的时间（离现在最远的时间），和第101个事件的时间戳做比较：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/8.png" alt="图片"></p><p>9.得到的差是10.1秒，大于时间窗口10秒，说明在10秒内，来的事件个数小于等于5了，所以本次允许通过：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/9.png" alt="图片"></p><p>10.删除位置4的时间（离现在最远的时间），把这次事件的时间戳放到0的位置，后面的时间戳依次向后移动：</p><p><img src="/2023/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/10.png" alt="图片"></p><p>往后再来其他事件，就是重复4-10的步骤，即可实现，在任意滑动时间窗口内，限制通过的次数</p><p>其本质思想是转换概念，将原本问题的确定时间大小，进行次数限制。转换成确定次数大小，进行时间限制。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解ThreadLocal</title>
      <link href="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/"/>
      <url>/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>ThreadLocal 是线程本地变量。当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。</p><span id="more"></span><h2 id="ThreadLocal-使用场景"><a href="#ThreadLocal-使用场景" class="headerlink" title="ThreadLocal 使用场景"></a>ThreadLocal 使用场景</h2><p>主要有以下三种场景。</p><ul><li>作为数据副本，当某些数据是以线程为作用域并且不同线程有不同数据副本时，可以考虑 ThreadLocal。</li><li>保存线程上下文信息，在任意需要的地方可以获取，避免显示传参。</li><li>解决线程安全问题，避免某些情况需要考虑线程安全必须同步带来的性能损失。</li></ul><h2 id="ThreadLocal的原理和实现"><a href="#ThreadLocal的原理和实现" class="headerlink" title="ThreadLocal的原理和实现"></a>ThreadLocal的原理和实现</h2><p>每个线程都有一个 ThreadLocalMap（ThreadLocal内部类），Map 中元素的键为 ThreadLocal，而值对应线程的变量副本。Map 是数组实现，使用线性探测解决hash冲突，需要手动调用set、get、remove防止内存泄漏。</p><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal 的用法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用 threadLocal.set() --&gt; 调用 getMap(Thread) --&gt; 返回当前线程的 ThreadLocalMap &lt; ThreadLocal, value &gt;--&gt;</span><br><span class="line">map.set(this, value)，this 是 ThreadLocal</span><br><span class="line"></span><br><span class="line">调用 get() --&gt; 调用getMap(Thread) --&gt; 返回当前线程的 ThreadLocalMap&lt;ThreadLocal, value&gt;--&gt;</span><br><span class="line">map.getEntry(this)，返回value。</span><br></pre></td></tr></table></figure><p>这个储值的Map并非ThreadLocal的成员变量，而是java.lang.Thread 类的成员变量。ThreadLocalMap实例是作为java.lang.Thread的成员变量存储的，每个线程有唯一的一个threadLocalMap。这个map以ThreadLocal对象为key，”线程局部变量”为值，所以一个线程下可以保存多个”线程局部变量”。</p><p><img src="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/1.png" alt="图片"></p><p>对ThreadLocal的操作，实际委托给当前Thread，每个Thread都会有自己独立的ThreadLocalMap实例，存储的仓库是Entry[] table；Entry的key为ThreadLocal，value为存储内容；因此在并发环境下，对ThreadLocal的set或get，不会有任何问题。</p><p>由于Tomcat线程池的原因，我最初使用的”线程局部变量”保存的值，在下一次请求依然存在（同一个线程处理），这样每次请求都是在本线程中取值。所以在线程池的情况下，处理完成后主动调用该业务treadLocal的remove()方法，将”线程局部变量”清空，避免本线程下次处理的时候依然存在旧数据。</p><p>ThreadLocal 并不是用来解决共享资源的多线程访问的问题，因为每个线程中的资源只是副本，并不共享。因此ThreadLocal适合作为线程上下文变量，简化线程内传参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ThreadLocal.ThreadLocalMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代表key弱引用已被回收</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果被回收 需要替换</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">            <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">            <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">            <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">           <span class="comment">// 向前遍历 检查是否有已经被回收的key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">            <span class="comment">// occurs first</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">                <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">                <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">                <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">                <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">              <span class="comment">// 遇到相同的需要替换value</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">                <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">                <span class="comment">// first still present in the run.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">            tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">            <span class="comment">// 如果有其他的过期对象会清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h3><p>在ThreadLocal中内存泄漏是指ThreadLocalMap中的Entry中的key为null，而value不为null。因为key为null导致value一直访问不到，而根据可达性分析导致在垃圾回收的时候进行可达性分析的时候，value可达从而不会被回收掉，但是该value永远不能被访问到，这样就存在了内存泄漏。</p><p><strong>解决方案</strong>：对应的 value 在下一次 ThreadLocalMap 调用 set、get、remove 方法时被清除，但是这几个方法需要被显式调用。</p><h3 id="为什么要使用弱引用"><a href="#为什么要使用弱引用" class="headerlink" title="为什么要使用弱引用"></a>为什么要使用弱引用</h3><p>key如果是强引用会导致线程不被回收，key对应ThreadLocal也不被回收，所以要改为弱引用。至于value一定是强引用，所以必须用完调用remove方法。</p><p>Map中的key为一个threadlocal实例.如果使用强引用，当ThreadLocal对象（假设为ThreadLocal@123456）的引用被回收了，ThreadLocalMap本身依然还持有ThreadLocal@123456的强引用，如果没有手动删除这个key，则ThreadLocal@123456不会被回收，所以只要当前线程不消亡，ThreadLocalMap引用的那些对象就不会被回收，可以认为这导致Entry内存泄漏。</p><p>如果使用弱引用，那指向ThreadLocal@123456对象的引用就两个：ThreadLocal强引用和ThreadLocalMap中Entry的弱引用。一旦ThreadLocal强引用被回收，则指向ThreadLocal@123456的就只有弱引用了，在下次gc的时候，这个ThreadLocal@123456就会被回收。</p><p>虽然上述的弱引用解决了key，也就是线程的ThreadLocal能及时被回收，但是value却依然存在内存泄漏的问题。当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露,因为存在一条从current thread连接过来的强引用.只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.所以当线程的某个localThread使用完了，马上调用threadlocal的remove方法,就不会发生这种情况了。</p><p>另外其实只要这个线程对象及时被gc回收，这个内存泄露问题影响不大，但在threadLocal设为null到线程结束中间这段时间不会被回收的，就发生了我们认为的内存泄露。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用，就可能出现内存泄露。</p><h3 id="ThreadLocalMap-和-HashMap-区别"><a href="#ThreadLocalMap-和-HashMap-区别" class="headerlink" title="ThreadLocalMap 和 HashMap 区别"></a>ThreadLocalMap 和 HashMap 区别</h3><p>ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同：</p><p>HashMap 的数据结构是数组+链表，HashMap 是通过链地址法解决hash 冲突的问题，HashMap 里面的Entry 内部类的引用都是强引用。</p><p>ThreadLocalMap的数据结构仅仅是数组，ThreadLocalMap 是通过开放地址法来解决hash 冲突的问题，ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用</p><h3 id="链地址法和开放地址法"><a href="#链地址法和开放地址法" class="headerlink" title="链地址法和开放地址法"></a>链地址法和开放地址法</h3><p>jdk 中大多数的类都是采用了链地址法来解决hash 冲突，为什么ThreadLocalMap 采用开放地址法来解决哈希冲突呢？首先我们来看看这两种不同的方式</p><p><strong>链地址法</strong></p><p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。列如对于关键字集合{12,67,56,16,25,37, 22,29,15,47,48,34}，我们用前面同样的12为除数，进行除留余数法：</p><p><img src="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/2.png" alt="图片"></p><p>优缺点：</p><p>处理冲突简单，且无堆积现象，平均查找长度短。</p><p>链表中的结点是动态申请的，适合构造表不能确定长度的情况。</p><p>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p><p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。</p><p><strong>开放地址法</strong></p><p>这种方法的基本思想是一旦发生了冲突，就去寻找下一个空的散列地址(这非常重要，源码都是根据这个特性，必须理解这里才能往下走)，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><p>比如说，我们的关键字集合为{12,33,4,5,15,25},表长为10。我们用散列函数f(key) &#x3D; key mod l0。当计算前S个数{12,33,4,5}时，都是没有冲突的散列地址，直接存入（蓝色代表为空的，可以存放数据）：</p><p><img src="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/3.png" alt="图片"></p><p>计算key &#x3D; 15时，发现f(15) &#x3D; 5，此时就与5所在的位置冲突。于是我们应用上面的公式f(15) &#x3D; (f(15)+1) mod 10 &#x3D;6。于是将15存入下标为6的位置。这其实就是房子被人买了于是买下一间的作法：</p><p><img src="/2023/10/30/%E4%BA%86%E8%A7%A3ThreadLocal/4.png" alt="图片"></p><p>优缺点：</p><p>容易产生堆积问题，不适于大规模的数据存储。</p><p>散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</p><p>删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</p><p><strong>ThreadLocalMap 采用开放地址法原因</strong></p><p>ThreadLocal 中看到一个属性 HASH_INCREMENT &#x3D; 0x61c88647 ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table，关于这个神奇的数字google 有很多解析，这里就不重复说了</p><p>ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式定义"><a href="#观察者模式定义" class="headerlink" title="观察者模式定义"></a><strong>观察者模式定义</strong></h2><p>观察者模式，也可以称之为<strong>发布订阅模式</strong>，它在GoF 的《设计模式》中，是这么定义的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Define a one-to-many dependency between objects so that when one object changes state,</span><br><span class="line">all its dependents are notified and updated automatically。</span><br></pre></td></tr></table></figure><p><strong>观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新</strong>。</p><span id="more"></span><p>观察者模式属于<strong>行为模式</strong>，一个对象（<strong>被观察者</strong>）的状态发生改变，所有的依赖对象（<strong>观察者对象</strong>）都将得到通知，进行广播通知。它的主要成员就是<strong>观察者和被观察者</strong>。</p><ul><li>被观察者（Observerable）：目标对象，状态发生变化时，将通知所有的观察者。</li><li>观察者（observer）：接受被观察者的状态变化通知，执行预先定义的业务。</li></ul><h2 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a><strong>观察者模式的应用场景</strong></h2><p>日常开发中，观察者模式的使用场景主要表现在：完成一件事情后，通知处理某个逻辑。如，<strong>登陆成功发个IM消息</strong>，<strong>支付成功发个邮件消息或者发个抽奖消息</strong>，<strong>用户评论成功给他发个积分</strong>等等。</p><p>详细点的例子:<strong>登陆注册</strong>应该是最常见的业务场景了，我们就拿注册来说事，大家经常会遇到类似的场景，就是用户注册成功后，我们给用户发一条<code>IM</code>消息，又或者发个邮件等等，因此经常有如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">  insertRegisterUser（user）;</span><br><span class="line">  sendIMMessage();</span><br><span class="line">  sendEmail()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码会有什么问题呢？如果产品又加需求：现在注册成功的用户，再给用户发一条短信通知。于是你又得改<code>register</code>方法的代码了。。。这是不是违反了<strong>开闭原则</strong>啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">  insertRegisterUser（user）;</span><br><span class="line">  sendIMMessage();</span><br><span class="line">  sendMobileMessage（）;</span><br><span class="line">  sendEmail()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，如果调发短信的接口失败了，是不是又影响到用户注册了？！这时候，是不是得加个<strong>异步方法</strong>，异步发通知消息才好？？其实这种场景，我们可以使用<strong>异步非阻塞的观察者模式</strong>优化的。</p><h2 id="如何实现一个简单的观察者模式"><a href="#如何实现一个简单的观察者模式" class="headerlink" title="如何实现一个简单的观察者模式"></a><strong>如何实现一个简单的观察者模式</strong></h2><p>我们先来看下，简单的观察者模式如何实现。可以这么定义</p><ul><li>一个主题接口<code>Subject</code>（声明添加、删除、通知观察者方法）</li><li>一个<code>Observer</code>观察者接口</li><li>一个创建主题的类<code>ObserverableImpl</code>（即被观察者），实现了<code>Subject</code>接口</li><li>各个观察者的差异化实现</li></ul><p>为了通俗易懂，可以这样理解观察者模式：就是被观察者（<code>ObserverableImpl</code>）做了一件事情，或者说发布了一个主题（<code>Subject</code>），然后这件事情通知到各个相关的不同的人（不同的观察者，<code>Observer</code>的差异化实现者）。</p><p><img src="/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.png" alt="图片"></p><p><strong>主题接口:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察者接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个创建主题的类<code>ObserverableImpl</code>（即被观察者），同时有观察者列表的属性（其实就是说观察者要事先注册到被观察者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverableImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储被观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察者的差异化</strong>实现，以及使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverOneImpl</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ObserverOne is notified,&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverTwoImpl</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ObserverTwo is notified,&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverDemoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverableImpl</span>();</span><br><span class="line">        <span class="comment">//添加观察者</span></span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">ObserverOneImpl</span>());</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">ObserverTwoImpl</span>());</span><br><span class="line">        <span class="comment">//通知</span></span><br><span class="line">        subject.notifyAllObservers(<span class="string">&quot;关注公众号:捡田螺的小男孩&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">ObserverOne is notified,关注公众号:捡田螺的小男孩</span><br><span class="line">ObserverTwo is notified,关注公众号:捡田螺的小男孩</span><br></pre></td></tr></table></figure><h2 id="工作中，如何使用观察者模式的"><a href="#工作中，如何使用观察者模式的" class="headerlink" title="工作中，如何使用观察者模式的"></a><strong>工作中，如何使用观察者模式的</strong></h2><p>观察者模式的实现有两种方式，同步阻塞方式和异步非阻塞方式。第3小节就是一个<strong>同步阻塞方式</strong>的观察者模式。我们来看下，日常工作的例子：<strong>用户注册成功发消息的例子，如何实现</strong>。本小节分同步阻塞、异步阻塞、spring观察者模式三个方向探讨。</p><ul><li>同步阻塞方式的观察模式</li><li>异步非阻塞方式的观察者模式</li><li>spring观察者模式应用</li></ul><h3 id="同步阻塞方式的观察模式"><a href="#同步阻塞方式的观察模式" class="headerlink" title="同步阻塞方式的观察模式"></a>同步阻塞方式的观察模式</h3><p>我们可以把<strong>用户注册</strong>，当做<strong>被观察者</strong>实现的逻辑，然后<strong>发消息</strong>就是<strong>观察者的实现逻辑</strong>。</p><p>假设有两个观察者，分别是发QQ消息和手机消息，于是有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverMobileImpl</span> <span class="keyword">implements</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送手机短信消息&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverQQImpl</span> <span class="keyword">implements</span> <span class="title class_">RegisterObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送QQ消息&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接可以通过<code>spring</code>的<code>ApplicationContextAware</code>，初始化观察者列表，然后用户注册成功，通知观察者即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//观察者列表</span></span><br><span class="line">     <span class="keyword">private</span> Collection&lt;RegisterObserver&gt; regObservers;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(&quot;register&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">          <span class="comment">//注册成功过（类似于被观察者，做了某件事）</span></span><br><span class="line">          userService.addUser(userParam);</span><br><span class="line">          <span class="comment">//然后就开始通知各个观察者。</span></span><br><span class="line">          <span class="keyword">for</span>(RegisterObserver temp:regObservers)&#123;</span><br><span class="line">               temp.sendMsg(<span class="string">&quot;注冊成功&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//利用spring的ApplicationContextAware，初始化所有观察者</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">          regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，观察者模式，就是将不同的行为代码解耦，也就是说<strong>将观察者和被观察者代码解耦</strong>。但是这里大家会发现，这是<strong>同步阻塞式的观察者模式</strong>，是有缺点的，比如发QQ消息异常，就会影响用户注册，或者发消息因为某些原因耗时，就影响了用户注册，所以可以考虑<strong>异步非阻塞</strong>的观察者模式。</p><h3 id="异步非阻塞方式的观察者模式"><a href="#异步非阻塞方式的观察者模式" class="headerlink" title="异步非阻塞方式的观察者模式"></a>异步非阻塞方式的观察者模式</h3><p>如何实现异步非阻塞，最简单就是另开个线程嘛，即<strong>新开个线程或者线程池异步跑观察者通知</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Collection&lt;RegisterObserver&gt; regObservers;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(&quot;register&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">          userService.addUser(userParam);</span><br><span class="line">          <span class="comment">//异步通知每个观察者</span></span><br><span class="line">          <span class="keyword">for</span> (RegisterObserver temp : regObservers) &#123;</span><br><span class="line">               executor.execute(() -&gt; &#123;</span><br><span class="line">                    temp.sendMsg(<span class="string">&quot;注冊成功&quot;</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">          regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池实现的异步非阻塞方式，还是可以的，但是异步执行逻辑都耦合在了<code>register()函数</code>中，不是很优雅，也增加了这部分业务代码的维护成本。一般日常工作中，我们会用<code>spring</code>那一套观察者模式等。</p><h3 id="spring观察者模式应用"><a href="#spring观察者模式应用" class="headerlink" title="spring观察者模式应用"></a>spring观察者模式应用</h3><p>spring的观察者模式使用也是比较简单的，就是先定义个事件，继承于<code>ApplicationEvent</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个事件监听器<code>MessageListener</code>，类似于<strong>观察者</strong>，它实现<code>ApplicationListener</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MessageEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MessageEvent messageEvent)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;用户注册成功，执行监听事件&quot;</span>+messageEvent.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户注册成功后，<code>applicationEventPublisher</code>（<strong>类似于被观察者</strong>）发布事件即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;springListenRegister&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">springListenRegister</span><span class="params">(UserParam userParam)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始注册&quot;</span>);</span><br><span class="line">        userService.addUser(userParam);</span><br><span class="line">        <span class="comment">//用户注册成功，发布事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">MessageEvent</span>(<span class="string">&quot;666&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始注册</span><br><span class="line">用户注册成功，执行监听事件666</span><br></pre></td></tr></table></figure><p>这个也是<strong>同步阻塞</strong>的方式实现的。</p><h4 id="Spring观察者模式原理"><a href="#Spring观察者模式原理" class="headerlink" title="Spring观察者模式原理"></a><strong>Spring观察者模式原理</strong></h4><p>Spring 中实现的观察者模式包含三部分：分别是<code>Event</code>事件（相当于消息）、<code>Listener</code>监听者（相当于观察者）、<code>Publisher</code>发送者（相当于被观察者）。用个图表示就是这样：</p><p><img src="/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2.png" alt="图片"></p><p><code>ApplicationEventPublisher</code>源代码（<strong>被观察者&#x2F;发布者</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  publishEvent((Object) event);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationEventPublisher</code>它只是一个函数式接口，我们再看下它接口方法的实现。它的具体实现类是<code>AbstractApplicationContext</code>，这个类代码有点多，我把关键部分代码贴出来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> extends ... &#123;</span><br><span class="line">  <span class="comment">//监听者（观察者列表）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造器，初始化观察者列表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发布事件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发布事件接口实现</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Object applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      <span class="comment">//如果event是ApplicationEvent对象,或者是它的子类</span></span><br><span class="line">      applicationEvent = (ApplicationEvent)event;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是ApplicationEvent对象或者它的子类，则将其包装成PayloadApplicationEvent事件，并获取对应的事件类型</span></span><br><span class="line">      applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>(<span class="built_in">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//真正的消息发送，是通过它。获取ApplicationEventMulticaster，调用multicastEvent方法广播事件</span></span><br><span class="line">      <span class="built_in">this</span>.getApplicationEventMulticaster().multicastEvent(</span><br><span class="line">            (ApplicationEvent)applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前命名空间还有父亲节点，也需要给父亲推送该消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">        ((AbstractApplicationContext)<span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加观察者（监听者）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    Assert.notNull(listener, <span class="string">&quot;ApplicationListener must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.applicationEventMulticaster != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationEventMulticaster.addApplicationListener(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.add(listener);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//观察者列表</span></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.applicationListeners;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册监听器</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//把提前存储好的监听器添加到监听器容器中到ApplicationEventMulticaster</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">   getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">     <span class="comment">//获取类型是ApplicationListener的beanName集合，此处不会去实例化bean</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">   getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//如果存在earlyEventsToProcess，提前处理这些事件</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以发现，真正的消息发送，实际上是通过事件广播器<code>ApplicationEventMulticaster </code>这个接口来完成的。<code>multicastEvent</code>是主要方法，这个方法的实现在类<code>SimpleApplicationEventMulticaster</code>中，我们一起来看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleApplicationEventMulticaster</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationEventMulticaster</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//线程池</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">protected</span> Executor <span class="title function_">getTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.taskExecutor;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(<span class="meta">@Nullable</span> Executor taskExecutor)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.taskExecutor = taskExecutor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 根据event类型获取适合的监听器</span></span><br><span class="line">  <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">   <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果executor不为空，异步调用执行监听器中的方法</span></span><br><span class="line">    executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用监听器的方法</span></span><br><span class="line">    invokeListener(listener, event);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">  <span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">    <span class="comment">//如果存在ErrorHandler，调用监听器方法(会用try...catch包一下)</span></span><br><span class="line">  <span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    doInvokeListener(listener, event);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">//如果抛出异常则调用ErrorHandler来处理异常。</span></span><br><span class="line">    errorHandler.handleError(err);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      否则直接调用监听器方法</span><br><span class="line">   doInvokeListener(listener, event);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以发现，<strong>默认情况下，spring实现的观察者模式，同步阻塞的</strong>。如果想异步执行事件，可以自定义<code>SimpleApplicationEventMulticaster</code>，然后构造一下<code>executor</code>线程池就好啦。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把线程池赋值进去</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">simpleApplicationEventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">        simpleApplicationEventMulticaster.setTaskExecutor(simpleAsyncTaskExecutor());</span><br><span class="line">        <span class="keyword">return</span> simpleApplicationEventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleAsyncTaskExecutor <span class="title function_">simpleAsyncTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册开始</span><br><span class="line">当前线程名称http-nio-8080-exec-1</span><br><span class="line">注册结束</span><br><span class="line">用户注册成功2，执行监听事件666Sat Jun 18 11:44:07 GMT+08:00 2022</span><br><span class="line">当前线程名称:SimpleAsyncTaskExecutor-20</span><br><span class="line">当前线程名称:SimpleAsyncTaskExecutor-19</span><br><span class="line">用户注册成功，执行监听事件666Sat Jun 18 11:44:12 GMT+08:00 2022</span><br></pre></td></tr></table></figure><p>如果手动新建<code>SimpleApplicationEventMulticaster</code>，并设置<code>taskExecutor</code>的话，所有的监听响应事件，都是<strong>异步执行</strong>的哦。而有些有些场景我们希望同步执行的，这时候这种实现方式就不好了。</p><p>其实<code>spring</code>提供了<code>@Async</code>注解，可以用来实现<strong>异步</strong>。具体怎么实现呢？其实很简单，只需要在<strong>配置类</strong>加上<code>@EnableAsync</code>，接着在需要异步执行的监听实现方法。加上<code>@Async</code>即可。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//配置类加上```@EnableAsync```</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerConfig2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">simpleApplicationEventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">        <span class="keyword">return</span> simpleApplicationEventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageAsyncListener3</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MessageEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//方法异步注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MessageEvent messageEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户注册成功3，执行监听事件&quot;</span> + messageEvent.getSource() + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程名称:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常开发中，异步执行也可以自己手动通过线程池来开启啦。回到我们本文的<strong>后端思维</strong>主题，如果每个开发，都自己定义观察者模式的实现，这种代码会很混乱，<strong>所以最好是实现一个可扩展，通用的观察者模板</strong>。</p><h3 id="基于spring观察者模式，抽取一个模板"><a href="#基于spring观察者模式，抽取一个模板" class="headerlink" title="基于spring观察者模式，抽取一个模板"></a><strong>基于spring观察者模式，抽取一个模板</strong></h3><p>基于spring实现观察者模式的话，就包括这三步：</p><ol><li>定义<code>Event</code>事件（相当于消息），一般定义一个<code>Event</code>对象，继承<code>ApplicationEvent</code></li><li>定义<code>Listener</code>监听者（相当于观察者），实现接口<code>ApplicationListener</code></li><li><code>Publisher</code>发送者（相当于被观察者），通过<code>ApplicationEventPublisher</code>发布。</li></ol><h4 id="定义Event事件对象"><a href="#定义Event事件对象" class="headerlink" title="定义Event事件对象"></a>定义<code>Event</code>事件对象</h4><p>定义一个<strong>项目相关的，通用</strong>的<code>BaseEvent</code>类，然后一些相关通用的信息属性可以放进去，比如<code>eventId</code>或者流水号<code>bizSeq</code>什么的，根据实际项目需要。以下代码，我定义一个空空如也的<code>BaseEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的观察者模式，是注册成功之后，发个消息的，你就可以声明一个消息类事件对象<code>RegisterMessageEvent</code>，继承通用的<code>BaseEvent</code>即可。然后属性可以自定义就好，比如<code>messageId</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterMessageEvent</span>  <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msgId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterMessageEvent</span><span class="params">(String msgId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.msgId = msgId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsgId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msgId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsgId</span><span class="params">(String msgId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msgId = msgId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果你想定义一个用户送礼物成功，然后发个广播，可以定义一个<code>GiftSendEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiftSendEvent</span> <span class="keyword">extends</span> <span class="title class_">BaseEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String giftId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GiftSendEvent</span><span class="params">(String giftId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.giftId = giftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGiftId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> giftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGiftId</span><span class="params">(String giftId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.giftId = giftId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务场景类似，只要想接入你的观察者模板，只需要自己定义事件对象，继承于你的<code>BaseEvent</code>即可。</p><h4 id="定义Listener监听者（观察者）"><a href="#定义Listener监听者（观察者）" class="headerlink" title="定义Listener监听者（观察者）"></a>定义<code>Listener</code>监听者（观察者）</h4><p>定义完<code>Event</code>事件，我们就可以开始定义监听者了。我们定义的监听者，只需要实现接口<code>ApplicationListener</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span> <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听者的实现，关键在于实现<code>ApplicationListener</code>的<code>onApplicationEvent</code>的接口方法即可。又因为未来别的业务场景接入观察者模式，都是按你的模板来，所以各个<code>Event</code>事件对象，都是继承于你的<code>BaseEvent</code>的，所以我们可以把**&lt; T extends BaseEvent &gt;**的泛型加进去，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，可能会有这种场景，就是执行<strong>监听逻辑</strong>，<strong>只对部分数据（或者说部分特殊用户才执行）</strong>。既然我们是抽取监听模板，考虑到可扩展性，我们可以优化下<code>IEventListener</code>的代码。我们可以声明一个support的方法，默认是执行的,子类可以覆盖重写（让子类去控制是否执行这个监听逻辑），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口里面，加了default，就可以写方法实现</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢，只有<code>support</code>方法返回<code>true</code>，才执行<strong>监听的逻辑</strong>，我们还可以定义一个<code>handler</code>方法，给子类去实现自己的业务逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (support(event)) &#123;</span><br><span class="line">            handler(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正实现业务逻辑的接口，给子类去实现。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给<code>onApplicationEvent</code>的实现<code>try...catch...</code>一下，如果<code>catch</code>住异常的话，可以定义一个<code>handlerException</code>异常处理方法，给子类自定义去实现，当然，异常可以默认不处理嘛，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEventListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 观察者的业务逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(T event)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (support(event)) &#123;</span><br><span class="line">                handler(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            handleException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认执行观察者的逻辑的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  观察者的逻辑，交给不同子类自定义实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(T event)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常默认不处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Throwable exception)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>最后呢，不同业务不同的监听者（观察者），直接实现你的<code>IEventListener</code>就好啦，比如注册成功那个，我们声明一个<code>RegisterMessageListenerImpl</code>类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterMessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">IEventListener</span>&lt;RegisterMessageEvent&gt; &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(RegisterMessageEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户注册成功register，执行监听事件&quot;</span> + event.getSource() + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义Publisher发送者模板"><a href="#定义Publisher发送者模板" class="headerlink" title="定义Publisher发送者模板"></a>定义<code>Publisher</code>发送者模板</h4><p>最后一步就是<strong>定义发送者模板</strong>。最简单的发送，就是利用<code>ApplicationContext</code>直接发送就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublish</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext继承了ApplicationEventPublisher接口，所以可以用applicationContext发布事件。</p><p>这个只是同步阻塞方式的观察者模式，一般来说，一个<strong>通用的观察者模板</strong>。也需要提供异步非阻塞方式的观察者模板。为了方便管理，和API语义更明确，我们可以手动设置线程池，给我们的模板发布类，提供异步发送的接口。我们先自定义一个线程池，一般<strong>不建议</strong>直接使用JDK的线程池。</p><p><strong>自定义线程池</strong></p><p>我们在<code>application.properties</code>配置文件，定义线程池一些属性（核心线程数、最大线程数等等）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">executor.corePoolSize</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">executor.maxPoolSize</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">executor.queueCapacity</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">executor.keepAliveSeconds</span>=<span class="string">120</span></span><br><span class="line"><span class="attr">executor.threadNamePrefix</span>=<span class="string">threadPoolExecutor</span></span><br></pre></td></tr></table></figure><p>声明一个线程配置类<code>TianLuoExecutorsConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;executor&quot;)</span><span class="comment">//读取配置文件的线程池属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TianLuoExecutorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get和set的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过线程配置类<code>TianLuoExecutorsConfig</code>，初始化线程池<code>TianLuoExecutorPool</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TianLuoExecutorPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TianLuoExecutorsConfig tianLuoExecutorsConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">eventExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(tianLuoExecutorsConfig.getCorePoolSize());</span><br><span class="line">        executor.setMaxPoolSize(tianLuoExecutorsConfig.getMaxPoolSize());</span><br><span class="line">        executor.setKeepAliveSeconds(tianLuoExecutorsConfig.getKeepAliveSeconds());</span><br><span class="line">        executor.setQueueCapacity(tianLuoExecutorsConfig.getQueueCapacity());</span><br><span class="line">        executor.setThreadNamePrefix(tianLuoExecutorsConfig.getThreadNamePrefix());</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后回到<code>EventPublish</code>，把异步发布的接口加上，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TianLuoExecutorPool tianLuoExecutorPool;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//同步阻塞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步发布（异步非阻塞）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncPublish</span><span class="params">(BaseEvent event)</span> &#123;</span><br><span class="line">        tianLuoExecutorPool.eventExecutor().execute(()-&gt;&#123;</span><br><span class="line">            publish(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch的原理是什么?</title>
      <link href="/2023/10/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/CountDownLatch%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2023/10/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/CountDownLatch%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>使用CountDownLatch可以实现等待多个线程执行完毕的功能，实现线程之间的协调，让它们按照我们期望的顺序执行，从而避免了可能出现的并发问题。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nThreads</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 需要等待的线程数</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">5000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished...&quot;</span>);</span><br><span class="line">            <span class="comment">// 任务完成，计数器减1</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;All threads have finished.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们创建了一个CountDownLatch实例，并将需要等待的线程数设置为5。然后，我们启动5个线程来执行任务，每个线程执行的时间并不相同，并在每个线程执行完任务后调用 countDown() 方法将计数器减1。</p><p>最后，在主线程中我们调用 await() 方法来使当前线程等待，直到所有线程完成任务并计数器减为 0 为止。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>关键代码其实就三行。</p><ol><li><p><code>new CountDownLatch(5)</code> 创建 CountDownLatch 实例，设置为state 为 5,相当于是个信号量。</p></li><li><p><code>latch.countDown()</code>任务执行完成，分别减少 state。</p></li><li><p><code>latch.await()</code>主线程检查其他线程是否全部执行完成，否则等待。</p></li></ol><p>信号量：那是多线程同步用的，一个线程完成了某一个动作就通过信号告诉别的线程，别的线程再进行某些动作。</p><p>互斥量：这是多线程互斥用的，比如说，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程离开，其他的线程才开始可以利用这个资源。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>在创建 CountDownLatch 实例的时候，传入一个参数 5。它实现了内部类 Sync， 并且 Sync 继承了 AbstractQueuedSynchronizer（AQS）类。这里设置的 State 其实就是 AQS 中的 state 成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CountDownLatch.Sync</span></span><br><span class="line">Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 中，state 用来表示这个线程是否还持有锁，每次加锁就对 state 加1，如果有重入的情况就继续增加。释放一次锁就减少1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><h2 id="执行countDown"><a href="#执行countDown" class="headerlink" title="执行countDown"></a>执行countDown</h2><p>设置完线信号量之后，在每个线程执行结束后会执行 <code>latch.countDown()</code>将 state 减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 releaseShared 方法中，他会尝试 state 减1，这里是一个死循环，也就是自旋锁。通过CAS的方式线程安全的修改 state的值，如果不成功，就通过自旋锁不断去尝试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//CAS</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在状态更新后会进入 doReleaseShared ，他会解锁这个队列中的所有线程。正常来说，走到这里都是运行状态的。但是如果主线程先走到了 await方法，这个队列中就会唤醒主线程检查state是否等于0。</p><p>子线程执行完后就结束了，不会添加到等待队列和同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//这里说明了头节点后面是有节点的，需要被唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">           <span class="comment">//CAS更新状态</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//head.waitStatus=0的情况有两种</span></span><br><span class="line">            <span class="comment">//1、就是head节点没有及时更新，线程被唤醒之后获取到了锁，在更新head之前，又经过一轮循环执行到这。  但是如果节点没有及时更新就会退出。所以执行到这一步只可能是情况2</span></span><br><span class="line">            <span class="comment">//2、head节点及时更新了，但是到了最后一个节点，它的head.waitStatus=0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点没有及时更新，就退出。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p>在主线程执行的时候，到达 await方法会检查当前的 state 是否等于0，如果不等于就返回 -1，进入 <code>doAcquireSharedInterruptibly</code> 逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 检查 state 是否等于0，不等于返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doAcquireSharedInterruptibly 方法中，会通过自旋锁不断检查 state。第二次自选检查的时候会被阻塞进入队列，然后等待子线程调用 countDown 方法的时候幻醒主线程，继续自选检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//自旋不断检查是否state=0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二次自旋，park等待</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2023/10/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/CountDownLatch%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/1.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CountDownLatch </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文彻底搞懂线程安全</title>
      <link href="/2023/10/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2023/10/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>关于线程安全问题是一块非常基础的知识，但基础不代表简单，一个人的基本功能往往能决定他是否可以写出高质量、高性能的代码。关于什么是synchronized、Lock、volatile，虽然都能道出一二，但概念都懂一用就懵，一不小心还能写出一个死锁出来。</p><span id="more"></span><h1 id="线程安全问题的诞生背景以及解决方式"><a href="#线程安全问题的诞生背景以及解决方式" class="headerlink" title="线程安全问题的诞生背景以及解决方式"></a>线程安全问题的诞生背景以及解决方式</h1><h2 id="为什么线程间需要通信？"><a href="#为什么线程间需要通信？" class="headerlink" title="为什么线程间需要通信？"></a>为什么线程间需要通信？</h2><p>线程是CPU执行的基本单位，为了提高CPU的使用率以及模拟多个应用程序同时运行的场景，便衍生出了多线程的概念。</p><p>在JVM架构下堆内存、方法区是可以被线程共享的，举个例子简要描述下：</p><p>现要做一个网络请求，请求响应后渲染到手机界面。Android为了提升用户体验将main线程当作UI线程，只做界面渲染，耗时操作应交由到工作线程。如若在UI线程执行耗时操作可能会出现阻塞现象，最直观的感受就是界面卡死。网络请求属于IO操作会出现阻塞想象，前面提到UI线程不允许出现阻塞现象，所以网络请求必须扔到工作线程，但拿到数据包后怎么传递给UI线程呢？最常规的做法就是回调接口，将HTTP数据包解析成本地模型，再通过接口将本地模型对应的堆内存地址值传递到UI线程。工作线程将堆内存对象地址值交给UI线程这一过程，就是线程间通信，也是JVM将堆内存设置为线程共享的原因，关于线程间通信用一句通俗易懂的话描述就是：”多个线程操作同一资源”，这一资源位于堆内存或方法区。</p><h2 id="单生产单消费引发的安全问题"><a href="#单生产单消费引发的安全问题" class="headerlink" title="单生产单消费引发的安全问题"></a>单生产单消费引发的安全问题</h2><p>“多个线程操作同一资源”，听起来如此的简单，殊不知一不小心便可能引发致命问题。</p><p><strong>案例</strong></p><p>现有一个车辆公司，主要经营四轮小汽车和两轮自行车，工人负责生产，销售员负责售卖。</p><p>以上案例如何通过应用程序来实现？思路如下：</p><p>定义一个车辆资源类，可以设置为小汽车和自行车</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="comment">//一辆车对应一个id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">//车名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//车的轮子数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wheelNumber;</span><br><span class="line">    <span class="comment">//标记(后面会用到)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    忽略setter、getter</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;--- name=&quot;</span> + name  + <span class="string">&quot;--- wheelNumber=&quot;</span> + wheelNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个工人线程任务，专门用来生产四轮小汽车和俩轮自行车，为生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Input</span><span class="params">(Resource r)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//无限生产车辆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                r.setName(<span class="string">&quot;小汽车&quot;</span>);<span class="comment">//设置车类型</span></span><br><span class="line">                r.setWheelNumber(<span class="number">4</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                r.setName(<span class="string">&quot;电动车&quot;</span>);<span class="comment">//设置车类型</span></span><br><span class="line">                r.setWheelNumber(<span class="number">2</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个销售员线程任务，专门用来销售车辆，为消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Output</span><span class="params">(Resource r)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//无限消费车辆</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//消费车辆</span></span><br><span class="line">            System.out.println(r.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始生产、消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源对象，对应车辆</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line"><span class="comment">//生产者runnable，对应工人</span></span><br><span class="line"><span class="type">Input</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(r);</span><br><span class="line"><span class="comment">//消费者runnable，对应销售员</span></span><br><span class="line"><span class="type">Output</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(r);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(in);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(out);</span><br><span class="line"><span class="comment">//开启生产者线程</span></span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//开启消费者线程</span></span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">id=51--- name=电动车--- wheelNumber=2</span><br><span class="line">id=52--- name=小汽车--- wheelNumber=2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>出现了一个严重问题 编号为52的小汽车少装了俩轮子！！！</p><p><strong>导致原因：</strong></p><p>tips：流程对应上面打印结果。下同</p><ul><li>生产者线程得到CPU执行权，将name和<code>wheelNumber</code>分别设置为电动车和2，随后CPU切换到了消费者线程。</li><li>消费者线程得到CPU执行权，此时name和<code>wheelNumber</code>别为电动车和2，随后打印<code>name=电动车--- wheelNumber=2</code>，CPU切换到了生产者线程。</li><li>生产者线程再次得到CPU执行权，将name设置为小汽车(未对wheelNumber进行设置)，此时name和<code>wheelNumber</code>分别为小汽车和2，CPU切换到了消费者线程。</li><li>消费者线程得到CPU执行权，此时name和<code>wheelNumber</code>别为小汽车和2，随后打印<code>name=小汽车--- wheelNumber=2</code></li></ul><p>工人：”生产到一半你销售员就拿去卖了，这锅我不背”</p><p><strong>解决方案：</strong></p><p>导致原因其实就是生产者对Resource的一次操作还未结束，消费者强行介入了。此时可以引入synchronized关键字，使得生产者一次工作结束前消费者不得介入</p><p>更改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#Input</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//无限生产车辆</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;;i++)&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">               r.setName(<span class="string">&quot;小汽车&quot;</span>);<span class="comment">//设置车类型</span></span><br><span class="line">               r.setWheelNumber(<span class="number">4</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">               r.setName(<span class="string">&quot;电动车&quot;</span>);<span class="comment">//设置车类型</span></span><br><span class="line">               r.setWheelNumber(<span class="number">2</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">#Output</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">           <span class="comment">//消费车辆</span></span><br><span class="line">           System.out.println(r.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者和消费者for循环中都加了一个synchronized，对应的锁是r，修改后重新执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">id=79--- name=电动车--- wheelNumber=2</span><br><span class="line">id=80--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=80--- name=小汽车--- wheelNumber=4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一切又恢复了正常。但又暴露出一个更严重的问题，编号为80的小汽车被消费(销售)了两次</p><p><strong>导致原因：</strong></p><ul><li>生产者线程得到CPU执行权，将name和<code>wheelNumber</code>分别设置为小汽车和4，随后CPU执行权切换到了消费者线程。</li><li>消费者线程得到CPU执行权，此时name和<code>wheelNumber</code>别为小汽车和4，随后打印<code>name=小汽车--- wheelNumber=4</code>，但消费后 CPU执行权并未切换到生产者线程，而是由消费者线程继续执行，于是就出现了编号为80的小汽车被打印（消费）了两次</li></ul><p><strong>解决方案：</strong></p><p>产生问题的原因就是消费者把资源消费后未处于等待状态，而是继续消费。此时可以引入wait、notify机制，使得销售员售卖完一辆车后处于等待状态，当工人重新生产一辆新车后再通知销售员，销售员接收到工人消息后再进行售卖。</p><p>更改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#Input</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//无限生产车辆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;;i++)&#123;</span><br><span class="line">         <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">              <span class="comment">//flag为true的时候代表已经生产过，此时将当前线程wait，等待消费者消费</span></span><br><span class="line">              <span class="keyword">if</span>(r.isFlag())&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      r.wait();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                  r.setName(<span class="string">&quot;小汽车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                  r.setWheel(<span class="number">4</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                  r.setName(<span class="string">&quot;电动车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                  r.setWheel(<span class="number">2</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">              &#125;</span><br><span class="line">              r.setFlag(<span class="literal">true</span>);</span><br><span class="line">              <span class="comment">//将线程池中的线程唤醒</span></span><br><span class="line">              r.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#Output</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//无限消费车辆</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">             <span class="comment">//flag为false，代表当前生产的车已经被消费掉，</span></span><br><span class="line">             <span class="comment">//进入wait状态等待生产者生产</span></span><br><span class="line">             <span class="keyword">if</span>(!r.isFlag())&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     r.wait();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//消费车辆</span></span><br><span class="line">             System.out.println(r.toString());</span><br><span class="line">             r.setFlag(<span class="literal">false</span>);</span><br><span class="line">             <span class="comment">//将线程池中的线程唤醒</span></span><br><span class="line">             r.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">id=129--- name=电动车--- wheelNumber=2</span><br><span class="line">id=130--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=131--- name=电动车--- wheelNumber=2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>注意点1：</strong></p><p>synchronized括号内传入的是一把锁，可以是任意类型的对象，生产者消费者必须使用同一把锁才能实现同步操作。这样设计的目的是为了更灵活使用同步代码块，否则整个进程那么多synchronized，锁谁不锁谁根本不明确</p><p><strong>注意点2：</strong></p><p>wait、notify其实是object的方法，它们只能在synchronized代码块内由锁进行调用，否则就会抛异常。每一把锁对应线程池的一块区域，被wait的线程会被放入到锁对应的线程池区域，并且释放锁。notify会随机唤醒锁对应线程池区域的任意一个线程，线程被唤醒后会重新上锁，注意是随机唤醒任意一个线程。</p><h1 id="由死锁问题看显示锁-Lock-的应用场景"><a href="#由死锁问题看显示锁-Lock-的应用场景" class="headerlink" title="由死锁问题看显示锁 Lock 的应用场景"></a>由死锁问题看显示锁 Lock 的应用场景</h1><h2 id="何为死锁？"><a href="#何为死锁？" class="headerlink" title="何为死锁？"></a>何为死锁？</h2><p>关于死锁，顾名思义应该是锁死了，它可以使线程处于假死状态但又没真死，卡在半道又无法被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deadlock1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1;</span><br><span class="line">    <span class="keyword">private</span> Object lock2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Deadlock1</span><span class="params">(Object obj1,Object obj2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lock1 = obj1;</span><br><span class="line">        <span class="built_in">this</span>.lock2 = obj2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Deadlock1----lock1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(lock2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Deadlock1----lock2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deadlock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1;</span><br><span class="line">    <span class="keyword">private</span> Object lock2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Deadlock2</span><span class="params">(Object obj1,Object obj2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lock1 = obj1;</span><br><span class="line">        <span class="built_in">this</span>.lock2 = obj2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Deadlock2----lock2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(lock1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Deadlock2----lock1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#运行</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Deadlock1</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Deadlock1</span>(lock1,lock2);</span><br><span class="line">      <span class="type">Deadlock2</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Deadlock2</span>(lock1,lock2);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(d1);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(d2);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deadlock1----lock1</span><br><span class="line">Deadlock2----lock2</span><br></pre></td></tr></table></figure><p><code>run()</code>方法中写的是无限循环，按理来说应该是无限打印。但程序运行后，在我没有终止控制台的情况下只打印了这两行数据。实际上这一过程引发了死锁，具体缘由如下：</p><ul><li>线程t1执行，判断了第一个同步代码块，此时锁lock1可用，于是持着锁lock1进入了第一个同步代码块，打印了：<code>Deadlock1----lock1</code>，随后线程切换到了线程t2</li><li>线程t2执行，判断第一个同步代码块，此时锁lock2可用，于是持着锁lock2进入了第一个同步代码块，打印了：<code>Deadlock2----lock2</code>，接着向下执行，判断锁lock1不可用(因为锁lock1已经被线程t1所占用)，于是线程t1进行等待.随后再次切换到线程t1</li><li>线程t1执行，判断第二个同步代码块，此时锁lock2不可用(因为所lock2已经被线程t2所占用)，线程t1也进入了等待状态</li></ul><p>通过以上描述可知：线程t1持有线程t2需要的锁进行等待，线程t2持有线程t1所需要的锁进行等待，两个线程各自拿着对方需要的锁处于一种僵持现象，导致线程假死即死锁</p><p>以上案例只是死锁的一种，死锁的标准就是判断线程是否处于假死状态</p><h2 id="多生产多消费场景的死锁如何避免？"><a href="#多生产多消费场景的死锁如何避免？" class="headerlink" title="多生产多消费场景的死锁如何避免？"></a>多生产多消费场景的死锁如何避免？</h2><p>第一小节主要是在讲单生产单消费，为了进一步提升运行效率可以适当引入多生产多消费，既多个生产者多个消费者。继续引用第一小节案例，稍作改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="comment">//将i写为成员变量而不是写在for循环中是为了方便讲解下面多生产多消费的内容，没必要纠结这点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Input</span><span class="params">(Resource r)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//无限生产车辆</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">                <span class="comment">//flag为true的时候代表已经生产过，此时将当前线程wait，等待消费者消费</span></span><br><span class="line">                <span class="keyword">if</span>(r.isFlag())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                    r.setName(<span class="string">&quot;小汽车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                    r.setWhell(<span class="number">4</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                    r.setName(<span class="string">&quot;电动车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                    r.setWhell(<span class="number">2</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                r.setFlag(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//将线程池中的线程唤醒</span></span><br><span class="line">                r.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(r);</span><br><span class="line">        <span class="type">Output</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(r);</span><br><span class="line">        Thread in1= <span class="keyword">new</span> <span class="title class_">Thread</span>(in);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(in);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">out1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(out);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">out2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(out);</span><br><span class="line">        in1.start();<span class="comment">//开启生产者1线程</span></span><br><span class="line">        in2 .start();<span class="comment">//开启生产者2线程</span></span><br><span class="line">        out1 .start();<span class="comment">//开启消费者1线程</span></span><br><span class="line">        out2 .start();<span class="comment">//开启消费者2线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id=211--- name=自行车--- wheelNumber=2</span><br><span class="line">id=220--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=220--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=220--- name=小汽车--- wheelNumber=4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>安全问题又产生了，编号为211-220的车辆未被打印，也即生产了未被消费。同时编号为220的车辆被打印了三次。先别着急，我接着给大家分析：</p><ul><li>生产者线程in1得到执行权，生产了id为211的车辆，将flag置为true，循环回来再判断标记为true，此时执<code>wait()</code>方法进入等待状态</li><li>生产者线程in2得到执行权，判断标记为true，执行<code>wait()</code>方法进入等待状态。</li><li>消费者线程out1得到执行权，判断标记为true，不进行等待而是选择了消费id为211的车辆，消费完毕后将标记置为false并执行<code>notify()</code>将线程池中的任意一个线程给唤醒，假设唤醒的是in1</li><li>生产者线程in1再次得到执行权，此时生产者线程in1被唤醒后不会判断标记而是选择生产一辆id为1的车辆，随后将标记置为true并执行<code>notify()</code>将线程池中任意一个线程给唤醒，假设唤醒的是in2</li><li>生产者线程in2再次得到执行权，此时生产者线程in2被唤醒后不会判断标记而是直接生产了一辆id为212的车辆，随后唤醒in1生产id为213的车辆，再唤醒in2…..</li></ul><p>以上即为编号211-220的车辆未被打印的原因，编号为220车辆重复打印同理。</p><p>如何解决？其实很简单，将生产者和消费者判断flag地方的if更改成while,被唤醒后重新再判断标记即可。代码就不重复贴了，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id=0--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=1--- name=电动车--- wheelNumber=2</span><br><span class="line">id=2--- name=小汽车--- wheelNumber=4</span><br><span class="line">id=3--- name=电动车--- wheelNumber=2</span><br><span class="line">id=4--- name=小汽车--- wheelNumber=4</span><br></pre></td></tr></table></figure><p>看起来很正常，但在我没有关控制台的情况下打印到编号为4的车辆时停了，没错，死锁出现了，具体原因如下：</p><ul><li>线程in1开始执行，生产了一辆车将flag置为true，循环回来判断flag进入<code>wait()</code>状态，此时线程池中进行等待的线程有：in1</li><li>线程in2开始执行，判断flag为true进入<code>wait()</code>状态，此时线程池中进行等待的线程有：in1，in2</li><li>线程out1开始执行，判断flag为true，消费了一辆汽车将flag置为false并唤醒一个线程，我们假定唤醒的为in1(这里需要注意，被唤醒并不意味着会立刻执行，只是当前具备着执行资格但并不具备执行权)，线程out1循环回来判读flag进入wait状态，此时线程池中的线程有in2，out1，随后out2得到执行权</li><li>线程out2开始执行，判断标记为false，进入等待状态，此时线程池中的线程有in2，out1，out2</li><li>线程in1开始执行，判断标记为false，生产了一辆汽车必将flag置为true并唤醒线程池中的一个线程，我们假定唤醒的是in2，随后in1循环判断flag进入<code>wait()</code>状态，此时线程池中的线程有in1，out1，out2</li><li>线程int2得到执行权，判断标记为false，进入<code>wait()</code>状态，此时线程池中的线程有in1，in2，out1，out2</li></ul><p>所有生产者消费者线程都被wait掉了，导致了死锁现象的产生。根本原因在于生产者wait后理应唤醒消费者，而不是唤醒生产者，object还有一个方法<code>notifyAll()</code>，它可以唤醒锁对应线程池区域的所有线程，所以将notify替换成notifyAll即可解决以上死锁问题</p><h2 id="通过-Lock-优雅的解决死锁问题"><a href="#通过-Lock-优雅的解决死锁问题" class="headerlink" title="通过 Lock 优雅的解决死锁问题"></a>通过 Lock 优雅的解决死锁问题</h2><p>提到的<code>notifyAll</code>是可以解决死锁问题，但不够优雅，因为<code>notifyAll()</code>会唤醒对应线程池所有线程，单其实只需要唤醒一个即可，多了就会造成线程反复被wait，进而会造成性能问题。所以后来Java在1.5版本引入了显示锁Lock的概念，它可以灵活的指定wait、notify的作用域，专门用来解决此类问题。</p><p>通过显示锁Lock对2.2死锁问题改进后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#生产者</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition in_con;<span class="comment">//生产者监视器</span></span><br><span class="line">    <span class="keyword">private</span> Condition out_con;<span class="comment">//消费者监视器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Input</span><span class="params">(Resource r,Lock lock,Condition in_con,Condition out_con)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.in_con = in_con;</span><br><span class="line">        <span class="built_in">this</span>.out_con = out_con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//无限生产车辆</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            lock.lock();<span class="comment">//获取锁</span></span><br><span class="line">            <span class="comment">//flag为true的时候代表已经生产过，此时将当前线程wait，等待消费者消费</span></span><br><span class="line">            <span class="keyword">while</span>(r.isFlag())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in_con.await();<span class="comment">//跟wait作用相同</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                r.setName(<span class="string">&quot;小汽车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                r.setWhell(<span class="number">4</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r.setId(i);<span class="comment">//设置车的id</span></span><br><span class="line">                r.setName(<span class="string">&quot;电动车&quot;</span>);<span class="comment">//设置车的型号</span></span><br><span class="line">                r.setWhell(<span class="number">2</span>);<span class="comment">//设置车的轮子数</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            r.setFlag(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//将线程池中的消费者线程唤醒</span></span><br><span class="line">            out_con.signal();</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition in_con;<span class="comment">//生产者监视器</span></span><br><span class="line">    <span class="keyword">private</span> Condition out_con;<span class="comment">//消费者监视器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Output</span><span class="params">(Resource r,Lock lock,Condition in_con,Condition out_con)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.in_con = in_con;</span><br><span class="line">        <span class="built_in">this</span>.out_con = out_con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//无限消费车辆</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            lock.lock();<span class="comment">//获取锁</span></span><br><span class="line">            <span class="keyword">while</span>(!r.isFlag())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out_con.await();<span class="comment">//将消费者线程wait</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(r.toString());</span><br><span class="line">            r.setFlag(<span class="literal">false</span>);</span><br><span class="line">            in_con.signal();<span class="comment">//唤醒生产者线程</span></span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="comment">//生产者监视器</span></span><br><span class="line">        <span class="type">Condition</span> <span class="variable">in_con</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="comment">//消费者监视器</span></span><br><span class="line">        <span class="type">Condition</span> <span class="variable">out_con</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(r,lock,in_con,out_con);</span><br><span class="line">        <span class="type">Output</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(r,lock,in_con,out_con);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(in);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(in);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(out);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(out);</span><br><span class="line">        t1.start();<span class="comment">//开启生产者线程</span></span><br><span class="line">        t2.start();<span class="comment">//开启生产者线程</span></span><br><span class="line">        t3.start();<span class="comment">//开启消费者线程</span></span><br><span class="line">        t4.start();<span class="comment">//开启消费者线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中Lock对应synchronized，Condition为Lock下的监视器，每一个监视器对应一个wait、notify作用域</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多线程是用来提升CUP使用率的</li><li>多个线程访问同一资源可能会引发安全问题</li><li>synchronized配合wait、notify可以解决线程安全问题</li><li>Lock可以解决synchronized下wait、notify的局限性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>命令模式是一种行为型设计模式，它允许您将请求封装成对象，从而允许您根据不同的请求、队列或者日志来参数化其他对象，并支持可撤销的操作。</p><span id="more"></span><h2 id="什么是命令模式？"><a href="#什么是命令模式？" class="headerlink" title="什么是命令模式？"></a>什么是命令模式？</h2><p>命令模式是一种行为型设计模式，它将请求或操作封装成独立的命令对象。这些命令对象包括了执行操作所需的所有信息，例如操作方法、参数和接收者。命令模式允许您将命令发送者（客户端）和命令执行者（接收者）解耦，使得发送者无需知道接收者的具体类别。</p><p>在命令模式中，通常包含以下关键角色：</p><ol><li><strong>命令（Command）</strong>：声明了执行操作的接口，通常包括一个 <strong><code>execute</code></strong> 方法。</li><li><strong>具体命令（Concrete Command）</strong>：实现了命令接口，包含了实际的操作逻辑。每个具体命令对象都与一个接收者相关联。</li><li><strong>接收者（Receiver）</strong>：执行命令实际操作的对象。</li><li><strong>调用者（Invoker）</strong>：负责调用命令对象来执行请求。</li><li><strong>客户端（Client）</strong>：创建命令对象并设置其接收者，然后将命令对象传递给调用者。</li></ol><h2 id="为什么需要命令模式？"><a href="#为什么需要命令模式？" class="headerlink" title="为什么需要命令模式？"></a>为什么需要命令模式？</h2><p>命令模式有以下几个优点：</p><ol><li><strong>解耦</strong>：命令模式可以将发送者和接收者解耦，发送者无需知道接收者的具体实现，从而提高了系统的灵活性。</li><li><strong>可扩展性</strong>：您可以轻松地添加新的命令类，而无需修改已有的代码。</li><li><strong>撤销操作</strong>：命令对象通常会保存操作的状态，从而支持撤销操作。</li><li><strong>日志记录和事务管理</strong>：您可以使用命令模式来记录所有执行的命令，以便进行事务管理或撤销。</li></ol><h2 id="命令模式的实现"><a href="#命令模式的实现" class="headerlink" title="命令模式的实现"></a>命令模式的实现</h2><p>让我们通过一个简单的示例来演示命令模式的实现。假设我们正在构建一个遥控器应用，用户可以通过遥控器执行不同的操作，例如打开电视、切换频道和调整音量。</p><p>首先，我们定义一个命令接口 **<code>Command</code>**，它包括了一个 <strong><code>execute</code></strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建具体的命令类，例如 <strong><code>TurnOnCommand</code><strong>、</strong><code>ChangeChannelCommand</code></strong> 和 **<code>AdjustVolumeCommand</code>**，它们实现了 <strong><code>Command</code></strong> 接口，并分别执行相应的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Television television;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOnCommand</span><span class="params">(Television television)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.television = television;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        television.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似地实现 ChangeChannelCommand 和 AdjustVolumeCommand</span></span><br></pre></td></tr></table></figure><p>然后，我们创建接收者类 **<code>Television</code>**，它包含了实际的操作逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Television</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电视已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;切换频道&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustVolume</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调整音量&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们创建调用者类 **<code>RemoteControl</code>**，它接收并执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Television</span> <span class="variable">television</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Television</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Command</span> <span class="variable">turnOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOnCommand</span>(television);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">changeChannelCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeChannelCommand</span>(television);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">adjustVolumeCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdjustVolumeCommand</span>(television);</span><br><span class="line"></span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line"></span><br><span class="line">        remoteControl.setCommand(turnOnCommand);</span><br><span class="line">        remoteControl.pressButton();</span><br><span class="line"></span><br><span class="line">        remoteControl.setCommand(changeChannelCommand);</span><br><span class="line">        remoteControl.pressButton();</span><br><span class="line"></span><br><span class="line">        remoteControl.setCommand(adjustVolumeCommand);</span><br><span class="line">        remoteControl.pressButton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，我们将不同的操作（打开电视、切换频道、调整音量）封装成了命令对象，通过遥控器执行这些命令，而不需要直接调用接收者的方法。</p><h2 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h2><p>宏命令是一种命令模式的扩展，它允许您将多个命令组合成一个更大的命令。宏命令本身也是一个命令，可以执行一系列子命令。这对于执行复杂的操作或者创建多级撤销机制非常有用。</p><p>让我们通过一个示例来了解宏命令。假设我们有一个文本编辑器，需要实现一个宏命令来执行以下操作：</p><ol><li>打开文件</li><li>编辑文件</li><li>保存文件</li></ol><p>首先，我们定义一个宏命令接口 <strong><code>MacroCommand</code></strong> ，它包含了 <strong><code>add</code></strong> 和 <strong><code>execute</code></strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MacroCommand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command command)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个具体的宏命令类 <strong><code>TextEditorMacro</code></strong> ，它可以添加和执行多个子命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditorMacro</span> <span class="keyword">implements</span> <span class="title class_">MacroCommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以创建多个子命令，例如 <strong><code>OpenFileCommand</code><strong>、</strong><code>EditFileCommand</code></strong> 和 <strong><code>SaveFileCommand</code></strong>  ，它们分别执行打开、编辑和保存文件的操作。最后，我们可以使用宏命令将这些子命令组合成一个宏命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OpenFileCommand</span> <span class="variable">openFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenFileCommand</span>();</span><br><span class="line">        <span class="type">EditFileCommand</span> <span class="variable">editFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EditFileCommand</span>();</span><br><span class="line">        <span class="type">SaveFileCommand</span> <span class="variable">saveFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaveFileCommand</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">TextEditorMacro</span> <span class="variable">macro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditorMacro</span>();</span><br><span class="line">        macro.add(openFile);</span><br><span class="line">        macro.add(editFile);</span><br><span class="line">        macro.add(saveFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行宏命令，依次执行子命令</span></span><br><span class="line">        macro.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个宏命令，可以一次性执行多个子命令，从而打开、编辑和保存文件。</p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><p>命令模式还支持撤销和重做操作。</p><p>为了实现撤销，我们需要在命令对象中保存执行前的状态，并提供一个 <strong><code>undo</code></strong> 方法来恢复到之前的状态。</p><p>让我们通过一个简单的示例来演示撤销和重做。假设我们有一个文本编辑器，可以执行添加文本、删除文本和撤销操作。</p><p>首先，我们定义一个命令接口 <strong><code>Command</code></strong> ，包括了 <strong><code>execute</code></strong> 和 <strong><code>undo</code></strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建具体的命令类，例如 <strong><code>AddTextCommand</code></strong> 和 <strong><code>DeleteTextCommand</code></strong> ，它们分别执行添加文本和删除文本的操作，并实现了 <strong><code>undo</code></strong> 方法来撤销操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddTextCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextEditor textEditor;</span><br><span class="line">    <span class="keyword">private</span> String addedText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTextCommand</span><span class="params">(TextEditor textEditor, String addedText)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textEditor = textEditor;</span><br><span class="line">        <span class="built_in">this</span>.addedText = addedText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        textEditor.addText(addedText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        textEditor.deleteText(addedText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似地实现 DeleteTextCommand</span></span><br></pre></td></tr></table></figure><p>然后，我们创建接收者类 <strong><code>TextEditor</code></strong> ，它包含了实际的文本编辑逻辑，包括添加文本、删除文本和显示文本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addText</span><span class="params">(String addedText)</span> &#123;</span><br><span class="line">        text.append(addedText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteText</span><span class="params">(String deletedText)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> text.lastIndexOf(deletedText);</span><br><span class="line">        <span class="keyword">if</span> (start != -<span class="number">1</span>) &#123;</span><br><span class="line">            text.delete(start, start + deletedText.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayText</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以创建一个客户端来测试撤销和重做操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TextEditor</span> <span class="variable">textEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Command</span> <span class="variable">addCommand1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTextCommand</span>(textEditor, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">addCommand2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTextCommand</span>(textEditor, <span class="string">&quot;Design Patterns!&quot;</span>);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">deleteCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteTextCommand</span>(textEditor, <span class="string">&quot;Patterns!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行添加和删除操作</span></span><br><span class="line">        addCommand1.execute();</span><br><span class="line">        addCommand2.execute();</span><br><span class="line">        deleteCommand.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前文本</span></span><br><span class="line">        textEditor.displayText(); <span class="comment">// 输出: Hello, Design!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销删除操作</span></span><br><span class="line">        deleteCommand.undo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前文本</span></span><br><span class="line">        textEditor.displayText(); <span class="comment">// 输出: Hello, Design Patterns!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们实现了撤销和重做操作，可以在执行操作后撤销到之前的状态，然后再重做。这在需要保留操作历史的应用程序中非常有用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令模式是一种行为型设计模式，它将请求和操作解耦，允许将操作封装成独立的命令对象。这使得我们能够实现撤销、重做、宏命令等高级功能，并且更容易扩展新的命令。在设计软件系统时，考虑使用命令模式来提高代码的可维护性和灵活性，特别是需要支持撤销和重做功能的应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU缓存</title>
      <link href="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/"/>
      <url>/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存是什么"><a href="#缓存是什么" class="headerlink" title="缓存是什么"></a>缓存是什么</h1><p>其实缓存的思想在生活中处处可见，比如说我们的书架上摆满了各种书籍，但是我最近想集中精力攻克数据结构这门课，因次为了方便，我将与数据结构有关的书先从书架取下来，放在我们的书桌上，这样我们取书的时候就快很多了，伸手可得，而不用跑到书架旁取书了，在这个例子里，书桌所扮演的就是缓存的角色。</p><span id="more"></span><p>在计算机中，我们知道，访问磁盘的效率比访问内存的效率低得多，低多少了，大概是10W级别吧，如下图所示。</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/1.png" alt="图片"></p><p>我们知道有个很著名的二八定律。其实计算机世界中也有很多情况遵守这个定律，比如说网站访问的特点：80% 的业务访问集中在20% 的数据上。那么很自然就想到：既然大部分业务访问集中在一小部分数据上，那么如果通过设计合理的数据结构把这一小部分数据存放在内存中，是不是极大的提高了系统的性能呢，这就是缓存。</p><p>从上面可以看出，无论是生活中还是计算机世界中的缓存，主要有以下两个特点：</p><ul><li>提高系统效率，</li><li>容量小于外部存储容量，如书桌容量小于书架容量，内存容量小于硬盘容量</li></ul><h2 id="什么是LRU缓存"><a href="#什么是LRU缓存" class="headerlink" title="什么是LRU缓存"></a>什么是LRU缓存</h2><p>由于内存是有限的，因此缓存总有满的时候，那么当缓存满了的时候，这时候又有新的数据需要加入到缓存中时，我们该怎么办了？没什么别的办法，只有从缓存中删除旧数据为新数据腾出空间，那么究竟删除原来缓存的哪些数据了？这就涉及到缓存的替换策略，LRU就是一种缓存策略。</p><p>LRU，Least Recently Used的简写，翻译过来就是“最近最少使用”。该算法依据于程序的局部性原理， 其淘汰旧数据的策略是，<strong>距离当前最久没有被访问过的数据</strong>应该被淘汰。</p><p>举个例子：现在有一个能存放5个数据的缓存，刚开始中缓存中存放了3个数据A-&gt;B-&gt;C，如下所示：</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/2.png" alt="图片"></p><p>接着又在缓存中插入2个数据D-&gt;E，此时缓存已经满了。如下：</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/3.png" alt="图片"></p><p>好了，现在我们来访问数据A，现在A成为了最近访问的数据，B成了最久没有访问过的数据:</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/4.png" alt="图片"></p><p>现在我们又有一个数据F想要插入到缓存中，由于缓存已经满了，需要从缓存中淘汰旧数据，此时缓存中的数据B是距离当前时间最久没有被访问过的数据，根据LRU算法，我们会淘汰掉数据B：将F插入到当前B的位置。</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/5.jpg" alt="图片"></p><p>此时数据C成为了距离当前时间最久没有被访问过的数据，因此如果再来一个数据的话，就应该插入到C当前的位置，依次类推。</p><h2 id="LRU缓存设计"><a href="#LRU缓存设计" class="headerlink" title="LRU缓存设计"></a>LRU缓存设计</h2><p>理解LRU缓存的思想其实挺简单，但是要自己动手设计一个LRU缓存就并不那么简单了，这节主要讲讲LRU缓存的设计思路。</p><p>首先从前面的分析可以看出，LRU缓存主要的操作是插入删除以及查找，因此我们可以考虑用双链表来维护缓存，该链表将缓存数据按访问时间从新到旧排列起来。</p><p>如果我们只是单将缓存中的数据维护在一个双向链表中， 那么当我们需要从缓存中查找数据时，需要遍历链表，其时间复杂度为O(n)。 这样的设计， 是一种比较低效率的做法。 因此， 我们除了将数据维护在双向链表中， 我们同时还将数据维护在一个哈希表中。 哈希表访问数据的时间复杂度为O(1)。</p><p>依据上述设计， 一个LRU缓存包含了一个双向链表和一个哈希表， 双向链表以及哈希表的一个节点代表缓存中的一个缓存单元， 因此我们可以这样定义我们缓存单元的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LRU缓存的缓存单元 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cacheEntryS</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> key;   <span class="comment">//数据的key </span></span><br><span class="line">    <span class="type">char</span> data;  <span class="comment">// 数据的data</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cacheEntryS</span> *hashListPrev; <span class="comment">//指向哈希链表的前一个元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cacheEntryS</span> *hashListNext; <span class="comment">//指向哈希链表的后一个元素</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cacheEntryS</span> *lruListPrev;  <span class="comment">//指向链表的前一个元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cacheEntryS</span> *lruListNext;  <span class="comment">//指向链表后一个元素</span></span><br><span class="line">&#125;cacheEntryS; </span><br></pre></td></tr></table></figure><p>LRU缓存的数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义LRU缓存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LRUCacheS</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> cacheCapacity;  <span class="comment">//缓存的容量</span></span><br><span class="line">    cacheEntryS **hashMap;  <span class="comment">//缓存的哈希表</span></span><br><span class="line">      </span><br><span class="line">    cacheEntryS *lruListHead;<span class="comment">//缓存的双向链表表头</span></span><br><span class="line">    cacheEntryS *lruListTail;<span class="comment">//缓存的双向链表表尾</span></span><br><span class="line">    <span class="type">int</span> lruListSize;    <span class="comment">//缓存的双向链表节点个数</span></span><br><span class="line">&#125;LRUCacheS;</span><br></pre></td></tr></table></figure><p>如果一大坨代码看的比较晕，那么对着下面的结构关系图应该能理解的比较透彻，注意下图中没有指向的指针都是NULL：</p><p><img src="/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98/6.jpg" alt="图片"></p><h2 id="LRU缓存接口设计"><a href="#LRU缓存接口设计" class="headerlink" title="LRU缓存接口设计"></a>LRU缓存接口设计</h2><p>通过前面的分析不难看出，对一个LRU缓存的最重要的操作无外乎是创建、销毁、插入数据、查找数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">函数名：LRUCacheCreate</span></span><br><span class="line"><span class="comment">功能:创建LRU缓存</span></span><br><span class="line"><span class="comment">输入参数：capacity，缓存的数据容量</span></span><br><span class="line"><span class="comment">输出参数：lruCache，指向新建缓存的指针</span></span><br><span class="line"><span class="comment">针返回值：0---成功     -1---失败</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRUCacheCreate</span><span class="params">(<span class="type">int</span> capacity, <span class="type">void</span> **lruCache)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">函数名：LRUCacheDestory</span></span><br><span class="line"><span class="comment">功能:销毁LRU缓存</span></span><br><span class="line"><span class="comment">输入参数：lruCache指向新建缓存的指针</span></span><br><span class="line"><span class="comment">输出参数：无</span></span><br><span class="line"><span class="comment">针返回值：0---成功     -1---失败</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRUCacheDestory</span><span class="params">(<span class="type">void</span> *lruCache)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">函数名：LRUCacheSet</span></span><br><span class="line"><span class="comment">功能:将数据插入到LRU缓存中</span></span><br><span class="line"><span class="comment">输入参数：key:数据索引   data:数据内容</span></span><br><span class="line"><span class="comment">输出参数：无</span></span><br><span class="line"><span class="comment">针返回值：0---成功     -1---失败</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRUCacheSet</span><span class="params">(<span class="type">void</span> *lruCache, <span class="type">char</span> key, <span class="type">char</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">函数名：LRUCacheGet</span></span><br><span class="line"><span class="comment">功能:将从LRU缓存中获取数据</span></span><br><span class="line"><span class="comment">输入参数：key:数据索引</span></span><br><span class="line"><span class="comment">输出参数：无</span></span><br><span class="line"><span class="comment">针返回值：缓存中存在key对应的data,返回</span></span><br><span class="line"><span class="comment">        缓存中不存在key对应的data，返回&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRUCacheGet</span><span class="params">(<span class="type">void</span> *lruCache, <span class="type">char</span> key)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>链表</strong>（Linked list）是一种线性表，但是并不会在物理存储上按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表的插入和删除操作可以达到O(1)的复杂度。本文将讲解单向链表和双向链表，其中双向链表会给出部分关键代码实现。</p><span id="more"></span><h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针，下图就是一个单链表，表头为空，表头的后继节点是”结点10”(数据为10的结点)，”节点10”的后继结点是”节点20”(数据为20的结点)，…</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.png" alt="图片"></p><h2 id="单链表删除节点"><a href="#单链表删除节点" class="headerlink" title="单链表删除节点"></a>单链表删除节点</h2><p>我们看看单链表删除节点的操作，比如说下面这个单链表中我们要删除”节点30”。</p><p><strong>删除之前</strong>：”节点20” 的后继节点为”节点30”，而”节点30” 的后继节点为”节点40”。</p><p><strong>删除之后</strong>：”节点20” 的后继节点为”节点40”。</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2.jpg" alt="图片"></p><h2 id="单链表添加节点"><a href="#单链表添加节点" class="headerlink" title="单链表添加节点"></a>单链表添加节点</h2><p>我们再来看看单链表添加节点的操作，比如说下面这个单链表中我们在”节点10”与”节点20”之间添加”节点15”</p><p><strong>添加之前</strong>：”节点10” 的后继节点为”节点20”。</p><p><strong>添加之后</strong>：”节点10” 的后继节点为”节点15”，而”节点15” 的后继节点为”节点20”。</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/3.jpg" alt="图片"></p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><p>双链表的示意图如下：</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/4.png" alt="图片"></p><p>表头为空，表头的后继节点为”节点10”(数据为10的节点)；”节点10”的后继节点是”节点20”(数据为20的节点)，”节点20”的前继节点是”节点10”；”节点20”的后继节点是”节点30”，”节点30”的前继节点是”节点20”；…；末尾节点的后继节点是表头。</p><p>不难看出，双向链表的节点定义可以用一个下面的结构体表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dlink_node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dlink_node</span> *prev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dlink_node</span> *next;</span><br><span class="line">    <span class="type">void</span> *val;  <span class="comment">//能存储任意类型数据</span></span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure><h2 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h2><p>我们看看双向链表删除节点的操作，比如说下面这个单链表中我们要删除”节点30”。</p><p><strong>删除之前</strong>：”节点20”的后继节点为”节点30”，”节点30” 的前继节点为”节点20”。”节点30”的后继节点为”节点40”，”节点40” 的前继节点为”节点30”。</p><p><strong>删除之后</strong>：”节点20”的后继节点为”节点40”，”节点40” 的前继节点为”节点20”。</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/5.jpg" alt="图片"></p><p>双向链表删除节点的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除节点pindex</span><br><span class="line">pindex-&gt;next-&gt;prev = pindex-&gt;prev;</span><br><span class="line">pindex-&gt;prev-&gt;next = pindex-&gt;next;</span><br><span class="line">free(pindex); //注意释放节点</span><br></pre></td></tr></table></figure><h2 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h2><p>我们再来看看双向链表添加节点的操作，比如说下面这个双向链表在”节点10”与”节点20”之间添加”节点15”</p><p><strong>添加之前</strong>：”节点10”的后继节点为”节点20”，”节点20” 的前继节点为”节点10”。</p><p><strong>添加之后</strong>：”节点10”的后继节点为”节点15”，”节点15” 的前继节点为”节点10”。”节点15”的后继节点为”节点20”，”节点20” 的前继节点为”节点15”。</p><p><img src="/2023/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/6.jpg" alt="图片"></p><p>双向链表添加节点的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将pnode节点插入到pindex之前</span></span><br><span class="line">pnode-&gt;prev = pindex-&gt;prev;</span><br><span class="line">pnode-&gt;next = pindex;</span><br><span class="line">pindex-&gt;prev-&gt;next = pnode;</span><br><span class="line">pindex-&gt;prev = pnode;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现过滤器、拦截器与AOP</title>
      <link href="/2023/10/28/SpringBoot/SpringBoot%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8EAOP/"/>
      <url>/2023/10/28/SpringBoot/SpringBoot%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8EAOP/</url>
      
        <content type="html"><![CDATA[<p>使用过滤器、拦截器与切片实现每个请求耗时的统计，并比较三者的区别与联系</p><span id="more"></span><h2 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h2><h3 id="过滤器概念"><a href="#过滤器概念" class="headerlink" title="过滤器概念"></a>过滤器概念</h3><p>Filter是J2E中来的，可以看做是Servlet的一种“加强版”，它主要用于对用户请求进行预处理和后处理，拥有一个典型的处理链。Filter也可以对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。</p><p>使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p><h3 id="过滤器作用"><a href="#过滤器作用" class="headerlink" title="过滤器作用"></a>过滤器作用</h3><ul><li><p>Examples that have been identified for this design are</p><ol><li><p>Authentication Filters, 即用户访问权限过滤</p></li><li><p>Logging and Auditing Filters, 日志过滤，可以记录特殊用户的特殊请求的记录等</p></li><li><p>Image conversion Filters</p></li><li><p>Data compression Filters</p></li><li><p>Encryption Filters</p></li><li><p>Tokenizing Filters</p></li><li><p>Filters that trigger resource access events</p></li><li><p>XSL&#x2F;T filters</p></li><li><p>Mime-type chain Filter</p></li></ol></li></ul><p>对于第一条，即使用Filter作权限过滤，其可以这么实现：定义一个Filter，获取每个客户端发起的请求URL，与当前用户无权限访问的URL列表（可以是从DB中取出）作对比，起到权限过滤的作用。</p><h3 id="过滤器实现方式"><a href="#过滤器实现方式" class="headerlink" title="过滤器实现方式"></a>过滤器实现方式</h3><p>自定义的过滤器都必须实现javax.Servlet.Filter接口，并重写接口中定义的三个方法：</p><p><strong>1.void init(FilterConfig config)</strong></p><p>用于完成Filter的初始化。</p><p><strong>2.void destory()</strong></p><p>用于Filter销毁前，完成某些资源的回收。</p><p><strong>3.void doFilter(ServletRequest request,ServletResponse response,FilterChain chain)</strong></p><p>实现过滤功能，即对每个请求及响应增加的额外的预处理和后处理。,执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。</p><p>值得注意的是，chain.doFilter()方法执行之前为预处理阶段，该方法执行结束即代表用户的请求已经得到控制器处理。因此，如果在doFilter中忘记调用chain.doFilter()方法，则用户的请求将得不到处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须添加注解，springmvc通过web.xml配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(TimeFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;初始化过滤器：&#123;&#125;&quot;</span>, filterConfig.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;start to doFilter&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        LOG.info(<span class="string">&quot;the request of &#123;&#125; consumes &#123;&#125;ms.&quot;</span>, getUrlFrom(request), (endTime - startTime));</span><br><span class="line">        LOG.info(<span class="string">&quot;end to doFilter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;销毁过滤器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUrlFrom</span><span class="params">(ServletRequest servletRequest)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (servletRequest <span class="keyword">instanceof</span> HttpServletRequest)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((HttpServletRequest) servletRequest).getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可看出，类Filter是在javax.servlet.*中，因此可以看出，过滤器的一个很大的局限性在于，其不能够知道当前用户的请求是被哪个控制器(Controller)处理的，因为后者是spring框架中定义的。</p><h3 id="在SpringBoot中注册第三方过滤器"><a href="#在SpringBoot中注册第三方过滤器" class="headerlink" title="在SpringBoot中注册第三方过滤器"></a>在SpringBoot中注册第三方过滤器</h3><p>对于SpringMvc，可以通过在web.xml中注册过滤器。但在SpringBoot中不存在web.xml，此时如果引用的某个jar包中的过滤器，且这个过滤器在实现时没有使用@Component标识为Spring Bean，则这个过滤器将不会生效。</p><p>此时需要通过java代码去注册这个过滤器。以上面定义的TimeFilter为例，当去掉类注解@Component时，注册方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册第三方过滤器</span></span><br><span class="line"><span class="comment">     * 功能与spring mvc中通过配置web.xml相同</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">thirdFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThirdPartFilter</span> <span class="variable">thirdPartFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPartFilter</span>();</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>() ;</span><br><span class="line"></span><br><span class="line">        filterRegistrationBean.setFilter(thirdPartFilter);</span><br><span class="line">        List&lt;String &gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 匹配所有请求路径</span></span><br><span class="line">        urls.add(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setUrlPatterns(urls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比使用@Component注解，这种配置方式有个优点，即可以自由配置拦截的URL。</p><h2 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h2><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><p>拦截器，在AOP(Aspect-Oriented Programming)中用于在某个方法或字段被访问之前，进行拦截，然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p><h3 id="拦截器作用"><a href="#拦截器作用" class="headerlink" title="拦截器作用"></a>拦截器作用</h3><ul><li><strong>日志记录：</strong>记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等</li><li><strong>权限检查：</strong>如登录检测，进入处理器检测检测是否登录</li><li><strong>性能监控：</strong>通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间。（反向代理，如apache也可以自动记录）；</li><li><strong>通用行为：</strong>读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</li></ul><h3 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h3><p>通过实现HandlerInterceptor接口，并重写该接口的三个方法来实现拦截器的自定义:</p><p><strong>1.preHandler(HttpServletRequest request, HttpServletResponse response, Object handler)</strong></p><p>方法将在请求处理之前进行调用。SpringMVC中的Interceptor同Filter一样都是链式调用。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。</p><p>该方法的返回值是布尔值Boolean 类型的，当它返回为false时，表示请求结束，后续的Interceptor和Controller都不会再执行；当返回值为true时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</p><p><strong>2.postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</strong></p><p>在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。</p><p><strong>3.afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</strong></p><p>该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(TimeInterceptor.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;在请求处理之前进行调用（Controller方法调用之前）&quot;</span>);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;startTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        LOG.info(<span class="string">&quot;controller object is &#123;&#125;&quot;</span>, handlerMethod.getBean().getClass().getName());</span><br><span class="line">        LOG.info(<span class="string">&quot;controller method is &#123;&#125;&quot;</span>, handlerMethod.getMethod());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要返回true，否则请求不会被控制器处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后），如果异常发生，则该方法不会被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> (<span class="type">long</span>) request.getAttribute(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">        LOG.info(<span class="string">&quot;time consume is &#123;&#125;&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与过滤器不同的是，拦截器使用@Component修饰后，在SpringBoot中还需要通过实现WebMvcConfigurer手动注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TimeInterceptor timeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">        registry.addInterceptor(timeInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在SpringMVC中，则需要通过xml文件配置&lt; mvc:interceptors &gt;节点信息。</p><h2 id="切片Aspect"><a href="#切片Aspect" class="headerlink" title="切片Aspect"></a>切片Aspect</h2><h3 id="切片概述"><a href="#切片概述" class="headerlink" title="切片概述"></a>切片概述</h3><p>相比过滤器，拦截器能够知道用户发出的请求最终被哪个控制器处理，但是拦截器还有一个明显的不足，即不能够获取request的参数以及控制器处理之后的response。所以就有了切片的用武之地了。</p><h3 id="切片实现"><a href="#切片实现" class="headerlink" title="切片实现"></a>切片实现</h3><p>切片的实现需要注意@Aspect,@Component以及@Around这三个注解的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(TimeAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* me.ifight.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">handleControllerMethod</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;切片开始。。。&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求入参</span></span><br><span class="line">        Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">        Arrays.stream(args).forEach(arg -&gt; LOG.info(<span class="string">&quot;arg is &#123;&#125;&quot;</span>, arg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取相应</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        LOG.info(<span class="string">&quot;请求:&#123;&#125;, 耗时&#123;&#125;ms&quot;</span>, proceedingJoinPoint.getSignature(), (endTime - startTime));</span><br><span class="line">        LOG.info(<span class="string">&quot;切片结束。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器、拦截器以及切片的调用顺序"><a href="#过滤器、拦截器以及切片的调用顺序" class="headerlink" title="过滤器、拦截器以及切片的调用顺序"></a>过滤器、拦截器以及切片的调用顺序</h2><p>如下图，展示了三者的调用顺序Filter-&gt;Intercepto-&gt;Aspect-&gt;Controller。相反的是，当Controller抛出的异常的处理顺序则是从内到外的。因此我们总是定义一个注解@ControllerAdvice去统一处理控制器抛出的异常。</p><p>如果一旦异常被@ControllerAdvice处理了，则调用拦截器的afterCompletion方法的参数Exception ex就为空了。</p><p><img src="/2023/10/28/SpringBoot/SpringBoot%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8EAOP/1.jpg" alt="图片"></p><p>实际执行的调用栈也说明了这一点：</p><p><img src="/2023/10/28/SpringBoot/SpringBoot%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8EAOP/2.jpg" alt="图片"></p><p>而对于过滤器和拦截器详细的调用顺序如下图：</p><p><img src="/2023/10/28/SpringBoot/SpringBoot%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8EAOP/3.jpg" alt="图片"></p><h2 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h2><p>最后有必要再说说过滤器和拦截器二者之间的区别：</p><table><thead><tr><th></th><th>Filter</th><th>Interceptor</th></tr></thead><tbody><tr><td>实现方式</td><td>基于函数回调</td><td>基于Java的反射机制</td></tr><tr><td>规范</td><td>Servlet规范</td><td>Spring规范</td></tr><tr><td>作用范围</td><td>几乎所有web请求</td><td>对action请求</td></tr></tbody></table><p>除此之外，相比过滤器，拦截器能够“看到”用户的请求具体是被Spring框架的哪个控制器所处理。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 过滤器 </tag>
            
            <tag> 拦截器 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁原理、锁优化、CAS、AQS</title>
      <link href="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81-%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/"/>
      <url>/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81-%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用锁？"><a href="#为什么要用锁？" class="headerlink" title="为什么要用锁？"></a>为什么要用锁？</h1><p>锁-是为了解决并发操作引起的脏读、数据不一致的问题。</p><span id="more"></span><h1 id="锁实现基本原理"><a href="#锁实现基本原理" class="headerlink" title="锁实现基本原理"></a>锁实现基本原理</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><p><img src="/./1.jpg" alt="图片"></p><p>结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><p>synchronized通过锁机制实现同步。</p><p>利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</p><p>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><p>synchronized是基于Monitor来实现同步的。</p><p>Monitor从两个方面来支持线程之间的同步：</p><ul><li>互斥执行</li><li>协作</li></ul><p>1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。</p><p>2、使用 notify&#x2F;notifyAll&#x2F;wait 方法来协同不同线程之间的工作。</p><p>3、Class和Object都关联了一个Monitor。</p><p><img src="/./2.png" alt="图片"></p><p>Monitor 的工作机理</p><ul><li>线程进入同步方法中。</li><li>为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）</li><li>拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。</li><li>其他线程调用 notify() &#x2F; notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要<strong>重新获取监视锁后</strong>才能执行 wait() 之后的代码。</li><li>同步方法执行完毕了，线程退出临界区，并释放监视锁。</li></ul><h3 id="synchronized具体实现"><a href="#synchronized具体实现" class="headerlink" title="synchronized具体实现"></a>synchronized具体实现</h3><p>1、同步代码块采用monitorenter、monitorexit指令显式的实现。</p><p>2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。</p><p>通过实例来看看具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public synchronized void method1()&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void method2()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap编译后的字节码如下：</p><p><img src="/./3.jpg" alt="图片"></p><p><strong>monitorenter</strong></p><p>每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：</p><ul><li>如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。</li><li>如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。</li><li>如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。</li></ul><p><strong>monitorexit</strong></p><p>只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。</p><h3 id="锁存放的位置"><a href="#锁存放的位置" class="headerlink" title="锁存放的位置"></a>锁存放的位置</h3><p>锁标记存放在Java对象头的Mark Word中。</p><p><img src="/./4.png" alt="图片"></p><p>Java对象头长度</p><p><img src="/./5.png" alt="图片"></p><p>32位JVM Mark Word 结构</p><p><img src="/./6.png" alt="图片"></p><p>32位JVM Mark Word 状态变化</p><p><img src="/./7.png" alt="图片"></p><p>64位JVM Mark Word 结构</p><h3 id="synchronized的锁优化"><a href="#synchronized的锁优化" class="headerlink" title="synchronized的锁优化"></a>synchronized的锁优化</h3><p>JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。</p><p><img src="/./8.jpg" alt="图片"></p><p><strong>锁粗化（Lock Coarsening）：</strong>也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p><strong>锁消除（Lock Elimination）：</strong>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</p><p><strong>适应性自旋（Adaptive Spinning）：</strong>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><p><img src="/./9.png" alt="图片"></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h2><p>CAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。</p><p>1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。</p><p>2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。</p><p>优点：</p><ul><li>竞争不大的时候系统开销小。</li></ul><p>缺点：</p><ul><li>循环时间长开销大。</li><li>ABA问题。</li><li>只能保证一个共享变量的原子操作。</li></ul><h1 id="Java中的锁实现"><a href="#Java中的锁实现" class="headerlink" title="Java中的锁实现"></a>Java中的锁实现</h1><h2 id="队列同步器（AQS）"><a href="#队列同步器（AQS）" class="headerlink" title="队列同步器（AQS）"></a><strong>队列同步器（AQS）</strong></h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。</p><h3 id="它使用了一个int成员变量表示同步状态。"><a href="#它使用了一个int成员变量表示同步状态。" class="headerlink" title="它使用了一个int成员变量表示同步状态。"></a>它使用了一个int成员变量表示同步状态。</h3><p><img src="/./10.png" alt="图片"></p><h3 id="通过内置的FIFO双向队列来完成获取锁线程的排队工作。"><a href="#通过内置的FIFO双向队列来完成获取锁线程的排队工作。" class="headerlink" title="通过内置的FIFO双向队列来完成获取锁线程的排队工作。"></a>通过内置的FIFO双向队列来完成获取锁线程的排队工作。</h3><p>同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。</p><p><img src="/./11.png" alt="图片"></p><p>未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示：</p><p><img src="/./12.png" alt="图片"></p><p>首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示：</p><p><img src="/./13.png" alt="图片"></p><h3 id="独占式-共享式锁获取"><a href="#独占式-共享式锁获取" class="headerlink" title="独占式&#x2F;共享式锁获取"></a>独占式&#x2F;共享式锁获取</h3><p>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</p><p>共享式：可以多个线程同时获取到锁，如：CountDownLatch</p><h4 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h4><ul><li><p>每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。</p><p><img src="/./14.png" alt="图片"></p></li><li><p>独占式锁获取流程：</p><p><img src="/./15.jpg" alt="图片"></p></li></ul><h4 id="共享式："><a href="#共享式：" class="headerlink" title="共享式："></a>共享式：</h4><ul><li><p>共享式与独占式的区别：</p><p><img src="/./16.jpg" alt="图片"></p></li><li><p>共享锁获取流程：</p><p><img src="/./17.jpg" alt="图片"></p></li></ul><h1 id="锁的使用用例"><a href="#锁的使用用例" class="headerlink" title="锁的使用用例"></a>锁的使用用例</h1><h2 id="ConcurrentHashMap的实现原理及使用"><a href="#ConcurrentHashMap的实现原理及使用" class="headerlink" title="ConcurrentHashMap的实现原理及使用"></a><strong>ConcurrentHashMap的实现原理及使用</strong></h2><p><img src="/./18.jpg" alt="图片"></p><p>ConcurrentHashMap类图</p><p><img src="/./19.png" alt="图片"></p><p>结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p><a href="https://mp.weixin.qq.com/s/hvku5GPxkfQ5GffLjiUAYw">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> CAS </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁原理、锁优化、CAS、AQS</title>
      <link href="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/"/>
      <url>/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用锁？"><a href="#为什么要用锁？" class="headerlink" title="为什么要用锁？"></a>为什么要用锁？</h1><p>锁-是为了解决并发操作引起的脏读、数据不一致的问题。</p><span id="more"></span><h1 id="锁实现基本原理"><a href="#锁实现基本原理" class="headerlink" title="锁实现基本原理"></a>锁实现基本原理</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><p><img src="/../1.jpg" alt="图片"></p><p>结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><p>synchronized通过锁机制实现同步。</p><p>利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</p><p>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><p>synchronized是基于Monitor来实现同步的。</p><p>Monitor从两个方面来支持线程之间的同步：</p><ul><li>互斥执行</li><li>协作</li></ul><p>1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。</p><p>2、使用 notify&#x2F;notifyAll&#x2F;wait 方法来协同不同线程之间的工作。</p><p>3、Class和Object都关联了一个Monitor。</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/2.png" alt="图片"></p><p>Monitor 的工作机理</p><ul><li>线程进入同步方法中。</li><li>为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）</li><li>拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。</li><li>其他线程调用 notify() &#x2F; notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要<strong>重新获取监视锁后</strong>才能执行 wait() 之后的代码。</li><li>同步方法执行完毕了，线程退出临界区，并释放监视锁。</li></ul><h3 id="synchronized具体实现"><a href="#synchronized具体实现" class="headerlink" title="synchronized具体实现"></a>synchronized具体实现</h3><p>1、同步代码块采用monitorenter、monitorexit指令显式的实现。</p><p>2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。</p><p>通过实例来看看具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public synchronized void method1()&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void method2()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap编译后的字节码如下：</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/3.jpg" alt="图片"></p><p><strong>monitorenter</strong></p><p>每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：</p><ul><li>如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。</li><li>如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。</li><li>如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。</li></ul><p><strong>monitorexit</strong></p><p>只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。</p><h3 id="锁存放的位置"><a href="#锁存放的位置" class="headerlink" title="锁存放的位置"></a>锁存放的位置</h3><p>锁标记存放在Java对象头的Mark Word中。</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/4.png" alt="图片"></p><p>Java对象头长度</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/5.png" alt="图片"></p><p>32位JVM Mark Word 结构</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/6.png" alt="图片"></p><p>32位JVM Mark Word 状态变化</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/7.png" alt="图片"></p><p>64位JVM Mark Word 结构</p><h3 id="synchronized的锁优化"><a href="#synchronized的锁优化" class="headerlink" title="synchronized的锁优化"></a>synchronized的锁优化</h3><p>JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/8.jpg" alt="图片"></p><p><strong>锁粗化（Lock Coarsening）：</strong>也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p><strong>锁消除（Lock Elimination）：</strong>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</p><p><strong>适应性自旋（Adaptive Spinning）：</strong>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/9.png" alt="图片"></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h2><p>CAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。</p><p>1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。</p><p>2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。</p><p>优点：</p><ul><li>竞争不大的时候系统开销小。</li></ul><p>缺点：</p><ul><li>循环时间长开销大。</li><li>ABA问题。</li><li>只能保证一个共享变量的原子操作。</li></ul><h1 id="Java中的锁实现"><a href="#Java中的锁实现" class="headerlink" title="Java中的锁实现"></a>Java中的锁实现</h1><h2 id="队列同步器（AQS）"><a href="#队列同步器（AQS）" class="headerlink" title="队列同步器（AQS）"></a><strong>队列同步器（AQS）</strong></h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。</p><h3 id="它使用了一个int成员变量表示同步状态。"><a href="#它使用了一个int成员变量表示同步状态。" class="headerlink" title="它使用了一个int成员变量表示同步状态。"></a>它使用了一个int成员变量表示同步状态。</h3><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/10.png" alt="图片"></p><h3 id="通过内置的FIFO双向队列来完成获取锁线程的排队工作。"><a href="#通过内置的FIFO双向队列来完成获取锁线程的排队工作。" class="headerlink" title="通过内置的FIFO双向队列来完成获取锁线程的排队工作。"></a>通过内置的FIFO双向队列来完成获取锁线程的排队工作。</h3><p>同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/11.png" alt="图片"></p><p>未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示：</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/12.png" alt="图片"></p><p>首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示：</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/13.png" alt="图片"></p><h3 id="独占式-共享式锁获取"><a href="#独占式-共享式锁获取" class="headerlink" title="独占式&#x2F;共享式锁获取"></a>独占式&#x2F;共享式锁获取</h3><p>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</p><p>共享式：可以多个线程同时获取到锁，如：CountDownLatch</p><h4 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h4><ul><li><p>每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/14.png" alt="图片"></p></li><li><p>独占式锁获取流程：</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/15.jpg" alt="图片"></p></li></ul><h4 id="共享式："><a href="#共享式：" class="headerlink" title="共享式："></a>共享式：</h4><ul><li><p>共享式与独占式的区别：</p><p><img src="/./16.jpg" alt="图片"></p></li><li><p>共享锁获取流程：</p><p><img src="/./17.jpg" alt="图片"></p></li></ul><h1 id="锁的使用用例"><a href="#锁的使用用例" class="headerlink" title="锁的使用用例"></a>锁的使用用例</h1><h2 id="ConcurrentHashMap的实现原理及使用"><a href="#ConcurrentHashMap的实现原理及使用" class="headerlink" title="ConcurrentHashMap的实现原理及使用"></a><strong>ConcurrentHashMap的实现原理及使用</strong></h2><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/18.jpg" alt="图片"></p><p>ConcurrentHashMap类图</p><p><img src="/2023/10/28/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS/19.png" alt="图片"></p><p>结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p><a href="https://mp.weixin.qq.com/s/hvku5GPxkfQ5GffLjiUAYw">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> CAS </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文了解单例设计模式</title>
      <link href="/2023/10/27/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/27/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式无论在我们面试，还是日常工作中，都会面对的问题。但很多单例模式的细节，值得我们深入探索一下。</p><p><img src="/2023/10/27/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png" alt="图片"></p><span id="more"></span><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p><code>单例模式</code>是一种非常常用的软件设计模式，它定义是单例对象的类<code>只能允许一个实例存在</code>。</p><p>该类负责创建自己的对象，同时确保只有一个对象被创建。一般常用在工具类的实现或创建对象需要消耗资源的业务场景。</p><p>单例模式的特点：</p><ul><li>类构造器私有</li><li>持有自己类的引用</li><li>对外提供获取实例的静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//持有自己类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SimpleSingleton.getInstance().hashCode());</span><br><span class="line">        System.out.println(SimpleSingleton.getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1639705018</span><br><span class="line">1639705018</span><br></pre></td></tr></table></figure><p>我们看到两次获取SimpleSingleton实例的hashCode是一样的，说明两次调用获取到的是同一个对象。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//持有自己类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//持有自己类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleSingleton INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">       INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态代码块的方式实例化INSTANCE对象。使用饿汉模式的好处是：<code>没有线程安全的问题</code>，但带来的坏处也很明显。一开始就实例化对象了，如果实例化过程非常耗时，如果这个对象没有被使用，不是白白造成资源浪费吗？</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有多个线程中都调用了getInstance方法，那么都走到 if (INSTANCE &#x3D;&#x3D; null) 判断时，可能同时成立，因为INSTANCE初始化时默认值是null。这样会导致多个线程中同时创建INSTANCE对象，即INSTANCE对象被创建了多次，违背了只创建一个INSTANCE对象的初衷。</p><p>改进一：使用<code>synchronized</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SimpleSingleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SimpleSingleton3.getInstance().hashCode());</span><br><span class="line">        System.out.println(SimpleSingleton3.getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getInstance方法上加<code>synchronized</code>关键字，保证在并发的情况下，只有一个线程能创建INSTANCE对象的实例。缺点是使用synchronized关键字会消耗getInstance方法的性能，我们应该判断当INSTANCE为空时才加锁，如果不为空不应该加锁，需要直接返回。</p><p>改进二：双重检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton4 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SimpleSingleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加锁之前判断是否为空，可以确保INSTANCE不为空的情况下，不用加锁，可以直接返回。上段代码虽然解决重复加锁问题，但是由于jvm生成对象操作不是原子，存在指令重排问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">          <span class="keyword">synchronized</span> (SimpleSingleton4.class) &#123;<span class="comment">//2</span></span><br><span class="line">              <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;<span class="comment">//3</span></span><br><span class="line">                  INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton4</span>();<span class="comment">//4</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> INSTANCE;<span class="comment">//5</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getInstance方法的这段代码，我是按1、2、3、4、5这种顺序写的，希望也按这个顺序执行。</p><p>但是java虚拟机实际上会做一些优化，对一些代码指令进行重排。重排之后的顺序可能就变成了：1、3、2、4、5，这样在多线程的情况下同样会创建多次实例。重排之后的代码可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">       <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;<span class="comment">//3</span></span><br><span class="line">           <span class="keyword">synchronized</span> (SimpleSingleton4.class) &#123;<span class="comment">//2</span></span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton4</span>();<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进三：加上<code>volatile</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SimpleSingleton7 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton7</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton7 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SimpleSingleton7.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton7</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code>关键字可以保证多个线程的可见性，但是不能保证原子性。同时它也能禁止指令重排。</p><p>双重检查锁的机制既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。</p><h3 id="静态内部锁"><a href="#静态内部锁" class="headerlink" title="静态内部锁"></a>静态内部锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SimpleSingleton5类中定义了一个静态的内部类Inner。在SimpleSingleton5类的getInstance方法中，返回的是内部类Inner的实例INSTANCE对象。只有在程序第一次调用getInstance方法时，虚拟机才加载Inner并实例化INSTANCE对象。java内部机制保证了，只有一个线程可以获得对象锁，其他的线程必须等待，保证对象的唯一性。</p><h3 id="反射漏洞"><a href="#反射漏洞" class="headerlink" title="反射漏洞"></a>反射漏洞</h3><p>上面的代码看似完美，但还是有漏洞。如果其他人使用<code>反射</code>，依然能够通过类的无参构造方式创建对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;SimpleSingleton5&gt; simpleSingleton5Class = SimpleSingleton5.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">SimpleSingleton5</span> <span class="variable">newInstance</span> <span class="operator">=</span> simpleSingleton5Class.newInstance();</span><br><span class="line">    System.out.println(newInstance == SimpleSingleton5.getInstance());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打印结果是false。由此看出，通过反射创建的对象，跟通过getInstance方法获取的对象，并非同一个对象，也就是说，这个漏洞会导致SimpleSingleton5非单例。</p><p>解决一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Inner.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能支持重复实例化&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton5</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方法无法阻止通过序列化生成对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Inner.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能支持重复实例化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleSingleton5</span> <span class="variable">simpleSingleton5</span> <span class="operator">=</span> SimpleSingleton5.getInstance();</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(simpleSingleton5);</span><br><span class="line">            System.out.println(simpleSingleton5.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="type">SimpleSingleton5</span> <span class="variable">myObject</span> <span class="operator">=</span> (SimpleSingleton5) ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(myObject.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        writeFile();</span><br><span class="line">        readFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现序列化和反序列化后对象的hashCode不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">189568618</span><br><span class="line">793589513</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>增加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">    <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：程序在反序列化获取对象时，会去寻找readResolve()方法。</p><ul><li>如果该方法不存在，则直接返回新对象。</li><li>如果该方法存在，则按该方法的内容返回对象。</li><li>如果我们之前没有实例化单例对象，则会返回null。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在java中枚举就是天然的单例，每一个实例只有一个对象，这是java底层内部机制保证的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">SimpleSingleton7</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSamething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSamething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton7Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SimpleSingleton7.INSTANCE.doSamething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在枚举中实例对象INSTANCE是唯一的，所以它是天然的单例模式。jvm保证了枚举是天然的单例，并且不存在线程安全问题，此外，还支持序列化。</p><h3 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h3><p>多例模式顾名思义，它允许创建多个实例。但它的初衷是为了控制实例的个数，其他的跟单例模式差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMultiPattern &#123;</span><br><span class="line">    //持有自己类的引用</span><br><span class="line">    private static final SimpleMultiPattern INSTANCE1 = new SimpleMultiPattern();</span><br><span class="line">    private static final SimpleMultiPattern INSTANCE2 = new SimpleMultiPattern();</span><br><span class="line"></span><br><span class="line">    //私有的构造方法</span><br><span class="line">    private SimpleMultiPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //对外提供获取实例的静态方法</span><br><span class="line">    public static SimpleMultiPattern getInstance(int type) &#123;</span><br><span class="line">        if(type == 1) &#123;</span><br><span class="line">          return INSTANCE1;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似容器工厂。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>JDK的Runtime</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Runtime &#123;</span><br><span class="line">    private static Runtime currentRuntime = new Runtime();</span><br><span class="line">    </span><br><span class="line">    public static Runtime getRuntime() &#123;</span><br><span class="line">        return currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Runtime() &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamespaceHandlerResolver</p><p>spring提供的DefaultNamespaceHandlerResolver是为需要初始化默认命名空间处理器，是为了方便后面做标签解析用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getHandlerMappings</span><span class="params">()</span> &#123;</span><br><span class="line">  Map&lt;String, Object&gt; handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">  <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">    <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Loading NamespaceHandler mappings from [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span></span><br><span class="line">        PropertiesLoaderUtils.loadAllProperties(<span class="built_in">this</span>.handlerMappingsLocation, <span class="built_in">this</span>.classLoader);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">       logger.debug(<span class="string">&quot;Loaded NamespaceHandler mappings: &quot;</span> + mappings);</span><br><span class="line">      &#125;</span><br><span class="line">      handlerMappings = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(mappings.size());</span><br><span class="line">      CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">      <span class="built_in">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;Unable to load NamespaceHandler mappings from location [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handlerMappings;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>LogFactory</p><p>mybatis提供<code>LogFactory</code>类是为了创建日志对象，根据引入的jar包，决定使用哪种方式打印日志。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LogFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MARKER</span> <span class="operator">=</span> <span class="string">&quot;MYBATIS&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useSlf4jLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useCommonsLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useLog4J2Logging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useLog4JLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useJdkLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useNoLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">LogFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title function_">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title function_">getLog</span><span class="params">(String logger)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogException</span>(<span class="string">&quot;Error creating logger for logger &quot;</span> + logger + <span class="string">&quot;.  Cause: &quot;</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useCustomLogging</span><span class="params">(Class&lt;? extends Log&gt; clazz)</span> &#123;</span><br><span class="line">    setImplementation(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useSlf4jLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useCommonsLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useLog4JLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useLog4J2Logging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useJdkLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useStdOutLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">useNoLogging</span><span class="params">()</span> &#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tryImplementation</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logConstructor == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">      <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Logging initialized using &#x27;&quot;</span> + implClass + <span class="string">&quot;&#x27; adapter.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      logConstructor = candidate;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogException</span>(<span class="string">&quot;Error setting Log implementation.  Cause: &quot;</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常经典，但它却是一个不走寻常路的单例模式。因为它创建的实例对象，可能存在多种情况，根据引入不同的jar包，加载不同的类创建实例对象。如果有一个创建成功，则用它作为整个类的实例对象。</p><p>ErrorContext</p><p>mybatis提供<code>ErrorContext</code>类记录了错误信息的上下文，方便后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorContext</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;ErrorContext&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ErrorContext</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title function_">instance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ErrorContext</span> <span class="variable">context</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      context = <span class="keyword">new</span> <span class="title class_">ErrorContext</span>();</span><br><span class="line">      LOCAL.set(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>ErrorContext跟传统的单例模式不一样，它改良了一下。它使用了饿汉模式，并且使用<code>ThreadLocal</code>，保证每个线程中的实例对象是单例的。这样看来，ErrorContext类创建的对象不是唯一的，它其实也是多例模式的一种。</p><p><a href="https://mp.weixin.qq.com/s/-KnI7WvS9h02PUjlAGxTiA">阅读原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务常见实现方式</title>
      <link href="/2023/10/24/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/24/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>定时任务，指的是在编程过程中无须做复杂控制的前提下执行简单的定时操作。</p><p>在项目中，我们常常需要在特定的时间执行一些任务，比如定时删除服务器存储的数据缓存，定时获取数据以及定时发送推送等等。</p><span id="more"></span><h3 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h3><p>在java中一个完整的定时任务需要由Timer和TimerTask两个类配合完成。其中Timer是一种工具，线程用其安排在后台线程中执行的任务，可安排任务执行一次或者定期重复执行；而TimerTask是由Timer安排执行一次或者重复执行的任务。</p><p>Timer中提供了四个构造方法：</p><p>（1）schedule(TimerTask task, Date time)——安排在指定的时间执行指定的任务；</p><p>（2）schedule(TimerTask task, Date firstTime, long period)——安排指定的任务在指定的时间开始进行重复的固定延迟执行；</p><p>（3）schedule(TimerTask task, long delay)——安排在指定延迟后执行指定的任务；</p><p>（4）schedule(TimerTask task, long delay, long period)——安排指定的任务在指定的延迟后开始进行重复的固定速率执行。</p><p>指定延迟时间执行定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUseTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        timer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">timer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------------设定任务执行------------&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定时间执行定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUseTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        timer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">timer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">1</span>);</span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------------设定任务执行----------&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在延迟指定时间后以指定时间循环执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUseTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        timer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">timer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;--------------设定任务执行-------------&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer类是一种简单实用的实现定时任务的方法，然而它存在着自身的缺陷：</p><p>（1）Timer对调度的支持是基于绝对时间而不是相对时间，因此它对于系统时间的改变非常敏感；</p><p>（2）一个Timer是在同一个线程循环执行的，如果上一个任务执行时间过长，下一个也会延迟。</p><p>（2）Timer线程是不会捕获异常的，如果TimerTask抛出未检查的异常则会导致Timer线程终止，同时Timer也不会重新恢复线程的执行，它会错误的认为整个Timer线程都会取消，已经被安排但尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。因此，如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。</p><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>ScheduledExecutor的设计思想是每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发的，相互之间不会受到干扰；只有当任务的时间到来时，ScheduledExecutor才会真正启动一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScheduleExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestScheduleExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timerOne</span><span class="params">()</span> &#123;</span><br><span class="line">        scheduledExecutorService.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务1 开始执行&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timerTow</span><span class="params">()</span> &#123;</span><br><span class="line">        scheduledExecutorService.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务2 开始执行&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestScheduleExecutor</span> <span class="variable">testScheduleExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestScheduleExecutor</span>();</span><br><span class="line">        testScheduleExecutor.timerOne();</span><br><span class="line">        testScheduleExecutor.timerTow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到针对Timer类存在的两个缺陷，ScheduledExecutorService可以很好地解决，其思路主要在于每一个被调度的任务都是由线程池中的一个线程去执行，任务之间是并发的，不会互相干扰。</p><h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>Quartz是一个完全由Java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单强大的机制。与前两种方法相比，Quartz对于定时的配置更为丰富，实际应用的场景多。</p><p>Quartz最重要的3个基本要素：</p><p>（1）Scheduler——调度器，所有的调度都由它控制；</p><p>（2）Trigger——定义触发的条件，包括SimpleTrigger和CronTrigger等；</p><p>（3）JobDetail &amp; Job——JobDetail定义的是任务数据，而真正的执行逻辑在Job中。Scheduler的每次执行都会根据JobDetail创建一个新的Job实例。</p><p>使用SimpleTrigger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTriggerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建scheduler调度器</span></span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义一个Trigger</span></span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger&quot;</span>, <span class="string">&quot;group&quot;</span>)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                            .withIntervalInSeconds(<span class="number">1</span>) <span class="comment">// 每秒</span></span><br><span class="line">                            .repeatForever() <span class="comment">// 一直重复</span></span><br><span class="line">                    ).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义任务信息</span></span><br><span class="line">            <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class).withIdentity(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;group&quot;</span>)</span><br><span class="line">                    .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;testJOb&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调度任务</span></span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">            scheduler.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CronTrigger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CronTriggerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建scheduler调度器</span></span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义一个Trigger</span></span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger&quot;</span>, <span class="string">&quot;group&quot;</span>)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/1 * * * * ?&quot;</span>)).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义任务信息</span></span><br><span class="line">            <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class).withIdentity(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;group&quot;</span>)</span><br><span class="line">                    .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;testJOb&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调度任务</span></span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">            scheduler.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyJob.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">detail</span> <span class="operator">=</span> jobExecutionContext.getJobDetail();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> detail.getJobDataMap().getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MyJob is working &quot;</span> +name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于CronTrigger的配置</p><p>（1）使用CronTrigger最主要是要掌握Cron表达式，Cron表达式包含6个必要组件和一个可选组件</p><table><thead><tr><th>位置</th><th>含义</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>1</td><td>秒（0-59）</td><td>, - * &#x2F;</td></tr><tr><td>2</td><td>分（0-59）</td><td>, - * &#x2F;</td></tr><tr><td>3</td><td>小时（0-24）</td><td>, - * &#x2F;</td></tr><tr><td>4</td><td>日期（1-31）</td><td>, - * &#x2F; ? L W C</td></tr><tr><td>5</td><td>月（JAN-DEC或1-12）</td><td>, - * &#x2F;</td></tr><tr><td>6</td><td>星期（SUN-SAT或1-7）</td><td>, - * &#x2F; ? L C #</td></tr><tr><td>7</td><td>年（可选，1970-2099），若为空，表示全部时间范围</td><td>, - * &#x2F;</td></tr></tbody></table><p>（2）特殊字符的含义</p><table><thead><tr><th>特殊字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>通配符，任意值</td></tr><tr><td>?</td><td>无特定值，通常和其他指定的值一起使用，表示必须显示该值但不能检查</td></tr><tr><td>-</td><td>范围</td></tr><tr><td>,</td><td>列分隔符，可以指定一系列的值</td></tr><tr><td>&#x2F;</td><td>增量，表示一个值的增量</td></tr><tr><td>L</td><td>表示Last，在日期和星期域中表示有所不同。在日期域中，表示这个月的最后一天，而在星期域中，它永远是7（星期六）</td></tr><tr><td>W</td><td>在本月内离当天最近的工作日触发</td></tr><tr><td>#</td><td>表示该月的第几个星期</td></tr><tr><td>C</td><td>日历值</td></tr></tbody></table><p>（3）Cron表达式举例：</p><p>“30 * * * * ?”  每半分钟出发</p><p>“30 10 * * * ?”   每小时的10分30秒触发</p><p>“30 10 1 * * ?”  每天1点10分30秒触发</p><p>“30 10 1 20 * ?”  每月20号1点10分30秒触发</p><p>“30 10 1 20 10 ? *”  每年10月20号1点10分30秒触发</p><p>“30 10 1 20 10 ? 2018”  2018年10月20号1点10分30秒触发</p><p>“30 10 1 ? 10 * 2018”  2018年10月每天1点10分30秒触发任务</p><p>“30 10 1 ? 10 SUN 2018”  2018年10月每周日1点10分30秒触发</p><p>“15,30,45 * * * * ?”  第15秒，30秒，45秒时触发</p><p>“15&#x2F;5 * * * * ?”  每分钟的每15秒开始触发，每隔5秒触发</p><p>“15-30&#x2F;5 * * * * ?”  每分钟的15秒到30秒之间开始触发，每隔5秒触发</p><p>“0 0&#x2F;3 * * * ?”  每小时的第0分0秒开始，每三分钟触发</p><p>“0 15 10 ? * MON-FRI”  星期一到星期五的10点15分0秒触发</p><p>“0 15 10 L * ?”  每个月最后一天的10点15分0秒触发</p><p>“0 15 10 LW * ?”  每个月最后一个工作日的10点15分0秒触发</p><p>“0 15 10 ? * 5L”  每个月最后一个星期四的10点15分0秒触发</p><p>“0 15 10 ? * 5#3”  每个月第三周的星期四的10点15分0秒</p><p>Quartz是一种简单有效的定时任务的实现方法，特别对于定时任务有更多的配置方式，适用范围较广。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> cron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四道回溯算法题</title>
      <link href="/2023/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9B%E9%81%93%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2023/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9B%E9%81%93%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br><span class="line">示例:</span><br><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><span id="more"></span><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backTrack(nums,res,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res, </span></span><br><span class="line"><span class="params">                              LinkedList&lt;Integer&gt; track)</span>&#123;</span><br><span class="line">    <span class="comment">//如果当前集合的size等于数组的长度，说明现在已经拿到了一种组合，添加到res结果集中</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == track.size()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backTrack(nums, res, track);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h3><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>首先对nums进行排序，这样凡是相同的元素都会集中都一块去，在选择的时候判断当前一个元素的上一个元素是否和该元素相同，并且上一个元素是否已经被选择过了，如果满足相等并且已经别选择了，那么如果我们继续选择该元素，最终得到的组合结果一定是重复的，</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//必须排序，原因已经在上面说明</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">boolean</span>[] marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    backTrack(res,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(),nums,marked);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; ans, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] marked)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//需要同时满足，当前元素不是第一个元素，当前元素和上一个元素相同并且上一个元素被选择过了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !marked[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">            <span class="comment">//标记该元素被选择过了</span></span><br><span class="line">            marked[i] = <span class="literal">true</span>;</span><br><span class="line">            ans.addLast(nums[i]);</span><br><span class="line">            backTrack(res, ans,  nums, marked);</span><br><span class="line">            ans.removeLast();</span><br><span class="line">            <span class="comment">//在撤销选择之后，该元素又可以被选择了</span></span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，</span><br><span class="line">找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line">说明：</span><br><span class="line">    所有数字（包括 target）都是正整数。</span><br><span class="line">    解集不能包含重复的组合。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (candidates.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Arrays.sort(candidates);<span class="comment">//排序的目的就是为了加速剪枝</span></span><br><span class="line">    backTrack(res,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; ans, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">//满足条件，提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.addLast(candidates[i]);</span><br><span class="line">        backTrack(res,ans,candidates,target - candidates[i],i);</span><br><span class="line">        ans.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h3><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class="line">说明：</span><br><span class="line">    所有数字（包括目标数）都是正整数。</span><br><span class="line">    解集不能包含重复的组合。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (candidates.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="type">boolean</span>[] marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">    Arrays.sort(candidates);<span class="comment">//排序的目的就是为了加速剪枝</span></span><br><span class="line">    backTrack(res,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(),candidates,target,<span class="number">0</span>,marked);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; ans, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> begin,<span class="type">boolean</span>[] marked)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">//需要同时满足，当前元素不是第一个元素，当前元素和上一个元素相同并且上一个元素被选择过了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !marked[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素没有被使用过的话就可以使用</span></span><br><span class="line">        <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">            marked[i] = <span class="literal">true</span>;</span><br><span class="line">            ans.addLast(candidates[i]);</span><br><span class="line">            backTrack(res, ans, candidates, target - candidates[i], i + <span class="number">1</span>, marked);</span><br><span class="line">            ans.removeLast();</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring代码技巧</title>
      <link href="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="如何获取Spring容器对象"><a href="#如何获取Spring容器对象" class="headerlink" title="如何获取Spring容器对象"></a>如何获取Spring容器对象</h3><h4 id="实现BeanFactoryAware接口"><a href="#实现BeanFactoryAware接口" class="headerlink" title="实现BeanFactoryAware接口"></a>实现BeanFactoryAware接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PersonService implements BeanFactoryAware &#123;</span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        Person person = (Person) beanFactory.getBean(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>BeanFactoryAware</code>接口，然后重写<code>setBeanFactory</code>方法，就能从该方法中获取到spring容器对象。</p><span id="more"></span><h4 id="实现ApplicationContextAware接口"><a href="#实现ApplicationContextAware接口" class="headerlink" title="实现ApplicationContextAware接口"></a>实现ApplicationContextAware接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PersonService2 implements ApplicationContextAware &#123;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        Person person = (Person) applicationContext.getBean(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>ApplicationContextAware</code>接口，然后重写<code>setApplicationContext</code>方法，也能从该方法中获取到spring容器对象。</p><h4 id="实现ApplicationListener接口"><a href="#实现ApplicationListener接口" class="headerlink" title="实现ApplicationListener接口"></a>实现ApplicationListener接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PersonService3 implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        applicationContext = event.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        Person person = (Person) applicationContext.getBean(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>ApplicationListener</code>接口，需要注意的是该接口接收的泛型是<code>ContextRefreshedEvent</code>类，然后重写<code>onApplicationEvent</code>方法，也能从该方法中获取到spring容器对象。</p><p>此外，不得不提一下<code>Aware</code>接口，它其实是一个空接口，里面不包含任何方法。</p><p>它表示已感知的意思，通过这类接口可以获取指定对象，比如：</p><ul><li>通过BeanFactoryAware获取BeanFactory</li><li>通过ApplicationContextAware获取ApplicationContext</li><li>通过BeanNameAware获取BeanName等</li></ul><p>Aware接口是很常用的功能，目前包含如下功能：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/1.png" alt="图片"></p><h3 id="如何初始化Bean"><a href="#如何初始化Bean" class="headerlink" title="如何初始化Bean"></a>如何初始化Bean</h3><p>spring中支持3种初始化bean的方法：</p><ul><li>xml中指定init-method方法</li><li>使用@PostConstruct注解</li><li>实现InitializingBean接口</li></ul><p>第一种方法太古老了，现在用的人不多，具体用法就不介绍了。</p><h4 id="使用-PostConstruct注解"><a href="#使用-PostConstruct注解" class="headerlink" title="使用@PostConstruct注解"></a>使用@PostConstruct注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AService &#123;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;===初始化===&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要初始化的方法上增加<code>@PostConstruct</code>注解，这样就有初始化的能力。</p><h4 id="实现InitializingBean接口"><a href="#实现InitializingBean接口" class="headerlink" title="实现InitializingBean接口"></a>实现InitializingBean接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BService implements InitializingBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;===初始化===&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>InitializingBean</code>接口，重写<code>afterPropertiesSet</code>方法，该方法中可以完成初始化功能。</p><p>这里顺便抛出一个有趣的问题：<code>init-method</code>、<code>PostConstruct</code> 和 <code>InitializingBean</code> 的执行顺序是什么样的？</p><p>决定他们调用顺序的关键代码在<code>AbstractAutowireCapableBeanFactory</code>类的<code>initializeBean</code>方法中。</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/2.png" alt="图片"></p><p>这段代码中会先调用<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法，而<code>PostConstruct</code>是通过<code>InitDestroyAnnotationBeanPostProcessor</code>实现的，它就是一个<code>BeanPostProcessor</code>，所以<code>PostConstruct</code>先执行。</p><p>而<code>invokeInitMethods</code>方法中的代码：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/3.png" alt="图片"></p><p>决定了先调用<code>InitializingBean</code>，再调用<code>init-method</code>。</p><p>所以得出结论，他们的调用顺序是：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/4.png" alt="图片"></p><h3 id="自定义自己的Scope"><a href="#自定义自己的Scope" class="headerlink" title="自定义自己的Scope"></a>自定义自己的Scope</h3><p>我们都知道<code>spring</code>默认支持的<code>Scope</code>只有两种：</p><ul><li>singleton 单例，每次从spring容器中获取到的bean都是同一个对象。</li><li>prototype 多例，每次从spring容器中获取到的bean都是不同的对象。</li></ul><p><code>spring web</code>又对<code>Scope</code>进行了扩展，增加了：</p><ul><li>RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。</li><li>SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。</li></ul><p>即便如此，有些场景还是无法满足我们的要求。</p><p>比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？</p><p>这就需要自定义<code>Scope</code>了。</p><p>第一步实现<code>Scope</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalScope</span> <span class="keyword">implements</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">THREAD_LOCAL_SCOPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> THREAD_LOCAL_SCOPE.get();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getObject();</span><br><span class="line">        THREAD_LOCAL_SCOPE.set(object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">remove</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        THREAD_LOCAL_SCOPE.remove();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveContextualObject</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConversationId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步将新定义的<code>Scope</code>注入到spring容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        beanFactory.registerScope(<span class="string">&quot;threadLocalScope&quot;</span>, <span class="keyword">new</span> <span class="title class_">ThreadLocalScope</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步使用新定义的<code>Scope</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;threadLocalScope&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>说起<code>FactoryBean</code>就不得不提<code>BeanFactory</code>，因为面试官老喜欢问它们的区别。</p><ul><li>BeanFactory：spring容器的顶级接口，管理bean的工厂。</li><li>FactoryBean：并非普通的工厂bean，它隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。</li></ul><p>如果你看过spring源码，会发现它有70多个地方在用FactoryBean接口。</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/5.png" alt="图片"></p><p>上面这张图足以说明该接口的重要性，请勿忽略它好吗？</p><p>特别提一句：<code>mybatis</code>的<code>SqlSessionFactory</code>对象就是通过<code>SqlSessionFactoryBean</code>类创建的。</p><p>我们一起定义自己的<code>FactoryBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data1</span> <span class="operator">=</span> buildData1();</span><br><span class="line">        <span class="type">String</span> <span class="variable">data2</span> <span class="operator">=</span> buildData2();</span><br><span class="line">        <span class="keyword">return</span> buildData3(data1, data2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildData1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildData2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildData3</span><span class="params">(String data1, String data2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data1 + data2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>FactoryBean</code>实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBeanService</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">myFactoryBean</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(myFactoryBean);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">myFactoryBean1</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;&amp;myFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(myFactoryBean1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getBean(&quot;myFactoryBean&quot;);</code>获取的是MyFactoryBeanService类中getObject方法返回的对象，</li><li><code>getBean(&quot;&amp;myFactoryBean&quot;);</code>获取的才是MyFactoryBean对象。</li></ul><h3 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h3><p>spring目前支持3中类型转换器：</p><ul><li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li><li>ConverterFactory&lt;S, R&gt;：将 S 类型对象转为 R 类型及子类对象</li><li>GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</li></ul><p>这3种类型转换器使用的场景不一样，我们以<code>Converter</code>为例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？</p><p>第一步，定义一个实体<code>User</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Date registerDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，实现<code>Converter</code>接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line">    private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String source) &#123;</span><br><span class="line">        if (source != null &amp;&amp; !&quot;&quot;.equals(source)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return simpleDateFormat.parse(source);</span><br><span class="line">            &#125; catch (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，将新定义的类型转换器注入到spring容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        registry.addConverter(new DateConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，调用接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    public String save(@RequestBody User user) &#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求接口时<code>User</code>对象中<code>registerDate</code>字段会被自动转换成<code>Date</code>类型。</p><h3 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h3><p>spring mvc拦截器根spring拦截器相比，它里面能够获取<code>HttpServletRequest</code>和<code>HttpServletResponse</code> 等web对象实例。</p><p>spring mvc拦截器的顶层接口是：<code>HandlerInterceptor</code>，包含三个方法：</p><ul><li>preHandle 目标方法执行前执行</li><li>postHandle 目标方法执行后执行</li><li>afterCompletion 请求完成时执行</li></ul><p>为了方便我们一般情况会用HandlerInterceptor接口的实现类<code>HandlerInterceptorAdapter</code>类。</p><p>假如有权限认证、日志、统计的场景，可以使用该拦截器。</p><p>第一步，继承<code>HandlerInterceptorAdapter</code>类定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span> (checkAuth(requestUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkAuth</span><span class="params">(String requestUrl)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===权限校验===&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，将该拦截器注册到spring容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebAuthConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthInterceptor <span class="title function_">getAuthInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。</p><p>该拦截器其实相对来说，比较简单，可以在<code>DispatcherServlet</code>类的<code>doDispatch</code>方法中看到调用过程：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/6.png" alt="图片"></p><h3 id="Enable开关"><a href="#Enable开关" class="headerlink" title="Enable开关"></a>Enable开关</h3><p>不知道你有没有用过<code>Enable</code>开头的注解，比如：<code>EnableAsync</code>、<code>EnableCaching</code>、<code>EnableAspectJAutoProxy</code>等，这类注解就像开关一样，只要在<code>@Configuration</code>定义的配置类上加上这类注解，就能开启相关的功能。</p><p>是不是很酷？</p><p>让我们一起实现一个自己的开关：</p><p>第一步，定义一个LogFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录请求日志&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">&quot;记录响应日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，注册LogFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilterWebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogFilter <span class="title function_">timeFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里用了<code>@ConditionalOnWebApplication</code>注解，没有直接使用<code>@Configuration</code>注解。</p><p>第三步，定义开关<code>@EnableLog</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(LogFilterWebConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLog &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，只需在<code>springboot</code>启动类加上<code>@EnableLog</code>注解即可开启LogFilter记录请求和响应日志的功能。</p><h3 id="RestTemplate拦截器"><a href="#RestTemplate拦截器" class="headerlink" title="RestTemplate拦截器"></a>RestTemplate拦截器</h3><p>我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p><p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p><p>第一步，实现<code>ClientHttpRequestInterceptor</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        request.getHeaders().set(<span class="string">&quot;traceId&quot;</span>, MdcUtil.get());</span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，定义配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">            restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplateInterceptor <span class="title function_">restTemplateInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplateInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中MdcUtil其实是利用<code>MDC</code>工具在<code>ThreadLocal</code>中存储和获取traceId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdcUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID</span> <span class="operator">=</span> <span class="string">&quot;TRACE_ID&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MDC.get(TRACE_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        MDC.put(TRACE_ID, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到<code>MDC</code>中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不做任何处理请求add接口结果直接报错：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/7.png" alt="图片"></p><p>what？用户能直接看到错误信息？</p><p>这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/add&quot;)</span><br><span class="line">public String add() &#123;</span><br><span class="line">        String result = &quot;成功&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 10 / 0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            result = &quot;数据异常&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。</p><p>看起来挺不错的，但是有问题。。。</p><p>如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？</p><p>答案是否定的，这时全局异常处理就派上用场了：<code>RestControllerAdvice</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;数据异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;服务器内部异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retur nnull;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需在<code>handleException</code>方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>以前我们在使用异步功能时，通常情况下有三种方式：</p><ul><li>继承Thread类</li><li>实现Runable接口</li><li>使用线程池</li></ul><p>让我们一起回顾一下：</p><ol><li>继承Thread类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===call MyThread===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现Runable接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWork</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===call MyWork===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyWork</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Work</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===call work===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">MyThreadPool</span>.Work());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种实现异步的方法不能说不好，但是spring已经帮我们抽取了一些公共的地方，我们无需再继承<code>Thread</code>类或实现<code>Runable</code>接口，它都搞定了。</p><p>如何spring异步功能呢？</p><p>第一步，springboot项目启动类上加<code>@EnableAsync</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(WebApplicationType.SERVLET).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在需要使用异步的方法上加上<code>@Async</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===add==&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在使用的地方调用一下：personService.get();就拥有了异步功能，是不是很神奇。</p><p>默认情况下，spring会为我们的异步方法创建一个线程去执行，如果该方法被调用次数非常多的话，需要创建大量的线程，会导致资源浪费。</p><p>这时，我们可以定义一个线程池，异步方法将会被自动提交到线程池中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;thread.pool.corePoolSize:5&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;thread.pool.maxPoolSize:10&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;thread.pool.queueCapacity:200&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;thread.pool.keepAliveSeconds:30&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;thread.pool.threadNamePrefix:ASYNC_&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">MessageExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring异步的核心方法：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/8.png" alt="图片"></p><p>根据返回值不同，处理情况也不太一样，具体分为如下情况：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/9.png" alt="图片"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>spring cache架构图：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/10.png" alt="图片"></p><p>它目前支持多种缓存：</p><p><img src="/2023/10/22/Spring/Spring%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/11.png" alt="图片"></p><p>我们在这里以<code>caffeine</code>为例，它是<code>spring</code>官方推荐的。</p><p>第一步，引入<code>caffeine</code>的相关jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，配置<code>CacheManager</code>，开启<code>EnableCaching</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line">        <span class="comment">//Caffeine配置</span></span><br><span class="line">        Caffeine&lt;Object, Object&gt; caffeine = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//最后一次写入后经过固定时间过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//缓存的最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">1000</span>);</span><br><span class="line">        cacheManager.setCaffeine(caffeine);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，使用<code>Cacheable</code>注解获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryService</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//category是缓存名称,#type是具体的key，可支持el表达式</span></span><br><span class="line">   <span class="meta">@Cacheable(value = &quot;category&quot;, key = &quot;#type&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> CategoryModel <span class="title function_">getCategory</span><span class="params">(Integer type)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getCategoryByType(type);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> CategoryModel <span class="title function_">getCategoryByType</span><span class="params">(Integer type)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;根据不同的type:&quot;</span> + type + <span class="string">&quot;获取不同的分类数据&quot;</span>);</span><br><span class="line">       <span class="type">CategoryModel</span> <span class="variable">categoryModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CategoryModel</span>();</span><br><span class="line">       categoryModel.setId(<span class="number">1L</span>);</span><br><span class="line">       categoryModel.setParentId(<span class="number">0L</span>);</span><br><span class="line">       categoryModel.setName(<span class="string">&quot;电器&quot;</span>);</span><br><span class="line">       categoryModel.setLevel(<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">return</span> categoryModel;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用categoryService.getCategory()方法时，先从<code>caffine</code>缓存中获取数据，如果能够获取到数据则直接返回该数据，不会进入方法体。如果不能获取到数据，则直接方法体中的代码获取到数据，然后放到<code>caffine</code>缓存中。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个登录案例，学会委派设计模式</title>
      <link href="/2023/10/22/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B%EF%BC%8C%E5%AD%A6%E4%BC%9A%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/22/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B%EF%BC%8C%E5%AD%A6%E4%BC%9A%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>场景：有多种登录方式，如果每种方式登录成功后要记录登录的日志信息，并且每种登录方式的token生成策略不一样。</p><p>引入委派模式，可以认为是当前对象知道要做某些事，但是却不会具体的实现，好比经理知道每天的任务，但是具体实现的时候要交给自己的小弟去做。</p><span id="more"></span><p>代码如下（抽象类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoginService</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(UserInfo user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;账号密码登录&quot;</span>);</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> serMapper.getUserInfo(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="built_in">this</span>.getToken();</span><br><span class="line">        <span class="built_in">this</span>.sendLog();</span><br><span class="line">         <span class="comment">// 等等各种操作此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置登录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sendLog</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取token</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getToken</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建抽象类，创建抽象方法<code>sendLog</code>和<code>getToken</code>,子类继承抽象类，实现抽象方法。</p><p>代码如下（短信登录示例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SmsLoginService extends AbstractLoginService &#123;</span><br><span class="line">    //手机号</span><br><span class="line">    //验证码</span><br><span class="line">    @Override</span><br><span class="line">    public void login(UserInfo user)&#123;</span><br><span class="line">        System.out.println(&quot;短信登录&quot;);</span><br><span class="line">        //验证验证码是否正确</span><br><span class="line">        this.checkCode(user.getMobile(),user.getCode());</span><br><span class="line">        UserInfo userInfo = null;//this.userMapper.getUserInfo(user.getMobile());</span><br><span class="line">        super.login(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void sendLog() &#123;</span><br><span class="line">        System.out.println(&quot;这里设置短信登录日志信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void getToken() &#123;</span><br><span class="line">        System.out.println(&quot;获取短信登录token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void checkCode(String mobile, String code) &#123;</span><br><span class="line">        System.out.println(&quot;验证验证码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类实现抽象方法后，可以实现不同的登录方式的发送登录日志和获取token的实现各不相同。</p><p><strong>总结</strong></p><p>委派模式即一件事情（或一个请求）对象本身不知道怎样处理，对象把请求交给其它对象来做。</p><p>在spring源码中可以看到更多委派模式的代码示例，</p><p><strong>例如：</strong></p><ol><li><code>AbstractApplicationContext</code>类中<code>obtainFreshBeanFactory</code>方法中的<code>refreshBeanFactory</code>方法，和我这个例子类似，主类不关注或者说不知道如何实现<code>refreshBeanFactory</code>方法，交给子类实现，达到了委派的效果。</li><li><code>DispatcherServlet</code>这个springMVC的前端控制器或者说这就是一个<strong>转发器</strong>。所有的信息都会经过这个类，但是这个类缺只是转发，具体实现委派给了<code>HandlerMapping</code>、视图解析器等等。达到了委派的效果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 委派模式 </tag>
            
            <tag> 模板方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java细粒度锁实现的3种方式</title>
      <link href="/2023/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>借鉴concurrentHashMap的分段思想，提前生成一定数量的锁，具体使用的时候再根据key来返回对应的lock。这是几个实现里最简单，性能最高，也是最终被采用的锁策略，代码如下：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分段锁，系统提供一定数量的原始锁，根据传入对象的哈希值获取对应的锁并加锁</span></span><br><span class="line"><span class="comment">* 注意：要锁的对象的哈希值如果发生改变，有可能导致锁无法成功释放!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentLock</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">segments</span> <span class="operator">=</span> <span class="number">16</span>;<span class="comment">//默认分段数量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, ReentrantLock&gt; lockMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SegmentLock</span><span class="params">()</span> &#123;</span><br><span class="line">       init(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SegmentLock</span><span class="params">(Integer counts, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       init(counts, fair);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Integer counts, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (counts != <span class="literal">null</span>) &#123;</span><br><span class="line">           segments = counts;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; segments; i++) &#123;</span><br><span class="line">           lockMap.put(i, <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(T key)</span> &#123;</span><br><span class="line">       <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> lockMap.get(key.hashCode() % segments);</span><br><span class="line">       lock.lock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(T key)</span> &#123;</span><br><span class="line">       <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> lockMap.get(key.hashCode() % segments);</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希锁"><a href="#哈希锁" class="headerlink" title="哈希锁"></a>哈希锁</h3><p>在上述分段锁的基础上发展起来的第二种锁策略，目的是实现真正意义上的细粒度锁。每个哈希值不同的对象都能获得自己独立的锁。在测试中，在被锁住的代码执行速度飞快的情况下，效率比分段锁慢 30% 左右。如果有长耗时操作，感觉表现应该会更好。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashLock</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFair</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> SegmentLock&lt;T&gt; segmentLock = <span class="keyword">new</span> <span class="title class_">SegmentLock</span>&lt;&gt;();<span class="comment">//分段锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;T, LockInfo&gt; lockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashLock</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       isFair = fair;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(T key)</span> &#123;</span><br><span class="line">       LockInfo lockInfo;</span><br><span class="line">       segmentLock.lock(key);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           lockInfo = lockMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (lockInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">               lockInfo = <span class="keyword">new</span> <span class="title class_">LockInfo</span>(isFair);</span><br><span class="line">               lockMap.put(key, lockInfo);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               lockInfo.count.incrementAndGet();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           segmentLock.unlock(key);</span><br><span class="line">       &#125;</span><br><span class="line">       lockInfo.lock.lock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(T key)</span> &#123;</span><br><span class="line">       <span class="type">LockInfo</span> <span class="variable">lockInfo</span> <span class="operator">=</span> lockMap.get(key);</span><br><span class="line">       <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">           segmentLock.lock(key);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">                   lockMap.remove(key);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               segmentLock.unlock(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       lockInfo.count.decrementAndGet();</span><br><span class="line">       lockInfo.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LockInfo</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> ReentrantLock lock;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">LockInfo</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.lock.lock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="弱引用锁"><a href="#弱引用锁" class="headerlink" title="弱引用锁"></a>弱引用锁</h3><p>哈希锁因为引入的分段锁来保证锁创建和销毁的同步，总感觉有点瑕疵，所以写了第三个锁来寻求更好的性能和更细粒度的锁。这个锁的思想是借助java的弱引用来创建锁，把锁的销毁交给jvm的垃圾回收，来避免额外的消耗。</p><p>有点遗憾的是因为使用了ConcurrentHashMap作为锁的容器，所以没能真正意义上的摆脱分段锁。这个锁的性能比 HashLock 快10% 左右。锁代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 弱引用锁，为每个独立的哈希值提供独立的锁功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashLock</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> ConcurrentHashMap&lt;T, WeakLockRef&lt;T, ReentrantLock&gt;&gt; lockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">private</span> ReferenceQueue&lt;ReentrantLock&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> ReentrantLock <span class="title function_">get</span><span class="params">(T key)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (lockMap.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">           clearEmptyRef();</span><br><span class="line">       &#125;</span><br><span class="line">       WeakReference&lt;ReentrantLock&gt; lockRef = lockMap.get(key);</span><br><span class="line">       <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> (lockRef == <span class="literal">null</span> ? <span class="literal">null</span> : lockRef.get());</span><br><span class="line">       <span class="keyword">while</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">           lockMap.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">WeakLockRef</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(), queue, key));</span><br><span class="line">           lockRef = lockMap.get(key);</span><br><span class="line">           lock = (lockRef == <span class="literal">null</span> ? <span class="literal">null</span> : lockRef.get());</span><br><span class="line">           <span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> lock;</span><br><span class="line">           &#125;</span><br><span class="line">           clearEmptyRef();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> lock;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearEmptyRef</span><span class="params">()</span> &#123;</span><br><span class="line">       Reference&lt;? <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&gt; ref;</span><br><span class="line">       <span class="keyword">while</span> ((ref = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">           WeakLockRef&lt;T, ? <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&gt; weakLockRef = (WeakLockRef&lt;T, ? <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&gt;) ref;</span><br><span class="line">           lockMap.remove(weakLockRef.key);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WeakLockRef</span>&lt;T, K&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;K&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">WeakLockRef</span><span class="params">(K referent, ReferenceQueue&lt;? <span class="built_in">super</span> K&gt; q, T key)</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>(referent, q);</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程基础-Thread</title>
      <link href="/2023/10/21/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-Thread/"/>
      <url>/2023/10/21/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-Thread/</url>
      
        <content type="html"><![CDATA[<p><code>java.lang.Thread</code>是 Java 实现多线程编程最核心的类，学习<code>Thread</code>类中的方法，是学习多线程的第一步。</p><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><p>在 JDK 1.8 版本中，创建线程总共有四种方式：</p><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>使用 Callable 和 Future 创建线程</li><li>使用 JDK 8 的 Lambda 创建线程</li></ul><span id="more"></span><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><p>通过继承<code>Thread</code>类来创建线程是最简单的一种方法，继承类重写<code>run()</code>方法，然后通过线程对象实例去调用<code>start()</code>方法即可启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Thread创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h4 id="通过实现Runnable接口创建线程"><a href="#通过实现Runnable接口创建线程" class="headerlink" title="通过实现Runnable接口创建线程"></a>通过实现Runnable接口创建线程</h4><p>通过实现<code>Runnable</code>接口来创建线程也是最简单的一种方法，同时也是最常用的一种方式。开发者只需要实现<code>Runnable</code>接口，然后通过一个<code>Thread</code>类来启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h4 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h4><p>相比通过实现<code>Runnable</code>接口来创建线程，使用<code>Callable</code>和<code>Future</code>组合来创建线程可以实现获取线程执行结果，弥补了调用线程没有返回值的情况，可以看做是<code>Runnable</code>的一个补充，<code>Callable</code>和<code>Future</code>是 JDK1.5 版本中加入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="comment">// 通过阻塞方式获取线程执行结果</span></span><br><span class="line">System.out.println(ft.get());</span><br></pre></td></tr></table></figure><h4 id="使用Lambda创建线程"><a href="#使用Lambda创建线程" class="headerlink" title="使用Lambda创建线程"></a>使用Lambda创建线程</h4><p>Lambda 表达式，是从 JDK1.8 版本开始加入的，可以看作成通过实现<code>Runnable</code>接口创建线程的一种简写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在运行！&quot;</span>)).start();</span><br></pre></td></tr></table></figure><h4 id="几种创建方式对比"><a href="#几种创建方式对比" class="headerlink" title="几种创建方式对比"></a>几种创建方式对比</h4><p>以上四种方式都可以创建线程，使用继承<code>Thread</code>类的方式创建线程时，编写简单，如果需要访问当前线程，无需使用<code>Thread.currentThread()</code>方法，直接使用<code>this</code>即可获得当前线程。</p><p>采用实现<code>Runnable</code>、<code>Callable</code>接口的方式创建线程时，线程类只是实现了 <code>Runnable</code>或<code>Callable</code>接口，同时还可以继承其他类，最后通过<code>Thread</code>类来启动线程。它也是最常用的一种创建线程方式，通过接口方式来编程，可以实现代码更加统一。</p><p>其实通过继承<code>Thread</code>类创建线程的方式，本质上也可以看成实现了<code>Runnable</code>接口的一个实例，打开源码<code>Thread</code>，你会发现这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要特别注意的地方是</strong>：<strong>真正启动线程的是<code>start()</code>方法而不是<code>run()</code>方法，单独调用<code>run()</code>方法和调用普通的成员方法一样，不能启动线程</strong>。</p><h3 id="Thread的常用方法"><a href="#Thread的常用方法" class="headerlink" title="Thread的常用方法"></a>Thread的常用方法</h3><p>Thread 类常用的方法主要有三大块：</p><ul><li>构造方法</li><li>实例方法</li><li>静态方法</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>在 JDK 中，Thread 类提供了如下几个常用的构造方法来创建线程。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Thread()</td><td align="left">创建一个默认设置的线程实例，线程名称采用自增ID命名</td></tr><tr><td align="left">Thread(Runnable target)</td><td align="left">创建一个包含可执行对象的线程实例</td></tr><tr><td align="left">Thread(Runnable target, String name)</td><td align="left">创建一个包含可执行对象，指定名称的线程实例</td></tr><tr><td align="left">Thread(String name)</td><td align="left">创建一个指定名称的线程实例</td></tr><tr><td align="left">Thread(ThreadGroup group, String name)</td><td align="left">创建一个指定线程组，线程名称的线程实例</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target)</td><td align="left">创建一个指定线程组，包含可执行对象的线程实例</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target, String name)</td><td align="left">创建一个指定线程组，包含可执行对象，指定线程名称的线程实例</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target, String name, long stackSize)</td><td align="left">创建一个指定线程组，包含可执行对象，指定名称以及堆栈大小的线程实例</td></tr></tbody></table><p>其中<code>Thread(Runnable target)</code>构造方法最常见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>其次<code>Thread(Runnable target, String name)</code>构造方法，可以指定线程名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;thread-demo&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>同时，还支持指定线程组来创建线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个线程组实例</span><br><span class="line">ThreadGroup tg = new ThreadGroup(&quot;线程组1&quot;);</span><br><span class="line">// 创建一个线程实例</span><br><span class="line">Thread thread = new Thread(tg,new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getThreadGroup().getName() + &quot;：&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;thread-demo&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>如果不显式指定线程组，JVM 会将创建的线程归到当前线程所属的线程组中。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>在 Java 中，实例方法只有实例对象才能调用，也就是<code>new</code>出来的对象或者反射出来的对象，类是无法直接调用的。</p><p>在 JDK 中，Thread 类提供了如下几个常用的实例方法来操作线程。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">public void start()</td><td align="left">启动线程</td></tr><tr><td align="left">public void run()</td><td align="left">线程进入可运行状态时，jvm 会调用该线程的 run 方法；单独调用 run 方法，不能启动线程</td></tr><tr><td align="left">public final void setName(String name)</td><td align="left">设置线程名称</td></tr><tr><td align="left">public final void setPriority(int priority)</td><td align="left">设置线程优先级，默认5，取值1-10</td></tr><tr><td align="left">public final void setDaemon(boolean on)</td><td align="left">设置线程为守护线程或用户线程，默认是用户线程</td></tr><tr><td align="left">public final void join(long millisec)</td><td align="left">挂起线程 xx 毫秒，参数可以不传</td></tr><tr><td align="left">public void interrupt()</td><td align="left">当线程受到阻塞时，调用此方法会抛出一个中断信号，让线程退出阻塞状态</td></tr><tr><td align="left">public final boolean isAlive()</td><td align="left">测试线程是否处于活动状态</td></tr></tbody></table><h5 id="start"><a href="#start" class="headerlink" title="start()"></a><strong>start()</strong></h5><p><code>start()</code>方法，简单的说就是启动线程，至于什么时候能运行，需要等待获取 CPU 时间片，然后调用线程对象的<code>run()</code>方法，产生一个异步执行的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            System.out.println(time + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，正在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CPU 什么时候执行线程的<code>run()</code>方法具有不确定，同时执行线程顺序也具有不确定性</strong>，这是采用多线程异步执行程序的一个主要特征。</p><p><strong>run()</strong></p><p>如果单独调用<code>run()</code>方法，不能启动线程，会像调用普通的成员方法一样，我们可以将上面例子中的<code>threadA.start()</code>改成<code>threadA.run()</code>，再看看结果如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">30</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">50</span>:<span class="number">983</span> 当前线程：main，正在运行</span><br><span class="line"><span class="number">2023</span>-08-<span class="number">30</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">50</span>:<span class="number">984</span> 当前线程：main，正在运行</span><br></pre></td></tr></table></figure><p>结果很明显，单独调用<code>Thread</code>类实例<code>run()</code>方法，是没有任何异步效果的，全部被主线程执行。</p><h5 id="setName"><a href="#setName" class="headerlink" title="setName()"></a><strong>setName()</strong></h5><p><code>setName()</code>方法，简而言之就是设置线程名称，如果不手动设置，创建线程的时候 JDK 会给一个默认的线程名称，从 0 开始依次自增。</p><p>开发者可以通过<code>getName()</code>方法获取线程名称，也可以通过<code>getId()</code>获取当前线程的唯一标记，这个值用户无法手动设置，由<code>Thread</code>类自动生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;threadId:&quot;</span> + threadId + <span class="string">&quot;，threadName:&quot;</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.setName(<span class="string">&quot;thread-a&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">threadId:<span class="number">10</span>，threadName:thread-a</span><br></pre></td></tr></table></figure><h5 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a><strong>setPriority()</strong></h5><p><code>setPriority()</code>方法的作用是设置线程的优先级，取值范围：1～ 10，与此对应的还有<code>getPriority()</code>方法，用于获取线程的优先级。优先级越高，拥有优先获取 CPU 执行的优势。换句话说，当有两个线程在等待 CPU 执行时，优先级高的线程越容易被 CPU 选择执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> Thread.currentThread().getPriority();</span><br><span class="line">        System.out.println(<span class="string">&quot;threadName:&quot;</span> + threadName + <span class="string">&quot;，priority：&quot;</span> +  priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">            threadA.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>，priority：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>线程默认优先级为 5，如果不手动指定，那么线程优先级具有继承性</strong>，比如线程 A 启动线程 B，那么线程 B 的优先级和线程 A 的优先级相同。在实测过程中，可能效果并不明显，如果你的电脑 CPU 是多核的，线程数量较少的情况，可能会被多个 CPU 并行执行，具体执行环境取决于 CPU 。</p><p>需要特别注意的是：<strong>设置优先级只是很大程度上让某个线程尽可能获得比较多的执行机会，操作系统不能保证设置了优先级高的线程就一定会先运行或得到更多的 CPU 时间，具体执行哪一个线程，最终还是由 CPU 来决定</strong>。</p><p>另外有些 linux 操作系统是不区分优先级的，它把所有优先级都视为 5。<code>setPriority()</code>方法在实际的开发中，使用的并不多见。</p><h5 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a><strong>setDaemon()</strong></h5><p>在 Java 中线程分为两种，一种是用户线程，一种是守护线程。</p><p>守护线程是一种特殊的线程，它的作用是为其他线程的运行提供便利的服务，比如垃圾回收线程，就是最典型的守护线程。当 JVM 检测到应用程序中的所有线程都只有守护线程时，它将退出应用程序，因为没有存在的必要，服务的对象都没了，当然就需要销毁了。开发者可以通过使用<code>setDaemon()</code>方法，传递<code>true</code>作为参数，使线程成为一个守护线程，同时可以使用<code>isDaemon()</code>方法来检查线程是否是守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isDaemon</span> <span class="operator">=</span> Thread.currentThread().isDaemon();</span><br><span class="line">                System.out.println(<span class="string">&quot;threadName:&quot;</span> + threadName + <span class="string">&quot;,isDaemon:&quot;</span> + isDaemon);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程方法执行完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">threadName:Thread-<span class="number">0</span>,isDaemon:<span class="literal">true</span></span><br><span class="line">主线程方法执行完毕！</span><br></pre></td></tr></table></figure><p>需要特别注意的是：创建守护线程时，<code>setDaemon(true)</code>方法必须在线程<code>start()</code>方法之前，否则会抛异常。</p><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p><code>join()</code>方法的作用是让调用此方法的主线程被阻塞，仅当该方法执行完成以后，才能继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            System.out.println(time + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，正在运行&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让执行这个方法的线程阻塞（指的是主线程，不是threadA线程）</span></span><br><span class="line">        threadA.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(time + <span class="string">&quot; 主线程方法执行完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">06</span> 当前线程：Thread-<span class="number">0</span>，正在运行</span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">12</span>:<span class="number">46</span>:09 主线程方法执行完毕！</span><br></pre></td></tr></table></figure><p>从运行结果可以得出一个结论，主线程<code>main</code>调用<code>threadA.join()</code>方法时，会进入阻塞状态，直到线程实例<code>threadA</code>的<code>run()</code>方法执行完毕，主线程<code>main</code>从阻塞状态变成可运行状态。</p><p>此例中主线程<code>main</code>会无限期阻塞直到<code>threadA.run()</code>方法执行完毕。</p><p>比如某个业务场景下，主线程<code>main</code>的执行时间是 1s，子线程的执行时间是 10s，同时主线程依赖子线程执行完的结果，此时让主线程执行<code>join()</code>方法进行适度阻塞，可以实现此目标。</p><h5 id="interrrupt"><a href="#interrrupt" class="headerlink" title="interrrupt()"></a>interrrupt()</h5><p><code>interrupt()</code>方法的作用是当线程受到阻塞时，调用此方法会抛出一个中断信号，让线程退出阻塞状态，如果当前线程没有阻塞，是无法中断线程的。</p><p>与此对应的还有<code>isInterrupted()</code>方法，用于检查线程是否已经中断，但不清除状态标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            System.out.println(time + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，count:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查线程是否中断，没有尝试终止线程</span></span><br><span class="line">        <span class="keyword">if</span>(!threadA.isInterrupted())&#123;</span><br><span class="line">            threadA.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">55</span>:<span class="number">053</span> 当前线程：Thread-<span class="number">0</span>，count:<span class="number">0</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">55</span>:<span class="number">054</span> 当前线程：Thread-<span class="number">0</span>，count:<span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">55</span>:<span class="number">839</span> 当前线程：Thread-<span class="number">0</span>，count:<span class="number">9999</span></span><br></pre></td></tr></table></figure><p>如果当前线程没有阻塞，调用<code>interrupt()</code>起不到任何效果。</p><p>改造一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.out.println(time + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，count:&quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查线程是否中断，没有尝试终止线程</span></span><br><span class="line">        <span class="keyword">if</span>(!threadA.isInterrupted())&#123;</span><br><span class="line">            threadA.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">19</span>:<span class="number">792</span> 当前线程：Thread-<span class="number">0</span>，count:<span class="number">0</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">20</span>:<span class="number">798</span> 当前线程：Thread-<span class="number">0</span>，count:<span class="number">1</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at com.example.thread.ThreadA.run(ThreadA.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure><p>很明显，当线程处于阻塞状态时，调用<code>interrupt()</code>方法，可以让线程退出阻塞，起到终止线程的效果。</p><h5 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h5><p><code>isAlive()</code>方法的作用是检查线程是否处于活动状态，只要线程启动且没有终止，方法返回的就是<code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;，isAlive：&quot; + Thread.currentThread().isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadA threadA = new ThreadA();</span><br><span class="line">        System.out.println(&quot;begin == &quot; + threadA.isAlive());</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;end == &quot; + threadA.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">begin == false</span><br><span class="line">当前线程：Thread-0，isAlive：true</span><br><span class="line">end == false</span><br></pre></td></tr></table></figure><p>从运行结果上可以看出，线程启动前<code>isAlive=false</code>，线程运行中<code>isAlive=true</code>，线程运行完成<code>isAlive=false</code>。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在 JDK 中，Thread 类还提供了如下几个常用的静态方法来操作线程。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">public static Thread currentThread()</td><td align="left">返回对当前正在执行的线程对象的引用</td></tr><tr><td align="left">public static void yield()</td><td align="left">暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td align="left">public static void sleep(long millisec)</td><td align="left">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响</td></tr><tr><td align="left">public static boolean holdsLock(Object x)</td><td align="left">当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true</td></tr><tr><td align="left">public static void dumpStack()</td><td align="left">将当前线程的堆栈跟踪打印至标准错误流</td></tr></tbody></table><h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h5><p><code>currentThread()</code>方法的作用是返回当前正在执行线程对象的引用，在上文中有所介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块打印的线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法打印的线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run()方法打印的线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">静态块打印的线程名称：main</span><br><span class="line">构造方法打印的线程名称：main</span><br><span class="line"><span class="title function_">run</span><span class="params">()</span>方法打印的线程名称：Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出，线程类的构造方法、静态块是被主线程<code>main</code>调用的，而线程类的<code>run()</code>方法才是用户线程自己调用的。</p><p>另外一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法打印 Begin...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread打印的线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;this.getName打印的线程名称：&quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法打印 end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run()方法打印 Begin...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread打印的线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;this.getName打印的线程名称：&quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;run()方法打印 end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">构造方法打印 Begin...</span><br><span class="line">Thread.currentThread打印的线程名称：main</span><br><span class="line"><span class="built_in">this</span>.getName打印的线程名称：Thread-<span class="number">0</span></span><br><span class="line">构造方法打印 end...</span><br><span class="line">===============</span><br><span class="line">run()方法打印 Begin...</span><br><span class="line">Thread.currentThread打印的线程名称：Thread-<span class="number">0</span></span><br><span class="line"><span class="built_in">this</span>.getName打印的线程名称：Thread-<span class="number">0</span></span><br><span class="line">run()方法打印 end...</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，<code>Thread.currentThread</code>方法返回的未必是<code>Thread</code>本身，而是当前正在执行线程对象的引用，这和通过<code>this.XXX()</code>返回的对象是有区别的。</p><h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><p><code>yield()</code>方法的作用是暂停当前执行的线程对象，并执行其他线程。这个暂停会放弃 CPU 资源，并且放弃 CPU 的时间不确定，有可能刚放弃，就获得 CPU 资源了，也有可能放弃好一会儿，才会被 CPU 执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name  + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;t1&quot;</span>.equals(name)) &#123;</span><br><span class="line">                System.out.println(name  + <span class="string">&quot;:&quot;</span> + i +<span class="string">&quot;......yield.............&quot;</span>);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA1.start();</span><br><span class="line">        threadA2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">t1:<span class="number">0</span></span><br><span class="line">t2:<span class="number">0</span></span><br><span class="line">t1:<span class="number">0.</span>.....<span class="keyword">yield</span>.............</span><br><span class="line">t2:<span class="number">1</span></span><br><span class="line">t1:<span class="number">1</span></span><br><span class="line">t1:<span class="number">1.</span>.....<span class="keyword">yield</span>.............</span><br><span class="line">t1:<span class="number">2</span></span><br><span class="line">t1:<span class="number">2.</span>.....<span class="keyword">yield</span>.............</span><br><span class="line">t1:<span class="number">3</span></span><br><span class="line">t1:<span class="number">3.</span>.....<span class="keyword">yield</span>.............</span><br><span class="line">t1:<span class="number">4</span></span><br><span class="line">t1:<span class="number">4.</span>.....<span class="keyword">yield</span>.............</span><br><span class="line">t2:<span class="number">2</span></span><br><span class="line">t2:<span class="number">3</span></span><br><span class="line">t2:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>从运行结果上可以看出，调用<code>yield()</code>方法可以让线程放弃 CPU 资源，循环次数越多，越明显。</p><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><p><code>sleep()</code>方法的作用是在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。这个<strong>正在执行的线程</strong>指的是<code>Thread.currentThread()</code>返回的线程。</p><p>根据 JDK API 的说法，该线程不丢失任何监视器的所属权，换句话说就是不会释放锁，如果<code>sleep()</code>代码上下文被加锁了，锁依然在，只是 CPU 资源会让出给其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            System.out.println(begin + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            System.out.println(end + <span class="string">&quot; 当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">41</span>:<span class="number">459</span> 当前线程：Thread-<span class="number">0</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">31</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">44</span>:<span class="number">464</span> 当前线程：Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="holdsLock"><a href="#holdsLock" class="headerlink" title="holdsLock()"></a>holdsLock()</h5><p><code>holdsLock()</code>方法表示当且仅当<strong>当前线程在指定的对象上保持监视器锁时，才返回 true</strong>，简单的说就是检测一个线程是否拥有锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;lock&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，Holds Lock = &quot;</span> + Thread.holdsLock(lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，Holds Lock = &quot;</span> + Thread.holdsLock(lock));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">当前线程：Thread-<span class="number">0</span>，<span class="type">Holds</span> <span class="variable">Lock</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">当前线程：Thread-<span class="number">0</span>，<span class="type">Holds</span> <span class="variable">Lock</span> <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="dumpStack"><a href="#dumpStack" class="headerlink" title="dumpStack()"></a>dumpStack()</h5><p><code>dumpStack()</code>方法的作用是将当前线程的堆栈跟踪打印至标准错误流。此方法仅用于调试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.dumpStack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">当前线程：Thread-<span class="number">0</span></span><br><span class="line">java.lang.Exception: Stack trace</span><br><span class="line"> at java.lang.Thread.dumpStack(Thread.java:<span class="number">1336</span>)</span><br><span class="line"> at com.example.thread.ThreadA.run(ThreadA.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p><code>Thread.dumpStack</code>会将当前线程的堆栈跟踪信息打印出控制台。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
